"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/zotero-plugin-toolkit/dist/utils/debugBridge.js
  var require_debugBridge = __commonJS({
    "node_modules/zotero-plugin-toolkit/dist/utils/debugBridge.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DebugBridge = void 0;
      var basic_1 = require_basic();
      var toolkitGlobal_1 = __importDefault(require_toolkitGlobal());
      var DebugBridge = class {
        get version() {
          return DebugBridge.version;
        }
        get disableDebugBridgePassword() {
          return this._disableDebugBridgePassword;
        }
        set disableDebugBridgePassword(value) {
          this._disableDebugBridgePassword = value;
        }
        get password() {
          return basic_1.BasicTool.getZotero().Prefs.get(DebugBridge.passwordPref, true);
        }
        set password(v) {
          basic_1.BasicTool.getZotero().Prefs.set(DebugBridge.passwordPref, v, true);
        }
        constructor() {
          this._disableDebugBridgePassword = false;
          this.initializeDebugBridge();
        }
        static setModule(instance) {
          var _a;
          if (!((_a = instance.debugBridge) === null || _a === void 0 ? void 0 : _a.version) || instance.debugBridge.version < DebugBridge.version) {
            instance.debugBridge = new DebugBridge();
          }
        }
        initializeDebugBridge() {
          const debugBridgeExtension = {
            noContent: true,
            doAction: async (uri) => {
              var _a;
              const Zotero2 = basic_1.BasicTool.getZotero();
              const window2 = Zotero2.getMainWindow();
              const uriString = uri.spec.split("//").pop();
              if (!uriString) {
                return;
              }
              const params = {};
              (_a = uriString.split("?").pop()) === null || _a === void 0 ? void 0 : _a.split("&").forEach((p) => {
                params[p.split("=")[0]] = decodeURIComponent(p.split("=")[1]);
              });
              const skipPasswordCheck = toolkitGlobal_1.default.getInstance().debugBridge.disableDebugBridgePassword;
              let allowed = false;
              if (skipPasswordCheck) {
                allowed = true;
              } else {
                if (typeof params.password === "undefined" && typeof this.password === "undefined") {
                  allowed = window2.confirm(`External App ${params.app} wants to execute command without password.
Command:
${(params.run || params.file || "").slice(0, 100)}
If you do not know what it is, please click Cancel to deny.`);
                } else {
                  allowed = this.password === params.password;
                }
              }
              if (allowed) {
                if (params.run) {
                  try {
                    const AsyncFunction = Object.getPrototypeOf(async function() {
                    }).constructor;
                    const f = new AsyncFunction("Zotero,window", params.run);
                    await f(Zotero2, window2);
                  } catch (e) {
                    Zotero2.debug(e);
                    window2.console.log(e);
                  }
                }
                if (params.file) {
                  try {
                    Services.scriptloader.loadSubScript(params.file, {
                      Zotero: Zotero2,
                      window: window2
                    });
                  } catch (e) {
                    Zotero2.debug(e);
                    window2.console.log(e);
                  }
                }
              }
            },
            newChannel: function(uri) {
              this.doAction(uri);
            }
          };
          Services.io.getProtocolHandler("zotero").wrappedJSObject._extensions["zotero://ztoolkit-debug"] = debugBridgeExtension;
        }
      };
      exports.DebugBridge = DebugBridge;
      DebugBridge.version = 2;
      DebugBridge.passwordPref = "extensions.zotero.debug-bridge.password";
    }
  });

  // node_modules/zotero-plugin-toolkit/dist/utils/pluginBridge.js
  var require_pluginBridge = __commonJS({
    "node_modules/zotero-plugin-toolkit/dist/utils/pluginBridge.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PluginBridge = void 0;
      var basic_1 = require_basic();
      var PluginBridge = class {
        get version() {
          return PluginBridge.version;
        }
        constructor() {
          this.initializePluginBridge();
        }
        static setModule(instance) {
          var _a;
          if (!((_a = instance.pluginBridge) === null || _a === void 0 ? void 0 : _a.version) || instance.pluginBridge.version < PluginBridge.version) {
            instance.pluginBridge = new PluginBridge();
          }
        }
        initializePluginBridge() {
          const { AddonManager } = ChromeUtils.import("resource://gre/modules/AddonManager.jsm");
          const Zotero2 = basic_1.BasicTool.getZotero();
          const pluginBridgeExtension = {
            noContent: true,
            doAction: async (uri) => {
              var _a;
              try {
                const uriString = uri.spec.split("//").pop();
                if (!uriString) {
                  return;
                }
                const params = {};
                (_a = uriString.split("?").pop()) === null || _a === void 0 ? void 0 : _a.split("&").forEach((p) => {
                  params[p.split("=")[0]] = decodeURIComponent(p.split("=")[1]);
                });
                if (params.action === "install" && params.url) {
                  if (params.minVersion && Services.vc.compare(Zotero2.version, params.minVersion) < 0 || params.maxVersion && Services.vc.compare(Zotero2.version, params.maxVersion) > 0) {
                    throw new Error(`Plugin is not compatible with Zotero version ${Zotero2.version}.The plugin requires Zotero version between ${params.minVersion} and ${params.maxVersion}.`);
                  }
                  const addon2 = await AddonManager.getInstallForURL(params.url);
                  if (addon2 && addon2.state === AddonManager.STATE_AVAILABLE) {
                    addon2.install();
                    hint("Plugin installed successfully.", true);
                  } else {
                    throw new Error(`Plugin ${params.url} is not available.`);
                  }
                }
              } catch (e) {
                Zotero2.logError(e);
                hint(e.message, false);
              }
            },
            newChannel: function(uri) {
              this.doAction(uri);
            }
          };
          Services.io.getProtocolHandler("zotero").wrappedJSObject._extensions["zotero://plugin"] = pluginBridgeExtension;
        }
      };
      exports.PluginBridge = PluginBridge;
      PluginBridge.version = 1;
      function hint(content, success) {
        const progressWindow = new Zotero.ProgressWindow({ closeOnClick: true });
        progressWindow.changeHeadline("Plugin Toolkit");
        progressWindow.progress = new progressWindow.ItemProgress(success ? "chrome://zotero/skin/tick.png" : "chrome://zotero/skin/cross.png", content);
        progressWindow.progress.setProgress(100);
        progressWindow.show();
        progressWindow.startCloseTimer(5e3);
      }
    }
  });

  // node_modules/zotero-plugin-toolkit/dist/managers/toolkitGlobal.js
  var require_toolkitGlobal = __commonJS({
    "node_modules/zotero-plugin-toolkit/dist/managers/toolkitGlobal.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ToolkitGlobal = void 0;
      var basic_1 = require_basic();
      var debugBridge_1 = require_debugBridge();
      var pluginBridge_1 = require_pluginBridge();
      var ToolkitGlobal = class {
        constructor() {
          initializeModules(this);
          this.currentWindow = basic_1.BasicTool.getZotero().getMainWindow();
        }
        /**
         * Get the global unique instance of `class ToolkitGlobal`.
         * @returns An instance of `ToolkitGlobal`.
         */
        static getInstance() {
          const Zotero2 = basic_1.BasicTool.getZotero();
          let requireInit = false;
          if (!("_toolkitGlobal" in Zotero2)) {
            Zotero2._toolkitGlobal = new ToolkitGlobal();
            requireInit = true;
          }
          const currentGlobal = Zotero2._toolkitGlobal;
          if (currentGlobal.currentWindow !== Zotero2.getMainWindow()) {
            checkWindowDependentModules(currentGlobal);
            requireInit = true;
          }
          if (requireInit) {
            initializeModules(currentGlobal);
          }
          return currentGlobal;
        }
      };
      exports.ToolkitGlobal = ToolkitGlobal;
      function initializeModules(instance) {
        setModule(instance, "fieldHooks", {
          _ready: false,
          getFieldHooks: {},
          setFieldHooks: {},
          isFieldOfBaseHooks: {}
        });
        setModule(instance, "itemTree", {
          _ready: false,
          columns: [],
          renderCellHooks: {}
        });
        setModule(instance, "itemBox", {
          _ready: false,
          fieldOptions: {}
        });
        setModule(instance, "shortcut", {
          _ready: false,
          eventKeys: []
        });
        setModule(instance, "prompt", {
          _ready: false,
          instance: void 0
        });
        setModule(instance, "readerInstance", {
          _ready: false,
          initializedHooks: {}
        });
        debugBridge_1.DebugBridge.setModule(instance);
        pluginBridge_1.PluginBridge.setModule(instance);
      }
      function setModule(instance, key, module2) {
        var _a;
        var _b;
        if (!module2) {
          return;
        }
        if (!instance[key]) {
          instance[key] = module2;
        }
        for (const moduleKey in module2) {
          (_a = (_b = instance[key])[moduleKey]) !== null && _a !== void 0 ? _a : _b[moduleKey] = module2[moduleKey];
        }
      }
      function checkWindowDependentModules(instance) {
        instance.currentWindow = basic_1.BasicTool.getZotero().getMainWindow();
        instance.itemTree = void 0;
        instance.itemBox = void 0;
        instance.shortcut = void 0;
        instance.prompt = void 0;
        instance.readerInstance = void 0;
      }
      exports.default = ToolkitGlobal;
    }
  });

  // node_modules/zotero-plugin-toolkit/dist/basic.js
  var require_basic = __commonJS({
    "node_modules/zotero-plugin-toolkit/dist/basic.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.unregister = exports.ManagerTool = exports.BasicTool = void 0;
      var toolkitGlobal_1 = __importDefault(require_toolkitGlobal());
      var BasicTool2 = class {
        get basicOptions() {
          return this._basicOptions;
        }
        /**
         *
         * @param basicTool Pass an BasicTool instance to copy its options.
         */
        constructor(data) {
          this.patchSign = "zotero-plugin-toolkit@2.0.0";
          this._basicOptions = {
            log: {
              _type: "toolkitlog",
              disableConsole: false,
              disableZLog: false,
              prefix: ""
            },
            debug: toolkitGlobal_1.default.getInstance().debugBridge,
            api: {
              pluginID: "zotero-plugin-toolkit@windingwind.com"
            }
          };
          this.updateOptions(data);
          return;
        }
        getGlobal(k) {
          const _Zotero = typeof Zotero !== "undefined" ? Zotero : Components.classes["@zotero.org/Zotero;1"].getService(Components.interfaces.nsISupports).wrappedJSObject;
          try {
            const window2 = _Zotero.getMainWindow();
            switch (k) {
              case "Zotero":
              case "zotero":
                return _Zotero;
              case "window":
                return window2;
              case "windows":
                return _Zotero.getMainWindows();
              case "document":
                return window2.document;
              case "ZoteroPane":
              case "ZoteroPane_Local":
                return _Zotero.getActiveZoteroPane();
              default:
                return window2[k];
            }
          } catch (e) {
            Zotero.logError(e);
          }
        }
        /**
         * Check if it's running on Zotero 7 (Firefox 102)
         */
        isZotero7() {
          return Zotero.platformMajorVersion >= 102;
        }
        /**
         * Get DOMParser.
         *
         * For Zotero 6: mainWindow.DOMParser or nsIDOMParser
         *
         * For Zotero 7: Firefox 102 support DOMParser natively
         */
        getDOMParser() {
          if (this.isZotero7()) {
            return new (this.getGlobal("DOMParser"))();
          }
          try {
            return new (this.getGlobal("DOMParser"))();
          } catch (e) {
            return Components.classes["@mozilla.org/xmlextras/domparser;1"].createInstance(Components.interfaces.nsIDOMParser);
          }
        }
        /**
         * If it's an XUL element
         * @param elem
         */
        isXULElement(elem) {
          return elem.namespaceURI === "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
        }
        /**
         * Create an XUL element
         *
         * For Zotero 6, use `createElementNS`;
         *
         * For Zotero 7+, use `createXULElement`.
         * @param doc
         * @param type
         * @example
         * Create a `<menuitem>`:
         * ```ts
         * const compat = new ZoteroCompat();
         * const doc = compat.getWindow().document;
         * const elem = compat.createXULElement(doc, "menuitem");
         * ```
         */
        createXULElement(doc, type) {
          if (this.isZotero7()) {
            return doc.createXULElement(type);
          } else {
            return doc.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul", type);
          }
        }
        /**
         * Output to both Zotero.debug and console.log
         * @param data e.g. string, number, object, ...
         */
        log(...data) {
          var _a;
          if (data.length === 0) {
            return;
          }
          const Zotero2 = this.getGlobal("Zotero");
          const console2 = this.getGlobal("console");
          let options;
          if (((_a = data[data.length - 1]) === null || _a === void 0 ? void 0 : _a._type) === "toolkitlog") {
            options = data.pop();
          } else {
            options = this._basicOptions.log;
          }
          try {
            if (options.prefix) {
              data.splice(0, 0, options.prefix);
            }
            if (!options.disableConsole) {
              console2.groupCollapsed(...data);
              console2.trace();
              console2.groupEnd();
            }
            if (!options.disableZLog) {
              Zotero2.debug(data.map((d) => {
                try {
                  return typeof d === "object" ? JSON.stringify(d) : String(d);
                } catch (e) {
                  Zotero2.debug(d);
                  return "";
                }
              }).join("\n"));
            }
          } catch (e) {
            console2.error(e);
            Zotero2.logError(e);
          }
        }
        /**
         * Patch a function
         * @deprecated Use `PatchManager` instead.
         * @param object The owner of the function
         * @param funcSign The signature of the function(function name)
         * @param ownerSign The signature of patch owner to avoid patching again
         * @param patcher The new wrapper of the patched function
         */
        patch(object, funcSign, ownerSign, patcher) {
          if (object[funcSign][ownerSign]) {
            throw new Error(`${String(funcSign)} re-patched`);
          }
          this.log("patching", funcSign, `by ${ownerSign}`);
          object[funcSign] = patcher(object[funcSign]);
          object[funcSign][ownerSign] = true;
        }
        updateOptions(source) {
          if (!source) {
            return;
          }
          if (source instanceof BasicTool2) {
            this._basicOptions = source._basicOptions;
          } else {
            this._basicOptions = source;
          }
        }
        static getZotero() {
          return typeof Zotero !== "undefined" ? Zotero : Components.classes["@zotero.org/Zotero;1"].getService(Components.interfaces.nsISupports).wrappedJSObject;
        }
      };
      exports.BasicTool = BasicTool2;
      var ManagerTool = class extends BasicTool2 {
      };
      exports.ManagerTool = ManagerTool;
      function unregister(tools) {
        Object.values(tools).forEach((tool) => {
          if (tool instanceof ManagerTool || typeof tool.unregisterAll === "function") {
            tool.unregisterAll();
          }
        });
      }
      exports.unregister = unregister;
    }
  });

  // node_modules/xml2js/lib/defaults.js
  var require_defaults = __commonJS({
    "node_modules/xml2js/lib/defaults.js"(exports) {
      (function() {
        exports.defaults = {
          "0.1": {
            explicitCharkey: false,
            trim: true,
            normalize: true,
            normalizeTags: false,
            attrkey: "@",
            charkey: "#",
            explicitArray: false,
            ignoreAttrs: false,
            mergeAttrs: false,
            explicitRoot: false,
            validator: null,
            xmlns: false,
            explicitChildren: false,
            childkey: "@@",
            charsAsChildren: false,
            includeWhiteChars: false,
            async: false,
            strict: true,
            attrNameProcessors: null,
            attrValueProcessors: null,
            tagNameProcessors: null,
            valueProcessors: null,
            emptyTag: ""
          },
          "0.2": {
            explicitCharkey: false,
            trim: false,
            normalize: false,
            normalizeTags: false,
            attrkey: "$",
            charkey: "_",
            explicitArray: true,
            ignoreAttrs: false,
            mergeAttrs: false,
            explicitRoot: true,
            validator: null,
            xmlns: false,
            explicitChildren: false,
            preserveChildrenOrder: false,
            childkey: "$$",
            charsAsChildren: false,
            includeWhiteChars: false,
            async: false,
            strict: true,
            attrNameProcessors: null,
            attrValueProcessors: null,
            tagNameProcessors: null,
            valueProcessors: null,
            rootName: "root",
            xmldec: {
              "version": "1.0",
              "encoding": "UTF-8",
              "standalone": true
            },
            doctype: null,
            renderOpts: {
              "pretty": true,
              "indent": "  ",
              "newline": "\n"
            },
            headless: false,
            chunkSize: 1e4,
            emptyTag: "",
            cdata: false
          }
        };
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/Utility.js
  var require_Utility = __commonJS({
    "node_modules/xmlbuilder/lib/Utility.js"(exports, module) {
      (function() {
        var assign, getValue, isArray, isEmpty, isFunction, isObject, isPlainObject, slice = [].slice, hasProp = {}.hasOwnProperty;
        assign = function() {
          var i, key, len, source, sources, target;
          target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
          if (isFunction(Object.assign)) {
            Object.assign.apply(null, arguments);
          } else {
            for (i = 0, len = sources.length; i < len; i++) {
              source = sources[i];
              if (source != null) {
                for (key in source) {
                  if (!hasProp.call(source, key))
                    continue;
                  target[key] = source[key];
                }
              }
            }
          }
          return target;
        };
        isFunction = function(val) {
          return !!val && Object.prototype.toString.call(val) === "[object Function]";
        };
        isObject = function(val) {
          var ref;
          return !!val && ((ref = typeof val) === "function" || ref === "object");
        };
        isArray = function(val) {
          if (isFunction(Array.isArray)) {
            return Array.isArray(val);
          } else {
            return Object.prototype.toString.call(val) === "[object Array]";
          }
        };
        isEmpty = function(val) {
          var key;
          if (isArray(val)) {
            return !val.length;
          } else {
            for (key in val) {
              if (!hasProp.call(val, key))
                continue;
              return false;
            }
            return true;
          }
        };
        isPlainObject = function(val) {
          var ctor, proto;
          return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && typeof ctor === "function" && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
        };
        getValue = function(obj) {
          if (isFunction(obj.valueOf)) {
            return obj.valueOf();
          } else {
            return obj;
          }
        };
        module.exports.assign = assign;
        module.exports.isFunction = isFunction;
        module.exports.isObject = isObject;
        module.exports.isArray = isArray;
        module.exports.isEmpty = isEmpty;
        module.exports.isPlainObject = isPlainObject;
        module.exports.getValue = getValue;
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLDOMImplementation.js
  var require_XMLDOMImplementation = __commonJS({
    "node_modules/xmlbuilder/lib/XMLDOMImplementation.js"(exports, module) {
      (function() {
        var XMLDOMImplementation;
        module.exports = XMLDOMImplementation = function() {
          function XMLDOMImplementation2() {
          }
          XMLDOMImplementation2.prototype.hasFeature = function(feature, version) {
            return true;
          };
          XMLDOMImplementation2.prototype.createDocumentType = function(qualifiedName, publicId, systemId) {
            throw new Error("This DOM method is not implemented.");
          };
          XMLDOMImplementation2.prototype.createDocument = function(namespaceURI, qualifiedName, doctype) {
            throw new Error("This DOM method is not implemented.");
          };
          XMLDOMImplementation2.prototype.createHTMLDocument = function(title) {
            throw new Error("This DOM method is not implemented.");
          };
          XMLDOMImplementation2.prototype.getFeature = function(feature, version) {
            throw new Error("This DOM method is not implemented.");
          };
          return XMLDOMImplementation2;
        }();
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js
  var require_XMLDOMErrorHandler = __commonJS({
    "node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js"(exports, module) {
      (function() {
        var XMLDOMErrorHandler;
        module.exports = XMLDOMErrorHandler = function() {
          function XMLDOMErrorHandler2() {
          }
          XMLDOMErrorHandler2.prototype.handleError = function(error) {
            throw new Error(error);
          };
          return XMLDOMErrorHandler2;
        }();
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLDOMStringList.js
  var require_XMLDOMStringList = __commonJS({
    "node_modules/xmlbuilder/lib/XMLDOMStringList.js"(exports, module) {
      (function() {
        var XMLDOMStringList;
        module.exports = XMLDOMStringList = function() {
          function XMLDOMStringList2(arr) {
            this.arr = arr || [];
          }
          Object.defineProperty(XMLDOMStringList2.prototype, "length", {
            get: function() {
              return this.arr.length;
            }
          });
          XMLDOMStringList2.prototype.item = function(index) {
            return this.arr[index] || null;
          };
          XMLDOMStringList2.prototype.contains = function(str) {
            return this.arr.indexOf(str) !== -1;
          };
          return XMLDOMStringList2;
        }();
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLDOMConfiguration.js
  var require_XMLDOMConfiguration = __commonJS({
    "node_modules/xmlbuilder/lib/XMLDOMConfiguration.js"(exports, module) {
      (function() {
        var XMLDOMConfiguration, XMLDOMErrorHandler, XMLDOMStringList;
        XMLDOMErrorHandler = require_XMLDOMErrorHandler();
        XMLDOMStringList = require_XMLDOMStringList();
        module.exports = XMLDOMConfiguration = function() {
          function XMLDOMConfiguration2() {
            var clonedSelf;
            this.defaultParams = {
              "canonical-form": false,
              "cdata-sections": false,
              "comments": false,
              "datatype-normalization": false,
              "element-content-whitespace": true,
              "entities": true,
              "error-handler": new XMLDOMErrorHandler(),
              "infoset": true,
              "validate-if-schema": false,
              "namespaces": true,
              "namespace-declarations": true,
              "normalize-characters": false,
              "schema-location": "",
              "schema-type": "",
              "split-cdata-sections": true,
              "validate": false,
              "well-formed": true
            };
            this.params = clonedSelf = Object.create(this.defaultParams);
          }
          Object.defineProperty(XMLDOMConfiguration2.prototype, "parameterNames", {
            get: function() {
              return new XMLDOMStringList(Object.keys(this.defaultParams));
            }
          });
          XMLDOMConfiguration2.prototype.getParameter = function(name) {
            if (this.params.hasOwnProperty(name)) {
              return this.params[name];
            } else {
              return null;
            }
          };
          XMLDOMConfiguration2.prototype.canSetParameter = function(name, value) {
            return true;
          };
          XMLDOMConfiguration2.prototype.setParameter = function(name, value) {
            if (value != null) {
              return this.params[name] = value;
            } else {
              return delete this.params[name];
            }
          };
          return XMLDOMConfiguration2;
        }();
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/NodeType.js
  var require_NodeType = __commonJS({
    "node_modules/xmlbuilder/lib/NodeType.js"(exports, module) {
      (function() {
        module.exports = {
          Element: 1,
          Attribute: 2,
          Text: 3,
          CData: 4,
          EntityReference: 5,
          EntityDeclaration: 6,
          ProcessingInstruction: 7,
          Comment: 8,
          Document: 9,
          DocType: 10,
          DocumentFragment: 11,
          NotationDeclaration: 12,
          Declaration: 201,
          Raw: 202,
          AttributeDeclaration: 203,
          ElementDeclaration: 204,
          Dummy: 205
        };
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLAttribute.js
  var require_XMLAttribute = __commonJS({
    "node_modules/xmlbuilder/lib/XMLAttribute.js"(exports, module) {
      (function() {
        var NodeType, XMLAttribute, XMLNode;
        NodeType = require_NodeType();
        XMLNode = require_XMLNode();
        module.exports = XMLAttribute = function() {
          function XMLAttribute2(parent, name, value) {
            this.parent = parent;
            if (this.parent) {
              this.options = this.parent.options;
              this.stringify = this.parent.stringify;
            }
            if (name == null) {
              throw new Error("Missing attribute name. " + this.debugInfo(name));
            }
            this.name = this.stringify.name(name);
            this.value = this.stringify.attValue(value);
            this.type = NodeType.Attribute;
            this.isId = false;
            this.schemaTypeInfo = null;
          }
          Object.defineProperty(XMLAttribute2.prototype, "nodeType", {
            get: function() {
              return this.type;
            }
          });
          Object.defineProperty(XMLAttribute2.prototype, "ownerElement", {
            get: function() {
              return this.parent;
            }
          });
          Object.defineProperty(XMLAttribute2.prototype, "textContent", {
            get: function() {
              return this.value;
            },
            set: function(value) {
              return this.value = value || "";
            }
          });
          Object.defineProperty(XMLAttribute2.prototype, "namespaceURI", {
            get: function() {
              return "";
            }
          });
          Object.defineProperty(XMLAttribute2.prototype, "prefix", {
            get: function() {
              return "";
            }
          });
          Object.defineProperty(XMLAttribute2.prototype, "localName", {
            get: function() {
              return this.name;
            }
          });
          Object.defineProperty(XMLAttribute2.prototype, "specified", {
            get: function() {
              return true;
            }
          });
          XMLAttribute2.prototype.clone = function() {
            return Object.create(this);
          };
          XMLAttribute2.prototype.toString = function(options) {
            return this.options.writer.attribute(this, this.options.writer.filterOptions(options));
          };
          XMLAttribute2.prototype.debugInfo = function(name) {
            name = name || this.name;
            if (name == null) {
              return "parent: <" + this.parent.name + ">";
            } else {
              return "attribute: {" + name + "}, parent: <" + this.parent.name + ">";
            }
          };
          XMLAttribute2.prototype.isEqualNode = function(node) {
            if (node.namespaceURI !== this.namespaceURI) {
              return false;
            }
            if (node.prefix !== this.prefix) {
              return false;
            }
            if (node.localName !== this.localName) {
              return false;
            }
            if (node.value !== this.value) {
              return false;
            }
            return true;
          };
          return XMLAttribute2;
        }();
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLNamedNodeMap.js
  var require_XMLNamedNodeMap = __commonJS({
    "node_modules/xmlbuilder/lib/XMLNamedNodeMap.js"(exports, module) {
      (function() {
        var XMLNamedNodeMap;
        module.exports = XMLNamedNodeMap = function() {
          function XMLNamedNodeMap2(nodes) {
            this.nodes = nodes;
          }
          Object.defineProperty(XMLNamedNodeMap2.prototype, "length", {
            get: function() {
              return Object.keys(this.nodes).length || 0;
            }
          });
          XMLNamedNodeMap2.prototype.clone = function() {
            return this.nodes = null;
          };
          XMLNamedNodeMap2.prototype.getNamedItem = function(name) {
            return this.nodes[name];
          };
          XMLNamedNodeMap2.prototype.setNamedItem = function(node) {
            var oldNode;
            oldNode = this.nodes[node.nodeName];
            this.nodes[node.nodeName] = node;
            return oldNode || null;
          };
          XMLNamedNodeMap2.prototype.removeNamedItem = function(name) {
            var oldNode;
            oldNode = this.nodes[name];
            delete this.nodes[name];
            return oldNode || null;
          };
          XMLNamedNodeMap2.prototype.item = function(index) {
            return this.nodes[Object.keys(this.nodes)[index]] || null;
          };
          XMLNamedNodeMap2.prototype.getNamedItemNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented.");
          };
          XMLNamedNodeMap2.prototype.setNamedItemNS = function(node) {
            throw new Error("This DOM method is not implemented.");
          };
          XMLNamedNodeMap2.prototype.removeNamedItemNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented.");
          };
          return XMLNamedNodeMap2;
        }();
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLElement.js
  var require_XMLElement = __commonJS({
    "node_modules/xmlbuilder/lib/XMLElement.js"(exports, module) {
      (function() {
        var NodeType, XMLAttribute, XMLElement, XMLNamedNodeMap, XMLNode, getValue, isFunction, isObject, ref, extend = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        ref = require_Utility(), isObject = ref.isObject, isFunction = ref.isFunction, getValue = ref.getValue;
        XMLNode = require_XMLNode();
        NodeType = require_NodeType();
        XMLAttribute = require_XMLAttribute();
        XMLNamedNodeMap = require_XMLNamedNodeMap();
        module.exports = XMLElement = function(superClass) {
          extend(XMLElement2, superClass);
          function XMLElement2(parent, name, attributes) {
            var child, j, len, ref1;
            XMLElement2.__super__.constructor.call(this, parent);
            if (name == null) {
              throw new Error("Missing element name. " + this.debugInfo());
            }
            this.name = this.stringify.name(name);
            this.type = NodeType.Element;
            this.attribs = {};
            this.schemaTypeInfo = null;
            if (attributes != null) {
              this.attribute(attributes);
            }
            if (parent.type === NodeType.Document) {
              this.isRoot = true;
              this.documentObject = parent;
              parent.rootObject = this;
              if (parent.children) {
                ref1 = parent.children;
                for (j = 0, len = ref1.length; j < len; j++) {
                  child = ref1[j];
                  if (child.type === NodeType.DocType) {
                    child.name = this.name;
                    break;
                  }
                }
              }
            }
          }
          Object.defineProperty(XMLElement2.prototype, "tagName", {
            get: function() {
              return this.name;
            }
          });
          Object.defineProperty(XMLElement2.prototype, "namespaceURI", {
            get: function() {
              return "";
            }
          });
          Object.defineProperty(XMLElement2.prototype, "prefix", {
            get: function() {
              return "";
            }
          });
          Object.defineProperty(XMLElement2.prototype, "localName", {
            get: function() {
              return this.name;
            }
          });
          Object.defineProperty(XMLElement2.prototype, "id", {
            get: function() {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
          });
          Object.defineProperty(XMLElement2.prototype, "className", {
            get: function() {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
          });
          Object.defineProperty(XMLElement2.prototype, "classList", {
            get: function() {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
          });
          Object.defineProperty(XMLElement2.prototype, "attributes", {
            get: function() {
              if (!this.attributeMap || !this.attributeMap.nodes) {
                this.attributeMap = new XMLNamedNodeMap(this.attribs);
              }
              return this.attributeMap;
            }
          });
          XMLElement2.prototype.clone = function() {
            var att, attName, clonedSelf, ref1;
            clonedSelf = Object.create(this);
            if (clonedSelf.isRoot) {
              clonedSelf.documentObject = null;
            }
            clonedSelf.attribs = {};
            ref1 = this.attribs;
            for (attName in ref1) {
              if (!hasProp.call(ref1, attName))
                continue;
              att = ref1[attName];
              clonedSelf.attribs[attName] = att.clone();
            }
            clonedSelf.children = [];
            this.children.forEach(function(child) {
              var clonedChild;
              clonedChild = child.clone();
              clonedChild.parent = clonedSelf;
              return clonedSelf.children.push(clonedChild);
            });
            return clonedSelf;
          };
          XMLElement2.prototype.attribute = function(name, value) {
            var attName, attValue;
            if (name != null) {
              name = getValue(name);
            }
            if (isObject(name)) {
              for (attName in name) {
                if (!hasProp.call(name, attName))
                  continue;
                attValue = name[attName];
                this.attribute(attName, attValue);
              }
            } else {
              if (isFunction(value)) {
                value = value.apply();
              }
              if (this.options.keepNullAttributes && value == null) {
                this.attribs[name] = new XMLAttribute(this, name, "");
              } else if (value != null) {
                this.attribs[name] = new XMLAttribute(this, name, value);
              }
            }
            return this;
          };
          XMLElement2.prototype.removeAttribute = function(name) {
            var attName, j, len;
            if (name == null) {
              throw new Error("Missing attribute name. " + this.debugInfo());
            }
            name = getValue(name);
            if (Array.isArray(name)) {
              for (j = 0, len = name.length; j < len; j++) {
                attName = name[j];
                delete this.attribs[attName];
              }
            } else {
              delete this.attribs[name];
            }
            return this;
          };
          XMLElement2.prototype.toString = function(options) {
            return this.options.writer.element(this, this.options.writer.filterOptions(options));
          };
          XMLElement2.prototype.att = function(name, value) {
            return this.attribute(name, value);
          };
          XMLElement2.prototype.a = function(name, value) {
            return this.attribute(name, value);
          };
          XMLElement2.prototype.getAttribute = function(name) {
            if (this.attribs.hasOwnProperty(name)) {
              return this.attribs[name].value;
            } else {
              return null;
            }
          };
          XMLElement2.prototype.setAttribute = function(name, value) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLElement2.prototype.getAttributeNode = function(name) {
            if (this.attribs.hasOwnProperty(name)) {
              return this.attribs[name];
            } else {
              return null;
            }
          };
          XMLElement2.prototype.setAttributeNode = function(newAttr) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLElement2.prototype.removeAttributeNode = function(oldAttr) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLElement2.prototype.getElementsByTagName = function(name) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLElement2.prototype.getAttributeNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLElement2.prototype.setAttributeNS = function(namespaceURI, qualifiedName, value) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLElement2.prototype.removeAttributeNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLElement2.prototype.getAttributeNodeNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLElement2.prototype.setAttributeNodeNS = function(newAttr) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLElement2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLElement2.prototype.hasAttribute = function(name) {
            return this.attribs.hasOwnProperty(name);
          };
          XMLElement2.prototype.hasAttributeNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLElement2.prototype.setIdAttribute = function(name, isId) {
            if (this.attribs.hasOwnProperty(name)) {
              return this.attribs[name].isId;
            } else {
              return isId;
            }
          };
          XMLElement2.prototype.setIdAttributeNS = function(namespaceURI, localName, isId) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLElement2.prototype.setIdAttributeNode = function(idAttr, isId) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLElement2.prototype.getElementsByTagName = function(tagname) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLElement2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLElement2.prototype.getElementsByClassName = function(classNames) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLElement2.prototype.isEqualNode = function(node) {
            var i, j, ref1;
            if (!XMLElement2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
              return false;
            }
            if (node.namespaceURI !== this.namespaceURI) {
              return false;
            }
            if (node.prefix !== this.prefix) {
              return false;
            }
            if (node.localName !== this.localName) {
              return false;
            }
            if (node.attribs.length !== this.attribs.length) {
              return false;
            }
            for (i = j = 0, ref1 = this.attribs.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) {
              if (!this.attribs[i].isEqualNode(node.attribs[i])) {
                return false;
              }
            }
            return true;
          };
          return XMLElement2;
        }(XMLNode);
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLCharacterData.js
  var require_XMLCharacterData = __commonJS({
    "node_modules/xmlbuilder/lib/XMLCharacterData.js"(exports, module) {
      (function() {
        var XMLCharacterData, XMLNode, extend = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        XMLNode = require_XMLNode();
        module.exports = XMLCharacterData = function(superClass) {
          extend(XMLCharacterData2, superClass);
          function XMLCharacterData2(parent) {
            XMLCharacterData2.__super__.constructor.call(this, parent);
            this.value = "";
          }
          Object.defineProperty(XMLCharacterData2.prototype, "data", {
            get: function() {
              return this.value;
            },
            set: function(value) {
              return this.value = value || "";
            }
          });
          Object.defineProperty(XMLCharacterData2.prototype, "length", {
            get: function() {
              return this.value.length;
            }
          });
          Object.defineProperty(XMLCharacterData2.prototype, "textContent", {
            get: function() {
              return this.value;
            },
            set: function(value) {
              return this.value = value || "";
            }
          });
          XMLCharacterData2.prototype.clone = function() {
            return Object.create(this);
          };
          XMLCharacterData2.prototype.substringData = function(offset, count) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLCharacterData2.prototype.appendData = function(arg) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLCharacterData2.prototype.insertData = function(offset, arg) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLCharacterData2.prototype.deleteData = function(offset, count) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLCharacterData2.prototype.replaceData = function(offset, count, arg) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLCharacterData2.prototype.isEqualNode = function(node) {
            if (!XMLCharacterData2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
              return false;
            }
            if (node.data !== this.data) {
              return false;
            }
            return true;
          };
          return XMLCharacterData2;
        }(XMLNode);
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLCData.js
  var require_XMLCData = __commonJS({
    "node_modules/xmlbuilder/lib/XMLCData.js"(exports, module) {
      (function() {
        var NodeType, XMLCData, XMLCharacterData, extend = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        NodeType = require_NodeType();
        XMLCharacterData = require_XMLCharacterData();
        module.exports = XMLCData = function(superClass) {
          extend(XMLCData2, superClass);
          function XMLCData2(parent, text) {
            XMLCData2.__super__.constructor.call(this, parent);
            if (text == null) {
              throw new Error("Missing CDATA text. " + this.debugInfo());
            }
            this.name = "#cdata-section";
            this.type = NodeType.CData;
            this.value = this.stringify.cdata(text);
          }
          XMLCData2.prototype.clone = function() {
            return Object.create(this);
          };
          XMLCData2.prototype.toString = function(options) {
            return this.options.writer.cdata(this, this.options.writer.filterOptions(options));
          };
          return XMLCData2;
        }(XMLCharacterData);
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLComment.js
  var require_XMLComment = __commonJS({
    "node_modules/xmlbuilder/lib/XMLComment.js"(exports, module) {
      (function() {
        var NodeType, XMLCharacterData, XMLComment, extend = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        NodeType = require_NodeType();
        XMLCharacterData = require_XMLCharacterData();
        module.exports = XMLComment = function(superClass) {
          extend(XMLComment2, superClass);
          function XMLComment2(parent, text) {
            XMLComment2.__super__.constructor.call(this, parent);
            if (text == null) {
              throw new Error("Missing comment text. " + this.debugInfo());
            }
            this.name = "#comment";
            this.type = NodeType.Comment;
            this.value = this.stringify.comment(text);
          }
          XMLComment2.prototype.clone = function() {
            return Object.create(this);
          };
          XMLComment2.prototype.toString = function(options) {
            return this.options.writer.comment(this, this.options.writer.filterOptions(options));
          };
          return XMLComment2;
        }(XMLCharacterData);
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLDeclaration.js
  var require_XMLDeclaration = __commonJS({
    "node_modules/xmlbuilder/lib/XMLDeclaration.js"(exports, module) {
      (function() {
        var NodeType, XMLDeclaration, XMLNode, isObject, extend = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        isObject = require_Utility().isObject;
        XMLNode = require_XMLNode();
        NodeType = require_NodeType();
        module.exports = XMLDeclaration = function(superClass) {
          extend(XMLDeclaration2, superClass);
          function XMLDeclaration2(parent, version, encoding, standalone) {
            var ref;
            XMLDeclaration2.__super__.constructor.call(this, parent);
            if (isObject(version)) {
              ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
            }
            if (!version) {
              version = "1.0";
            }
            this.type = NodeType.Declaration;
            this.version = this.stringify.xmlVersion(version);
            if (encoding != null) {
              this.encoding = this.stringify.xmlEncoding(encoding);
            }
            if (standalone != null) {
              this.standalone = this.stringify.xmlStandalone(standalone);
            }
          }
          XMLDeclaration2.prototype.toString = function(options) {
            return this.options.writer.declaration(this, this.options.writer.filterOptions(options));
          };
          return XMLDeclaration2;
        }(XMLNode);
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLDTDAttList.js
  var require_XMLDTDAttList = __commonJS({
    "node_modules/xmlbuilder/lib/XMLDTDAttList.js"(exports, module) {
      (function() {
        var NodeType, XMLDTDAttList, XMLNode, extend = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        XMLNode = require_XMLNode();
        NodeType = require_NodeType();
        module.exports = XMLDTDAttList = function(superClass) {
          extend(XMLDTDAttList2, superClass);
          function XMLDTDAttList2(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
            XMLDTDAttList2.__super__.constructor.call(this, parent);
            if (elementName == null) {
              throw new Error("Missing DTD element name. " + this.debugInfo());
            }
            if (attributeName == null) {
              throw new Error("Missing DTD attribute name. " + this.debugInfo(elementName));
            }
            if (!attributeType) {
              throw new Error("Missing DTD attribute type. " + this.debugInfo(elementName));
            }
            if (!defaultValueType) {
              throw new Error("Missing DTD attribute default. " + this.debugInfo(elementName));
            }
            if (defaultValueType.indexOf("#") !== 0) {
              defaultValueType = "#" + defaultValueType;
            }
            if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
              throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(elementName));
            }
            if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
              throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(elementName));
            }
            this.elementName = this.stringify.name(elementName);
            this.type = NodeType.AttributeDeclaration;
            this.attributeName = this.stringify.name(attributeName);
            this.attributeType = this.stringify.dtdAttType(attributeType);
            if (defaultValue) {
              this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
            }
            this.defaultValueType = defaultValueType;
          }
          XMLDTDAttList2.prototype.toString = function(options) {
            return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(options));
          };
          return XMLDTDAttList2;
        }(XMLNode);
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLDTDEntity.js
  var require_XMLDTDEntity = __commonJS({
    "node_modules/xmlbuilder/lib/XMLDTDEntity.js"(exports, module) {
      (function() {
        var NodeType, XMLDTDEntity, XMLNode, isObject, extend = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        isObject = require_Utility().isObject;
        XMLNode = require_XMLNode();
        NodeType = require_NodeType();
        module.exports = XMLDTDEntity = function(superClass) {
          extend(XMLDTDEntity2, superClass);
          function XMLDTDEntity2(parent, pe, name, value) {
            XMLDTDEntity2.__super__.constructor.call(this, parent);
            if (name == null) {
              throw new Error("Missing DTD entity name. " + this.debugInfo(name));
            }
            if (value == null) {
              throw new Error("Missing DTD entity value. " + this.debugInfo(name));
            }
            this.pe = !!pe;
            this.name = this.stringify.name(name);
            this.type = NodeType.EntityDeclaration;
            if (!isObject(value)) {
              this.value = this.stringify.dtdEntityValue(value);
              this.internal = true;
            } else {
              if (!value.pubID && !value.sysID) {
                throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(name));
              }
              if (value.pubID && !value.sysID) {
                throw new Error("System identifier is required for a public external entity. " + this.debugInfo(name));
              }
              this.internal = false;
              if (value.pubID != null) {
                this.pubID = this.stringify.dtdPubID(value.pubID);
              }
              if (value.sysID != null) {
                this.sysID = this.stringify.dtdSysID(value.sysID);
              }
              if (value.nData != null) {
                this.nData = this.stringify.dtdNData(value.nData);
              }
              if (this.pe && this.nData) {
                throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(name));
              }
            }
          }
          Object.defineProperty(XMLDTDEntity2.prototype, "publicId", {
            get: function() {
              return this.pubID;
            }
          });
          Object.defineProperty(XMLDTDEntity2.prototype, "systemId", {
            get: function() {
              return this.sysID;
            }
          });
          Object.defineProperty(XMLDTDEntity2.prototype, "notationName", {
            get: function() {
              return this.nData || null;
            }
          });
          Object.defineProperty(XMLDTDEntity2.prototype, "inputEncoding", {
            get: function() {
              return null;
            }
          });
          Object.defineProperty(XMLDTDEntity2.prototype, "xmlEncoding", {
            get: function() {
              return null;
            }
          });
          Object.defineProperty(XMLDTDEntity2.prototype, "xmlVersion", {
            get: function() {
              return null;
            }
          });
          XMLDTDEntity2.prototype.toString = function(options) {
            return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(options));
          };
          return XMLDTDEntity2;
        }(XMLNode);
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLDTDElement.js
  var require_XMLDTDElement = __commonJS({
    "node_modules/xmlbuilder/lib/XMLDTDElement.js"(exports, module) {
      (function() {
        var NodeType, XMLDTDElement, XMLNode, extend = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        XMLNode = require_XMLNode();
        NodeType = require_NodeType();
        module.exports = XMLDTDElement = function(superClass) {
          extend(XMLDTDElement2, superClass);
          function XMLDTDElement2(parent, name, value) {
            XMLDTDElement2.__super__.constructor.call(this, parent);
            if (name == null) {
              throw new Error("Missing DTD element name. " + this.debugInfo());
            }
            if (!value) {
              value = "(#PCDATA)";
            }
            if (Array.isArray(value)) {
              value = "(" + value.join(",") + ")";
            }
            this.name = this.stringify.name(name);
            this.type = NodeType.ElementDeclaration;
            this.value = this.stringify.dtdElementValue(value);
          }
          XMLDTDElement2.prototype.toString = function(options) {
            return this.options.writer.dtdElement(this, this.options.writer.filterOptions(options));
          };
          return XMLDTDElement2;
        }(XMLNode);
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLDTDNotation.js
  var require_XMLDTDNotation = __commonJS({
    "node_modules/xmlbuilder/lib/XMLDTDNotation.js"(exports, module) {
      (function() {
        var NodeType, XMLDTDNotation, XMLNode, extend = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        XMLNode = require_XMLNode();
        NodeType = require_NodeType();
        module.exports = XMLDTDNotation = function(superClass) {
          extend(XMLDTDNotation2, superClass);
          function XMLDTDNotation2(parent, name, value) {
            XMLDTDNotation2.__super__.constructor.call(this, parent);
            if (name == null) {
              throw new Error("Missing DTD notation name. " + this.debugInfo(name));
            }
            if (!value.pubID && !value.sysID) {
              throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(name));
            }
            this.name = this.stringify.name(name);
            this.type = NodeType.NotationDeclaration;
            if (value.pubID != null) {
              this.pubID = this.stringify.dtdPubID(value.pubID);
            }
            if (value.sysID != null) {
              this.sysID = this.stringify.dtdSysID(value.sysID);
            }
          }
          Object.defineProperty(XMLDTDNotation2.prototype, "publicId", {
            get: function() {
              return this.pubID;
            }
          });
          Object.defineProperty(XMLDTDNotation2.prototype, "systemId", {
            get: function() {
              return this.sysID;
            }
          });
          XMLDTDNotation2.prototype.toString = function(options) {
            return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(options));
          };
          return XMLDTDNotation2;
        }(XMLNode);
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLDocType.js
  var require_XMLDocType = __commonJS({
    "node_modules/xmlbuilder/lib/XMLDocType.js"(exports, module) {
      (function() {
        var NodeType, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLNamedNodeMap, XMLNode, isObject, extend = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        isObject = require_Utility().isObject;
        XMLNode = require_XMLNode();
        NodeType = require_NodeType();
        XMLDTDAttList = require_XMLDTDAttList();
        XMLDTDEntity = require_XMLDTDEntity();
        XMLDTDElement = require_XMLDTDElement();
        XMLDTDNotation = require_XMLDTDNotation();
        XMLNamedNodeMap = require_XMLNamedNodeMap();
        module.exports = XMLDocType = function(superClass) {
          extend(XMLDocType2, superClass);
          function XMLDocType2(parent, pubID, sysID) {
            var child, i, len, ref, ref1, ref2;
            XMLDocType2.__super__.constructor.call(this, parent);
            this.type = NodeType.DocType;
            if (parent.children) {
              ref = parent.children;
              for (i = 0, len = ref.length; i < len; i++) {
                child = ref[i];
                if (child.type === NodeType.Element) {
                  this.name = child.name;
                  break;
                }
              }
            }
            this.documentObject = parent;
            if (isObject(pubID)) {
              ref1 = pubID, pubID = ref1.pubID, sysID = ref1.sysID;
            }
            if (sysID == null) {
              ref2 = [pubID, sysID], sysID = ref2[0], pubID = ref2[1];
            }
            if (pubID != null) {
              this.pubID = this.stringify.dtdPubID(pubID);
            }
            if (sysID != null) {
              this.sysID = this.stringify.dtdSysID(sysID);
            }
          }
          Object.defineProperty(XMLDocType2.prototype, "entities", {
            get: function() {
              var child, i, len, nodes, ref;
              nodes = {};
              ref = this.children;
              for (i = 0, len = ref.length; i < len; i++) {
                child = ref[i];
                if (child.type === NodeType.EntityDeclaration && !child.pe) {
                  nodes[child.name] = child;
                }
              }
              return new XMLNamedNodeMap(nodes);
            }
          });
          Object.defineProperty(XMLDocType2.prototype, "notations", {
            get: function() {
              var child, i, len, nodes, ref;
              nodes = {};
              ref = this.children;
              for (i = 0, len = ref.length; i < len; i++) {
                child = ref[i];
                if (child.type === NodeType.NotationDeclaration) {
                  nodes[child.name] = child;
                }
              }
              return new XMLNamedNodeMap(nodes);
            }
          });
          Object.defineProperty(XMLDocType2.prototype, "publicId", {
            get: function() {
              return this.pubID;
            }
          });
          Object.defineProperty(XMLDocType2.prototype, "systemId", {
            get: function() {
              return this.sysID;
            }
          });
          Object.defineProperty(XMLDocType2.prototype, "internalSubset", {
            get: function() {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
          });
          XMLDocType2.prototype.element = function(name, value) {
            var child;
            child = new XMLDTDElement(this, name, value);
            this.children.push(child);
            return this;
          };
          XMLDocType2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
            var child;
            child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
            this.children.push(child);
            return this;
          };
          XMLDocType2.prototype.entity = function(name, value) {
            var child;
            child = new XMLDTDEntity(this, false, name, value);
            this.children.push(child);
            return this;
          };
          XMLDocType2.prototype.pEntity = function(name, value) {
            var child;
            child = new XMLDTDEntity(this, true, name, value);
            this.children.push(child);
            return this;
          };
          XMLDocType2.prototype.notation = function(name, value) {
            var child;
            child = new XMLDTDNotation(this, name, value);
            this.children.push(child);
            return this;
          };
          XMLDocType2.prototype.toString = function(options) {
            return this.options.writer.docType(this, this.options.writer.filterOptions(options));
          };
          XMLDocType2.prototype.ele = function(name, value) {
            return this.element(name, value);
          };
          XMLDocType2.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
            return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
          };
          XMLDocType2.prototype.ent = function(name, value) {
            return this.entity(name, value);
          };
          XMLDocType2.prototype.pent = function(name, value) {
            return this.pEntity(name, value);
          };
          XMLDocType2.prototype.not = function(name, value) {
            return this.notation(name, value);
          };
          XMLDocType2.prototype.up = function() {
            return this.root() || this.documentObject;
          };
          XMLDocType2.prototype.isEqualNode = function(node) {
            if (!XMLDocType2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
              return false;
            }
            if (node.name !== this.name) {
              return false;
            }
            if (node.publicId !== this.publicId) {
              return false;
            }
            if (node.systemId !== this.systemId) {
              return false;
            }
            return true;
          };
          return XMLDocType2;
        }(XMLNode);
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLRaw.js
  var require_XMLRaw = __commonJS({
    "node_modules/xmlbuilder/lib/XMLRaw.js"(exports, module) {
      (function() {
        var NodeType, XMLNode, XMLRaw, extend = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        NodeType = require_NodeType();
        XMLNode = require_XMLNode();
        module.exports = XMLRaw = function(superClass) {
          extend(XMLRaw2, superClass);
          function XMLRaw2(parent, text) {
            XMLRaw2.__super__.constructor.call(this, parent);
            if (text == null) {
              throw new Error("Missing raw text. " + this.debugInfo());
            }
            this.type = NodeType.Raw;
            this.value = this.stringify.raw(text);
          }
          XMLRaw2.prototype.clone = function() {
            return Object.create(this);
          };
          XMLRaw2.prototype.toString = function(options) {
            return this.options.writer.raw(this, this.options.writer.filterOptions(options));
          };
          return XMLRaw2;
        }(XMLNode);
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLText.js
  var require_XMLText = __commonJS({
    "node_modules/xmlbuilder/lib/XMLText.js"(exports, module) {
      (function() {
        var NodeType, XMLCharacterData, XMLText, extend = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        NodeType = require_NodeType();
        XMLCharacterData = require_XMLCharacterData();
        module.exports = XMLText = function(superClass) {
          extend(XMLText2, superClass);
          function XMLText2(parent, text) {
            XMLText2.__super__.constructor.call(this, parent);
            if (text == null) {
              throw new Error("Missing element text. " + this.debugInfo());
            }
            this.name = "#text";
            this.type = NodeType.Text;
            this.value = this.stringify.text(text);
          }
          Object.defineProperty(XMLText2.prototype, "isElementContentWhitespace", {
            get: function() {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
          });
          Object.defineProperty(XMLText2.prototype, "wholeText", {
            get: function() {
              var next, prev, str;
              str = "";
              prev = this.previousSibling;
              while (prev) {
                str = prev.data + str;
                prev = prev.previousSibling;
              }
              str += this.data;
              next = this.nextSibling;
              while (next) {
                str = str + next.data;
                next = next.nextSibling;
              }
              return str;
            }
          });
          XMLText2.prototype.clone = function() {
            return Object.create(this);
          };
          XMLText2.prototype.toString = function(options) {
            return this.options.writer.text(this, this.options.writer.filterOptions(options));
          };
          XMLText2.prototype.splitText = function(offset) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLText2.prototype.replaceWholeText = function(content) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          return XMLText2;
        }(XMLCharacterData);
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLProcessingInstruction.js
  var require_XMLProcessingInstruction = __commonJS({
    "node_modules/xmlbuilder/lib/XMLProcessingInstruction.js"(exports, module) {
      (function() {
        var NodeType, XMLCharacterData, XMLProcessingInstruction, extend = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        NodeType = require_NodeType();
        XMLCharacterData = require_XMLCharacterData();
        module.exports = XMLProcessingInstruction = function(superClass) {
          extend(XMLProcessingInstruction2, superClass);
          function XMLProcessingInstruction2(parent, target, value) {
            XMLProcessingInstruction2.__super__.constructor.call(this, parent);
            if (target == null) {
              throw new Error("Missing instruction target. " + this.debugInfo());
            }
            this.type = NodeType.ProcessingInstruction;
            this.target = this.stringify.insTarget(target);
            this.name = this.target;
            if (value) {
              this.value = this.stringify.insValue(value);
            }
          }
          XMLProcessingInstruction2.prototype.clone = function() {
            return Object.create(this);
          };
          XMLProcessingInstruction2.prototype.toString = function(options) {
            return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(options));
          };
          XMLProcessingInstruction2.prototype.isEqualNode = function(node) {
            if (!XMLProcessingInstruction2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
              return false;
            }
            if (node.target !== this.target) {
              return false;
            }
            return true;
          };
          return XMLProcessingInstruction2;
        }(XMLCharacterData);
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLDummy.js
  var require_XMLDummy = __commonJS({
    "node_modules/xmlbuilder/lib/XMLDummy.js"(exports, module) {
      (function() {
        var NodeType, XMLDummy, XMLNode, extend = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        XMLNode = require_XMLNode();
        NodeType = require_NodeType();
        module.exports = XMLDummy = function(superClass) {
          extend(XMLDummy2, superClass);
          function XMLDummy2(parent) {
            XMLDummy2.__super__.constructor.call(this, parent);
            this.type = NodeType.Dummy;
          }
          XMLDummy2.prototype.clone = function() {
            return Object.create(this);
          };
          XMLDummy2.prototype.toString = function(options) {
            return "";
          };
          return XMLDummy2;
        }(XMLNode);
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLNodeList.js
  var require_XMLNodeList = __commonJS({
    "node_modules/xmlbuilder/lib/XMLNodeList.js"(exports, module) {
      (function() {
        var XMLNodeList;
        module.exports = XMLNodeList = function() {
          function XMLNodeList2(nodes) {
            this.nodes = nodes;
          }
          Object.defineProperty(XMLNodeList2.prototype, "length", {
            get: function() {
              return this.nodes.length || 0;
            }
          });
          XMLNodeList2.prototype.clone = function() {
            return this.nodes = null;
          };
          XMLNodeList2.prototype.item = function(index) {
            return this.nodes[index] || null;
          };
          return XMLNodeList2;
        }();
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/DocumentPosition.js
  var require_DocumentPosition = __commonJS({
    "node_modules/xmlbuilder/lib/DocumentPosition.js"(exports, module) {
      (function() {
        module.exports = {
          Disconnected: 1,
          Preceding: 2,
          Following: 4,
          Contains: 8,
          ContainedBy: 16,
          ImplementationSpecific: 32
        };
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLNode.js
  var require_XMLNode = __commonJS({
    "node_modules/xmlbuilder/lib/XMLNode.js"(exports, module) {
      (function() {
        var DocumentPosition, NodeType, XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLNamedNodeMap, XMLNode, XMLNodeList, XMLProcessingInstruction, XMLRaw, XMLText, getValue, isEmpty, isFunction, isObject, ref1, hasProp = {}.hasOwnProperty;
        ref1 = require_Utility(), isObject = ref1.isObject, isFunction = ref1.isFunction, isEmpty = ref1.isEmpty, getValue = ref1.getValue;
        XMLElement = null;
        XMLCData = null;
        XMLComment = null;
        XMLDeclaration = null;
        XMLDocType = null;
        XMLRaw = null;
        XMLText = null;
        XMLProcessingInstruction = null;
        XMLDummy = null;
        NodeType = null;
        XMLNodeList = null;
        XMLNamedNodeMap = null;
        DocumentPosition = null;
        module.exports = XMLNode = function() {
          function XMLNode2(parent1) {
            this.parent = parent1;
            if (this.parent) {
              this.options = this.parent.options;
              this.stringify = this.parent.stringify;
            }
            this.value = null;
            this.children = [];
            this.baseURI = null;
            if (!XMLElement) {
              XMLElement = require_XMLElement();
              XMLCData = require_XMLCData();
              XMLComment = require_XMLComment();
              XMLDeclaration = require_XMLDeclaration();
              XMLDocType = require_XMLDocType();
              XMLRaw = require_XMLRaw();
              XMLText = require_XMLText();
              XMLProcessingInstruction = require_XMLProcessingInstruction();
              XMLDummy = require_XMLDummy();
              NodeType = require_NodeType();
              XMLNodeList = require_XMLNodeList();
              XMLNamedNodeMap = require_XMLNamedNodeMap();
              DocumentPosition = require_DocumentPosition();
            }
          }
          Object.defineProperty(XMLNode2.prototype, "nodeName", {
            get: function() {
              return this.name;
            }
          });
          Object.defineProperty(XMLNode2.prototype, "nodeType", {
            get: function() {
              return this.type;
            }
          });
          Object.defineProperty(XMLNode2.prototype, "nodeValue", {
            get: function() {
              return this.value;
            }
          });
          Object.defineProperty(XMLNode2.prototype, "parentNode", {
            get: function() {
              return this.parent;
            }
          });
          Object.defineProperty(XMLNode2.prototype, "childNodes", {
            get: function() {
              if (!this.childNodeList || !this.childNodeList.nodes) {
                this.childNodeList = new XMLNodeList(this.children);
              }
              return this.childNodeList;
            }
          });
          Object.defineProperty(XMLNode2.prototype, "firstChild", {
            get: function() {
              return this.children[0] || null;
            }
          });
          Object.defineProperty(XMLNode2.prototype, "lastChild", {
            get: function() {
              return this.children[this.children.length - 1] || null;
            }
          });
          Object.defineProperty(XMLNode2.prototype, "previousSibling", {
            get: function() {
              var i;
              i = this.parent.children.indexOf(this);
              return this.parent.children[i - 1] || null;
            }
          });
          Object.defineProperty(XMLNode2.prototype, "nextSibling", {
            get: function() {
              var i;
              i = this.parent.children.indexOf(this);
              return this.parent.children[i + 1] || null;
            }
          });
          Object.defineProperty(XMLNode2.prototype, "ownerDocument", {
            get: function() {
              return this.document() || null;
            }
          });
          Object.defineProperty(XMLNode2.prototype, "textContent", {
            get: function() {
              var child, j, len, ref2, str;
              if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {
                str = "";
                ref2 = this.children;
                for (j = 0, len = ref2.length; j < len; j++) {
                  child = ref2[j];
                  if (child.textContent) {
                    str += child.textContent;
                  }
                }
                return str;
              } else {
                return null;
              }
            },
            set: function(value) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
          });
          XMLNode2.prototype.setParent = function(parent) {
            var child, j, len, ref2, results;
            this.parent = parent;
            if (parent) {
              this.options = parent.options;
              this.stringify = parent.stringify;
            }
            ref2 = this.children;
            results = [];
            for (j = 0, len = ref2.length; j < len; j++) {
              child = ref2[j];
              results.push(child.setParent(this));
            }
            return results;
          };
          XMLNode2.prototype.element = function(name, attributes, text) {
            var childNode, item, j, k, key, lastChild, len, len1, ref2, ref3, val;
            lastChild = null;
            if (attributes === null && text == null) {
              ref2 = [{}, null], attributes = ref2[0], text = ref2[1];
            }
            if (attributes == null) {
              attributes = {};
            }
            attributes = getValue(attributes);
            if (!isObject(attributes)) {
              ref3 = [attributes, text], text = ref3[0], attributes = ref3[1];
            }
            if (name != null) {
              name = getValue(name);
            }
            if (Array.isArray(name)) {
              for (j = 0, len = name.length; j < len; j++) {
                item = name[j];
                lastChild = this.element(item);
              }
            } else if (isFunction(name)) {
              lastChild = this.element(name.apply());
            } else if (isObject(name)) {
              for (key in name) {
                if (!hasProp.call(name, key))
                  continue;
                val = name[key];
                if (isFunction(val)) {
                  val = val.apply();
                }
                if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
                  lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
                } else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) {
                  lastChild = this.dummy();
                } else if (isObject(val) && isEmpty(val)) {
                  lastChild = this.element(key);
                } else if (!this.options.keepNullNodes && val == null) {
                  lastChild = this.dummy();
                } else if (!this.options.separateArrayItems && Array.isArray(val)) {
                  for (k = 0, len1 = val.length; k < len1; k++) {
                    item = val[k];
                    childNode = {};
                    childNode[key] = item;
                    lastChild = this.element(childNode);
                  }
                } else if (isObject(val)) {
                  if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) {
                    lastChild = this.element(val);
                  } else {
                    lastChild = this.element(key);
                    lastChild.element(val);
                  }
                } else {
                  lastChild = this.element(key, val);
                }
              }
            } else if (!this.options.keepNullNodes && text === null) {
              lastChild = this.dummy();
            } else {
              if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
                lastChild = this.text(text);
              } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
                lastChild = this.cdata(text);
              } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
                lastChild = this.comment(text);
              } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
                lastChild = this.raw(text);
              } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {
                lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);
              } else {
                lastChild = this.node(name, attributes, text);
              }
            }
            if (lastChild == null) {
              throw new Error("Could not create any elements with: " + name + ". " + this.debugInfo());
            }
            return lastChild;
          };
          XMLNode2.prototype.insertBefore = function(name, attributes, text) {
            var child, i, newChild, refChild, removed;
            if (name != null ? name.type : void 0) {
              newChild = name;
              refChild = attributes;
              newChild.setParent(this);
              if (refChild) {
                i = children.indexOf(refChild);
                removed = children.splice(i);
                children.push(newChild);
                Array.prototype.push.apply(children, removed);
              } else {
                children.push(newChild);
              }
              return newChild;
            } else {
              if (this.isRoot) {
                throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
              }
              i = this.parent.children.indexOf(this);
              removed = this.parent.children.splice(i);
              child = this.parent.element(name, attributes, text);
              Array.prototype.push.apply(this.parent.children, removed);
              return child;
            }
          };
          XMLNode2.prototype.insertAfter = function(name, attributes, text) {
            var child, i, removed;
            if (this.isRoot) {
              throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
            }
            i = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i + 1);
            child = this.parent.element(name, attributes, text);
            Array.prototype.push.apply(this.parent.children, removed);
            return child;
          };
          XMLNode2.prototype.remove = function() {
            var i, ref2;
            if (this.isRoot) {
              throw new Error("Cannot remove the root element. " + this.debugInfo());
            }
            i = this.parent.children.indexOf(this);
            [].splice.apply(this.parent.children, [i, i - i + 1].concat(ref2 = [])), ref2;
            return this.parent;
          };
          XMLNode2.prototype.node = function(name, attributes, text) {
            var child, ref2;
            if (name != null) {
              name = getValue(name);
            }
            attributes || (attributes = {});
            attributes = getValue(attributes);
            if (!isObject(attributes)) {
              ref2 = [attributes, text], text = ref2[0], attributes = ref2[1];
            }
            child = new XMLElement(this, name, attributes);
            if (text != null) {
              child.text(text);
            }
            this.children.push(child);
            return child;
          };
          XMLNode2.prototype.text = function(value) {
            var child;
            if (isObject(value)) {
              this.element(value);
            }
            child = new XMLText(this, value);
            this.children.push(child);
            return this;
          };
          XMLNode2.prototype.cdata = function(value) {
            var child;
            child = new XMLCData(this, value);
            this.children.push(child);
            return this;
          };
          XMLNode2.prototype.comment = function(value) {
            var child;
            child = new XMLComment(this, value);
            this.children.push(child);
            return this;
          };
          XMLNode2.prototype.commentBefore = function(value) {
            var child, i, removed;
            i = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i);
            child = this.parent.comment(value);
            Array.prototype.push.apply(this.parent.children, removed);
            return this;
          };
          XMLNode2.prototype.commentAfter = function(value) {
            var child, i, removed;
            i = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i + 1);
            child = this.parent.comment(value);
            Array.prototype.push.apply(this.parent.children, removed);
            return this;
          };
          XMLNode2.prototype.raw = function(value) {
            var child;
            child = new XMLRaw(this, value);
            this.children.push(child);
            return this;
          };
          XMLNode2.prototype.dummy = function() {
            var child;
            child = new XMLDummy(this);
            return child;
          };
          XMLNode2.prototype.instruction = function(target, value) {
            var insTarget, insValue, instruction, j, len;
            if (target != null) {
              target = getValue(target);
            }
            if (value != null) {
              value = getValue(value);
            }
            if (Array.isArray(target)) {
              for (j = 0, len = target.length; j < len; j++) {
                insTarget = target[j];
                this.instruction(insTarget);
              }
            } else if (isObject(target)) {
              for (insTarget in target) {
                if (!hasProp.call(target, insTarget))
                  continue;
                insValue = target[insTarget];
                this.instruction(insTarget, insValue);
              }
            } else {
              if (isFunction(value)) {
                value = value.apply();
              }
              instruction = new XMLProcessingInstruction(this, target, value);
              this.children.push(instruction);
            }
            return this;
          };
          XMLNode2.prototype.instructionBefore = function(target, value) {
            var child, i, removed;
            i = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i);
            child = this.parent.instruction(target, value);
            Array.prototype.push.apply(this.parent.children, removed);
            return this;
          };
          XMLNode2.prototype.instructionAfter = function(target, value) {
            var child, i, removed;
            i = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i + 1);
            child = this.parent.instruction(target, value);
            Array.prototype.push.apply(this.parent.children, removed);
            return this;
          };
          XMLNode2.prototype.declaration = function(version, encoding, standalone) {
            var doc, xmldec;
            doc = this.document();
            xmldec = new XMLDeclaration(doc, version, encoding, standalone);
            if (doc.children.length === 0) {
              doc.children.unshift(xmldec);
            } else if (doc.children[0].type === NodeType.Declaration) {
              doc.children[0] = xmldec;
            } else {
              doc.children.unshift(xmldec);
            }
            return doc.root() || doc;
          };
          XMLNode2.prototype.dtd = function(pubID, sysID) {
            var child, doc, doctype, i, j, k, len, len1, ref2, ref3;
            doc = this.document();
            doctype = new XMLDocType(doc, pubID, sysID);
            ref2 = doc.children;
            for (i = j = 0, len = ref2.length; j < len; i = ++j) {
              child = ref2[i];
              if (child.type === NodeType.DocType) {
                doc.children[i] = doctype;
                return doctype;
              }
            }
            ref3 = doc.children;
            for (i = k = 0, len1 = ref3.length; k < len1; i = ++k) {
              child = ref3[i];
              if (child.isRoot) {
                doc.children.splice(i, 0, doctype);
                return doctype;
              }
            }
            doc.children.push(doctype);
            return doctype;
          };
          XMLNode2.prototype.up = function() {
            if (this.isRoot) {
              throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
            }
            return this.parent;
          };
          XMLNode2.prototype.root = function() {
            var node;
            node = this;
            while (node) {
              if (node.type === NodeType.Document) {
                return node.rootObject;
              } else if (node.isRoot) {
                return node;
              } else {
                node = node.parent;
              }
            }
          };
          XMLNode2.prototype.document = function() {
            var node;
            node = this;
            while (node) {
              if (node.type === NodeType.Document) {
                return node;
              } else {
                node = node.parent;
              }
            }
          };
          XMLNode2.prototype.end = function(options) {
            return this.document().end(options);
          };
          XMLNode2.prototype.prev = function() {
            var i;
            i = this.parent.children.indexOf(this);
            if (i < 1) {
              throw new Error("Already at the first node. " + this.debugInfo());
            }
            return this.parent.children[i - 1];
          };
          XMLNode2.prototype.next = function() {
            var i;
            i = this.parent.children.indexOf(this);
            if (i === -1 || i === this.parent.children.length - 1) {
              throw new Error("Already at the last node. " + this.debugInfo());
            }
            return this.parent.children[i + 1];
          };
          XMLNode2.prototype.importDocument = function(doc) {
            var clonedRoot;
            clonedRoot = doc.root().clone();
            clonedRoot.parent = this;
            clonedRoot.isRoot = false;
            this.children.push(clonedRoot);
            return this;
          };
          XMLNode2.prototype.debugInfo = function(name) {
            var ref2, ref3;
            name = name || this.name;
            if (name == null && !((ref2 = this.parent) != null ? ref2.name : void 0)) {
              return "";
            } else if (name == null) {
              return "parent: <" + this.parent.name + ">";
            } else if (!((ref3 = this.parent) != null ? ref3.name : void 0)) {
              return "node: <" + name + ">";
            } else {
              return "node: <" + name + ">, parent: <" + this.parent.name + ">";
            }
          };
          XMLNode2.prototype.ele = function(name, attributes, text) {
            return this.element(name, attributes, text);
          };
          XMLNode2.prototype.nod = function(name, attributes, text) {
            return this.node(name, attributes, text);
          };
          XMLNode2.prototype.txt = function(value) {
            return this.text(value);
          };
          XMLNode2.prototype.dat = function(value) {
            return this.cdata(value);
          };
          XMLNode2.prototype.com = function(value) {
            return this.comment(value);
          };
          XMLNode2.prototype.ins = function(target, value) {
            return this.instruction(target, value);
          };
          XMLNode2.prototype.doc = function() {
            return this.document();
          };
          XMLNode2.prototype.dec = function(version, encoding, standalone) {
            return this.declaration(version, encoding, standalone);
          };
          XMLNode2.prototype.e = function(name, attributes, text) {
            return this.element(name, attributes, text);
          };
          XMLNode2.prototype.n = function(name, attributes, text) {
            return this.node(name, attributes, text);
          };
          XMLNode2.prototype.t = function(value) {
            return this.text(value);
          };
          XMLNode2.prototype.d = function(value) {
            return this.cdata(value);
          };
          XMLNode2.prototype.c = function(value) {
            return this.comment(value);
          };
          XMLNode2.prototype.r = function(value) {
            return this.raw(value);
          };
          XMLNode2.prototype.i = function(target, value) {
            return this.instruction(target, value);
          };
          XMLNode2.prototype.u = function() {
            return this.up();
          };
          XMLNode2.prototype.importXMLBuilder = function(doc) {
            return this.importDocument(doc);
          };
          XMLNode2.prototype.replaceChild = function(newChild, oldChild) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLNode2.prototype.removeChild = function(oldChild) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLNode2.prototype.appendChild = function(newChild) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLNode2.prototype.hasChildNodes = function() {
            return this.children.length !== 0;
          };
          XMLNode2.prototype.cloneNode = function(deep) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLNode2.prototype.normalize = function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLNode2.prototype.isSupported = function(feature, version) {
            return true;
          };
          XMLNode2.prototype.hasAttributes = function() {
            return this.attribs.length !== 0;
          };
          XMLNode2.prototype.compareDocumentPosition = function(other) {
            var ref, res;
            ref = this;
            if (ref === other) {
              return 0;
            } else if (this.document() !== other.document()) {
              res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;
              if (Math.random() < 0.5) {
                res |= DocumentPosition.Preceding;
              } else {
                res |= DocumentPosition.Following;
              }
              return res;
            } else if (ref.isAncestor(other)) {
              return DocumentPosition.Contains | DocumentPosition.Preceding;
            } else if (ref.isDescendant(other)) {
              return DocumentPosition.Contains | DocumentPosition.Following;
            } else if (ref.isPreceding(other)) {
              return DocumentPosition.Preceding;
            } else {
              return DocumentPosition.Following;
            }
          };
          XMLNode2.prototype.isSameNode = function(other) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLNode2.prototype.lookupPrefix = function(namespaceURI) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLNode2.prototype.isDefaultNamespace = function(namespaceURI) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLNode2.prototype.lookupNamespaceURI = function(prefix) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLNode2.prototype.isEqualNode = function(node) {
            var i, j, ref2;
            if (node.nodeType !== this.nodeType) {
              return false;
            }
            if (node.children.length !== this.children.length) {
              return false;
            }
            for (i = j = 0, ref2 = this.children.length - 1; 0 <= ref2 ? j <= ref2 : j >= ref2; i = 0 <= ref2 ? ++j : --j) {
              if (!this.children[i].isEqualNode(node.children[i])) {
                return false;
              }
            }
            return true;
          };
          XMLNode2.prototype.getFeature = function(feature, version) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLNode2.prototype.setUserData = function(key, data, handler) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLNode2.prototype.getUserData = function(key) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLNode2.prototype.contains = function(other) {
            if (!other) {
              return false;
            }
            return other === this || this.isDescendant(other);
          };
          XMLNode2.prototype.isDescendant = function(node) {
            var child, isDescendantChild, j, len, ref2;
            ref2 = this.children;
            for (j = 0, len = ref2.length; j < len; j++) {
              child = ref2[j];
              if (node === child) {
                return true;
              }
              isDescendantChild = child.isDescendant(node);
              if (isDescendantChild) {
                return true;
              }
            }
            return false;
          };
          XMLNode2.prototype.isAncestor = function(node) {
            return node.isDescendant(this);
          };
          XMLNode2.prototype.isPreceding = function(node) {
            var nodePos, thisPos;
            nodePos = this.treePosition(node);
            thisPos = this.treePosition(this);
            if (nodePos === -1 || thisPos === -1) {
              return false;
            } else {
              return nodePos < thisPos;
            }
          };
          XMLNode2.prototype.isFollowing = function(node) {
            var nodePos, thisPos;
            nodePos = this.treePosition(node);
            thisPos = this.treePosition(this);
            if (nodePos === -1 || thisPos === -1) {
              return false;
            } else {
              return nodePos > thisPos;
            }
          };
          XMLNode2.prototype.treePosition = function(node) {
            var found, pos;
            pos = 0;
            found = false;
            this.foreachTreeNode(this.document(), function(childNode) {
              pos++;
              if (!found && childNode === node) {
                return found = true;
              }
            });
            if (found) {
              return pos;
            } else {
              return -1;
            }
          };
          XMLNode2.prototype.foreachTreeNode = function(node, func) {
            var child, j, len, ref2, res;
            node || (node = this.document());
            ref2 = node.children;
            for (j = 0, len = ref2.length; j < len; j++) {
              child = ref2[j];
              if (res = func(child)) {
                return res;
              } else {
                res = this.foreachTreeNode(child, func);
                if (res) {
                  return res;
                }
              }
            }
          };
          return XMLNode2;
        }();
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLStringifier.js
  var require_XMLStringifier = __commonJS({
    "node_modules/xmlbuilder/lib/XMLStringifier.js"(exports, module) {
      (function() {
        var XMLStringifier, bind = function(fn, me) {
          return function() {
            return fn.apply(me, arguments);
          };
        }, hasProp = {}.hasOwnProperty;
        module.exports = XMLStringifier = function() {
          function XMLStringifier2(options) {
            this.assertLegalName = bind(this.assertLegalName, this);
            this.assertLegalChar = bind(this.assertLegalChar, this);
            var key, ref, value;
            options || (options = {});
            this.options = options;
            if (!this.options.version) {
              this.options.version = "1.0";
            }
            ref = options.stringify || {};
            for (key in ref) {
              if (!hasProp.call(ref, key))
                continue;
              value = ref[key];
              this[key] = value;
            }
          }
          XMLStringifier2.prototype.name = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalName("" + val || "");
          };
          XMLStringifier2.prototype.text = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar(this.textEscape("" + val || ""));
          };
          XMLStringifier2.prototype.cdata = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            val = "" + val || "";
            val = val.replace("]]>", "]]]]><![CDATA[>");
            return this.assertLegalChar(val);
          };
          XMLStringifier2.prototype.comment = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            val = "" + val || "";
            if (val.match(/--/)) {
              throw new Error("Comment text cannot contain double-hypen: " + val);
            }
            return this.assertLegalChar(val);
          };
          XMLStringifier2.prototype.raw = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            return "" + val || "";
          };
          XMLStringifier2.prototype.attValue = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar(this.attEscape(val = "" + val || ""));
          };
          XMLStringifier2.prototype.insTarget = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          };
          XMLStringifier2.prototype.insValue = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            val = "" + val || "";
            if (val.match(/\?>/)) {
              throw new Error("Invalid processing instruction value: " + val);
            }
            return this.assertLegalChar(val);
          };
          XMLStringifier2.prototype.xmlVersion = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            val = "" + val || "";
            if (!val.match(/1\.[0-9]+/)) {
              throw new Error("Invalid version number: " + val);
            }
            return val;
          };
          XMLStringifier2.prototype.xmlEncoding = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            val = "" + val || "";
            if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
              throw new Error("Invalid encoding: " + val);
            }
            return this.assertLegalChar(val);
          };
          XMLStringifier2.prototype.xmlStandalone = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            if (val) {
              return "yes";
            } else {
              return "no";
            }
          };
          XMLStringifier2.prototype.dtdPubID = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          };
          XMLStringifier2.prototype.dtdSysID = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          };
          XMLStringifier2.prototype.dtdElementValue = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          };
          XMLStringifier2.prototype.dtdAttType = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          };
          XMLStringifier2.prototype.dtdAttDefault = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          };
          XMLStringifier2.prototype.dtdEntityValue = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          };
          XMLStringifier2.prototype.dtdNData = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          };
          XMLStringifier2.prototype.convertAttKey = "@";
          XMLStringifier2.prototype.convertPIKey = "?";
          XMLStringifier2.prototype.convertTextKey = "#text";
          XMLStringifier2.prototype.convertCDataKey = "#cdata";
          XMLStringifier2.prototype.convertCommentKey = "#comment";
          XMLStringifier2.prototype.convertRawKey = "#raw";
          XMLStringifier2.prototype.assertLegalChar = function(str) {
            var regex, res;
            if (this.options.noValidation) {
              return str;
            }
            regex = "";
            if (this.options.version === "1.0") {
              regex = /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
              if (res = str.match(regex)) {
                throw new Error("Invalid character in string: " + str + " at index " + res.index);
              }
            } else if (this.options.version === "1.1") {
              regex = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
              if (res = str.match(regex)) {
                throw new Error("Invalid character in string: " + str + " at index " + res.index);
              }
            }
            return str;
          };
          XMLStringifier2.prototype.assertLegalName = function(str) {
            var regex;
            if (this.options.noValidation) {
              return str;
            }
            this.assertLegalChar(str);
            regex = /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/;
            if (!str.match(regex)) {
              throw new Error("Invalid character in name");
            }
            return str;
          };
          XMLStringifier2.prototype.textEscape = function(str) {
            var ampregex;
            if (this.options.noValidation) {
              return str;
            }
            ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
            return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;");
          };
          XMLStringifier2.prototype.attEscape = function(str) {
            var ampregex;
            if (this.options.noValidation) {
              return str;
            }
            ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
            return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
          };
          return XMLStringifier2;
        }();
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/WriterState.js
  var require_WriterState = __commonJS({
    "node_modules/xmlbuilder/lib/WriterState.js"(exports, module) {
      (function() {
        module.exports = {
          None: 0,
          OpenTag: 1,
          InsideTag: 2,
          CloseTag: 3
        };
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLWriterBase.js
  var require_XMLWriterBase = __commonJS({
    "node_modules/xmlbuilder/lib/XMLWriterBase.js"(exports, module) {
      (function() {
        var NodeType, WriterState, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLProcessingInstruction, XMLRaw, XMLText, XMLWriterBase, assign, hasProp = {}.hasOwnProperty;
        assign = require_Utility().assign;
        NodeType = require_NodeType();
        XMLDeclaration = require_XMLDeclaration();
        XMLDocType = require_XMLDocType();
        XMLCData = require_XMLCData();
        XMLComment = require_XMLComment();
        XMLElement = require_XMLElement();
        XMLRaw = require_XMLRaw();
        XMLText = require_XMLText();
        XMLProcessingInstruction = require_XMLProcessingInstruction();
        XMLDummy = require_XMLDummy();
        XMLDTDAttList = require_XMLDTDAttList();
        XMLDTDElement = require_XMLDTDElement();
        XMLDTDEntity = require_XMLDTDEntity();
        XMLDTDNotation = require_XMLDTDNotation();
        WriterState = require_WriterState();
        module.exports = XMLWriterBase = function() {
          function XMLWriterBase2(options) {
            var key, ref, value;
            options || (options = {});
            this.options = options;
            ref = options.writer || {};
            for (key in ref) {
              if (!hasProp.call(ref, key))
                continue;
              value = ref[key];
              this["_" + key] = this[key];
              this[key] = value;
            }
          }
          XMLWriterBase2.prototype.filterOptions = function(options) {
            var filteredOptions, ref, ref1, ref2, ref3, ref4, ref5, ref6;
            options || (options = {});
            options = assign({}, this.options, options);
            filteredOptions = {
              writer: this
            };
            filteredOptions.pretty = options.pretty || false;
            filteredOptions.allowEmpty = options.allowEmpty || false;
            filteredOptions.indent = (ref = options.indent) != null ? ref : "  ";
            filteredOptions.newline = (ref1 = options.newline) != null ? ref1 : "\n";
            filteredOptions.offset = (ref2 = options.offset) != null ? ref2 : 0;
            filteredOptions.dontPrettyTextNodes = (ref3 = (ref4 = options.dontPrettyTextNodes) != null ? ref4 : options.dontprettytextnodes) != null ? ref3 : 0;
            filteredOptions.spaceBeforeSlash = (ref5 = (ref6 = options.spaceBeforeSlash) != null ? ref6 : options.spacebeforeslash) != null ? ref5 : "";
            if (filteredOptions.spaceBeforeSlash === true) {
              filteredOptions.spaceBeforeSlash = " ";
            }
            filteredOptions.suppressPrettyCount = 0;
            filteredOptions.user = {};
            filteredOptions.state = WriterState.None;
            return filteredOptions;
          };
          XMLWriterBase2.prototype.indent = function(node, options, level) {
            var indentLevel;
            if (!options.pretty || options.suppressPrettyCount) {
              return "";
            } else if (options.pretty) {
              indentLevel = (level || 0) + options.offset + 1;
              if (indentLevel > 0) {
                return new Array(indentLevel).join(options.indent);
              }
            }
            return "";
          };
          XMLWriterBase2.prototype.endline = function(node, options, level) {
            if (!options.pretty || options.suppressPrettyCount) {
              return "";
            } else {
              return options.newline;
            }
          };
          XMLWriterBase2.prototype.attribute = function(att, options, level) {
            var r;
            this.openAttribute(att, options, level);
            r = " " + att.name + '="' + att.value + '"';
            this.closeAttribute(att, options, level);
            return r;
          };
          XMLWriterBase2.prototype.cdata = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + "<![CDATA[";
            options.state = WriterState.InsideTag;
            r += node.value;
            options.state = WriterState.CloseTag;
            r += "]]>" + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
          };
          XMLWriterBase2.prototype.comment = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + "<!-- ";
            options.state = WriterState.InsideTag;
            r += node.value;
            options.state = WriterState.CloseTag;
            r += " -->" + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
          };
          XMLWriterBase2.prototype.declaration = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + "<?xml";
            options.state = WriterState.InsideTag;
            r += ' version="' + node.version + '"';
            if (node.encoding != null) {
              r += ' encoding="' + node.encoding + '"';
            }
            if (node.standalone != null) {
              r += ' standalone="' + node.standalone + '"';
            }
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + "?>";
            r += this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
          };
          XMLWriterBase2.prototype.docType = function(node, options, level) {
            var child, i, len, r, ref;
            level || (level = 0);
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level);
            r += "<!DOCTYPE " + node.root().name;
            if (node.pubID && node.sysID) {
              r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
            } else if (node.sysID) {
              r += ' SYSTEM "' + node.sysID + '"';
            }
            if (node.children.length > 0) {
              r += " [";
              r += this.endline(node, options, level);
              options.state = WriterState.InsideTag;
              ref = node.children;
              for (i = 0, len = ref.length; i < len; i++) {
                child = ref[i];
                r += this.writeChildNode(child, options, level + 1);
              }
              options.state = WriterState.CloseTag;
              r += "]";
            }
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + ">";
            r += this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
          };
          XMLWriterBase2.prototype.element = function(node, options, level) {
            var att, child, childNodeCount, firstChildNode, i, j, len, len1, name, prettySuppressed, r, ref, ref1, ref2;
            level || (level = 0);
            prettySuppressed = false;
            r = "";
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r += this.indent(node, options, level) + "<" + node.name;
            ref = node.attribs;
            for (name in ref) {
              if (!hasProp.call(ref, name))
                continue;
              att = ref[name];
              r += this.attribute(att, options, level);
            }
            childNodeCount = node.children.length;
            firstChildNode = childNodeCount === 0 ? null : node.children[0];
            if (childNodeCount === 0 || node.children.every(function(e) {
              return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === "";
            })) {
              if (options.allowEmpty) {
                r += ">";
                options.state = WriterState.CloseTag;
                r += "</" + node.name + ">" + this.endline(node, options, level);
              } else {
                options.state = WriterState.CloseTag;
                r += options.spaceBeforeSlash + "/>" + this.endline(node, options, level);
              }
            } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {
              r += ">";
              options.state = WriterState.InsideTag;
              options.suppressPrettyCount++;
              prettySuppressed = true;
              r += this.writeChildNode(firstChildNode, options, level + 1);
              options.suppressPrettyCount--;
              prettySuppressed = false;
              options.state = WriterState.CloseTag;
              r += "</" + node.name + ">" + this.endline(node, options, level);
            } else {
              if (options.dontPrettyTextNodes) {
                ref1 = node.children;
                for (i = 0, len = ref1.length; i < len; i++) {
                  child = ref1[i];
                  if ((child.type === NodeType.Text || child.type === NodeType.Raw) && child.value != null) {
                    options.suppressPrettyCount++;
                    prettySuppressed = true;
                    break;
                  }
                }
              }
              r += ">" + this.endline(node, options, level);
              options.state = WriterState.InsideTag;
              ref2 = node.children;
              for (j = 0, len1 = ref2.length; j < len1; j++) {
                child = ref2[j];
                r += this.writeChildNode(child, options, level + 1);
              }
              options.state = WriterState.CloseTag;
              r += this.indent(node, options, level) + "</" + node.name + ">";
              if (prettySuppressed) {
                options.suppressPrettyCount--;
              }
              r += this.endline(node, options, level);
              options.state = WriterState.None;
            }
            this.closeNode(node, options, level);
            return r;
          };
          XMLWriterBase2.prototype.writeChildNode = function(node, options, level) {
            switch (node.type) {
              case NodeType.CData:
                return this.cdata(node, options, level);
              case NodeType.Comment:
                return this.comment(node, options, level);
              case NodeType.Element:
                return this.element(node, options, level);
              case NodeType.Raw:
                return this.raw(node, options, level);
              case NodeType.Text:
                return this.text(node, options, level);
              case NodeType.ProcessingInstruction:
                return this.processingInstruction(node, options, level);
              case NodeType.Dummy:
                return "";
              case NodeType.Declaration:
                return this.declaration(node, options, level);
              case NodeType.DocType:
                return this.docType(node, options, level);
              case NodeType.AttributeDeclaration:
                return this.dtdAttList(node, options, level);
              case NodeType.ElementDeclaration:
                return this.dtdElement(node, options, level);
              case NodeType.EntityDeclaration:
                return this.dtdEntity(node, options, level);
              case NodeType.NotationDeclaration:
                return this.dtdNotation(node, options, level);
              default:
                throw new Error("Unknown XML node type: " + node.constructor.name);
            }
          };
          XMLWriterBase2.prototype.processingInstruction = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + "<?";
            options.state = WriterState.InsideTag;
            r += node.target;
            if (node.value) {
              r += " " + node.value;
            }
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + "?>";
            r += this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
          };
          XMLWriterBase2.prototype.raw = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level);
            options.state = WriterState.InsideTag;
            r += node.value;
            options.state = WriterState.CloseTag;
            r += this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
          };
          XMLWriterBase2.prototype.text = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level);
            options.state = WriterState.InsideTag;
            r += node.value;
            options.state = WriterState.CloseTag;
            r += this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
          };
          XMLWriterBase2.prototype.dtdAttList = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + "<!ATTLIST";
            options.state = WriterState.InsideTag;
            r += " " + node.elementName + " " + node.attributeName + " " + node.attributeType;
            if (node.defaultValueType !== "#DEFAULT") {
              r += " " + node.defaultValueType;
            }
            if (node.defaultValue) {
              r += ' "' + node.defaultValue + '"';
            }
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
          };
          XMLWriterBase2.prototype.dtdElement = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + "<!ELEMENT";
            options.state = WriterState.InsideTag;
            r += " " + node.name + " " + node.value;
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
          };
          XMLWriterBase2.prototype.dtdEntity = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + "<!ENTITY";
            options.state = WriterState.InsideTag;
            if (node.pe) {
              r += " %";
            }
            r += " " + node.name;
            if (node.value) {
              r += ' "' + node.value + '"';
            } else {
              if (node.pubID && node.sysID) {
                r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
              } else if (node.sysID) {
                r += ' SYSTEM "' + node.sysID + '"';
              }
              if (node.nData) {
                r += " NDATA " + node.nData;
              }
            }
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
          };
          XMLWriterBase2.prototype.dtdNotation = function(node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + "<!NOTATION";
            options.state = WriterState.InsideTag;
            r += " " + node.name;
            if (node.pubID && node.sysID) {
              r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
            } else if (node.pubID) {
              r += ' PUBLIC "' + node.pubID + '"';
            } else if (node.sysID) {
              r += ' SYSTEM "' + node.sysID + '"';
            }
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
          };
          XMLWriterBase2.prototype.openNode = function(node, options, level) {
          };
          XMLWriterBase2.prototype.closeNode = function(node, options, level) {
          };
          XMLWriterBase2.prototype.openAttribute = function(att, options, level) {
          };
          XMLWriterBase2.prototype.closeAttribute = function(att, options, level) {
          };
          return XMLWriterBase2;
        }();
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLStringWriter.js
  var require_XMLStringWriter = __commonJS({
    "node_modules/xmlbuilder/lib/XMLStringWriter.js"(exports, module) {
      (function() {
        var XMLStringWriter, XMLWriterBase, extend = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        XMLWriterBase = require_XMLWriterBase();
        module.exports = XMLStringWriter = function(superClass) {
          extend(XMLStringWriter2, superClass);
          function XMLStringWriter2(options) {
            XMLStringWriter2.__super__.constructor.call(this, options);
          }
          XMLStringWriter2.prototype.document = function(doc, options) {
            var child, i, len, r, ref;
            options = this.filterOptions(options);
            r = "";
            ref = doc.children;
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              r += this.writeChildNode(child, options, 0);
            }
            if (options.pretty && r.slice(-options.newline.length) === options.newline) {
              r = r.slice(0, -options.newline.length);
            }
            return r;
          };
          return XMLStringWriter2;
        }(XMLWriterBase);
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLDocument.js
  var require_XMLDocument = __commonJS({
    "node_modules/xmlbuilder/lib/XMLDocument.js"(exports, module) {
      (function() {
        var NodeType, XMLDOMConfiguration, XMLDOMImplementation, XMLDocument, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject, extend = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        isPlainObject = require_Utility().isPlainObject;
        XMLDOMImplementation = require_XMLDOMImplementation();
        XMLDOMConfiguration = require_XMLDOMConfiguration();
        XMLNode = require_XMLNode();
        NodeType = require_NodeType();
        XMLStringifier = require_XMLStringifier();
        XMLStringWriter = require_XMLStringWriter();
        module.exports = XMLDocument = function(superClass) {
          extend(XMLDocument2, superClass);
          function XMLDocument2(options) {
            XMLDocument2.__super__.constructor.call(this, null);
            this.name = "#document";
            this.type = NodeType.Document;
            this.documentURI = null;
            this.domConfig = new XMLDOMConfiguration();
            options || (options = {});
            if (!options.writer) {
              options.writer = new XMLStringWriter();
            }
            this.options = options;
            this.stringify = new XMLStringifier(options);
          }
          Object.defineProperty(XMLDocument2.prototype, "implementation", {
            value: new XMLDOMImplementation()
          });
          Object.defineProperty(XMLDocument2.prototype, "doctype", {
            get: function() {
              var child, i, len, ref;
              ref = this.children;
              for (i = 0, len = ref.length; i < len; i++) {
                child = ref[i];
                if (child.type === NodeType.DocType) {
                  return child;
                }
              }
              return null;
            }
          });
          Object.defineProperty(XMLDocument2.prototype, "documentElement", {
            get: function() {
              return this.rootObject || null;
            }
          });
          Object.defineProperty(XMLDocument2.prototype, "inputEncoding", {
            get: function() {
              return null;
            }
          });
          Object.defineProperty(XMLDocument2.prototype, "strictErrorChecking", {
            get: function() {
              return false;
            }
          });
          Object.defineProperty(XMLDocument2.prototype, "xmlEncoding", {
            get: function() {
              if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
                return this.children[0].encoding;
              } else {
                return null;
              }
            }
          });
          Object.defineProperty(XMLDocument2.prototype, "xmlStandalone", {
            get: function() {
              if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
                return this.children[0].standalone === "yes";
              } else {
                return false;
              }
            }
          });
          Object.defineProperty(XMLDocument2.prototype, "xmlVersion", {
            get: function() {
              if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
                return this.children[0].version;
              } else {
                return "1.0";
              }
            }
          });
          Object.defineProperty(XMLDocument2.prototype, "URL", {
            get: function() {
              return this.documentURI;
            }
          });
          Object.defineProperty(XMLDocument2.prototype, "origin", {
            get: function() {
              return null;
            }
          });
          Object.defineProperty(XMLDocument2.prototype, "compatMode", {
            get: function() {
              return null;
            }
          });
          Object.defineProperty(XMLDocument2.prototype, "characterSet", {
            get: function() {
              return null;
            }
          });
          Object.defineProperty(XMLDocument2.prototype, "contentType", {
            get: function() {
              return null;
            }
          });
          XMLDocument2.prototype.end = function(writer) {
            var writerOptions;
            writerOptions = {};
            if (!writer) {
              writer = this.options.writer;
            } else if (isPlainObject(writer)) {
              writerOptions = writer;
              writer = this.options.writer;
            }
            return writer.document(this, writer.filterOptions(writerOptions));
          };
          XMLDocument2.prototype.toString = function(options) {
            return this.options.writer.document(this, this.options.writer.filterOptions(options));
          };
          XMLDocument2.prototype.createElement = function(tagName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.createDocumentFragment = function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.createTextNode = function(data) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.createComment = function(data) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.createCDATASection = function(data) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.createProcessingInstruction = function(target, data) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.createAttribute = function(name) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.createEntityReference = function(name) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.getElementsByTagName = function(tagname) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.importNode = function(importedNode, deep) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.createElementNS = function(namespaceURI, qualifiedName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.createAttributeNS = function(namespaceURI, qualifiedName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.getElementById = function(elementId) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.adoptNode = function(source) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.normalizeDocument = function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.renameNode = function(node, namespaceURI, qualifiedName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.getElementsByClassName = function(classNames) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.createEvent = function(eventInterface) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.createRange = function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.createNodeIterator = function(root, whatToShow, filter) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.createTreeWalker = function(root, whatToShow, filter) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          return XMLDocument2;
        }(XMLNode);
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLDocumentCB.js
  var require_XMLDocumentCB = __commonJS({
    "node_modules/xmlbuilder/lib/XMLDocumentCB.js"(exports, module) {
      (function() {
        var NodeType, WriterState, XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocument, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, getValue, isFunction, isObject, isPlainObject, ref, hasProp = {}.hasOwnProperty;
        ref = require_Utility(), isObject = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject, getValue = ref.getValue;
        NodeType = require_NodeType();
        XMLDocument = require_XMLDocument();
        XMLElement = require_XMLElement();
        XMLCData = require_XMLCData();
        XMLComment = require_XMLComment();
        XMLRaw = require_XMLRaw();
        XMLText = require_XMLText();
        XMLProcessingInstruction = require_XMLProcessingInstruction();
        XMLDeclaration = require_XMLDeclaration();
        XMLDocType = require_XMLDocType();
        XMLDTDAttList = require_XMLDTDAttList();
        XMLDTDEntity = require_XMLDTDEntity();
        XMLDTDElement = require_XMLDTDElement();
        XMLDTDNotation = require_XMLDTDNotation();
        XMLAttribute = require_XMLAttribute();
        XMLStringifier = require_XMLStringifier();
        XMLStringWriter = require_XMLStringWriter();
        WriterState = require_WriterState();
        module.exports = XMLDocumentCB = function() {
          function XMLDocumentCB2(options, onData, onEnd) {
            var writerOptions;
            this.name = "?xml";
            this.type = NodeType.Document;
            options || (options = {});
            writerOptions = {};
            if (!options.writer) {
              options.writer = new XMLStringWriter();
            } else if (isPlainObject(options.writer)) {
              writerOptions = options.writer;
              options.writer = new XMLStringWriter();
            }
            this.options = options;
            this.writer = options.writer;
            this.writerOptions = this.writer.filterOptions(writerOptions);
            this.stringify = new XMLStringifier(options);
            this.onDataCallback = onData || function() {
            };
            this.onEndCallback = onEnd || function() {
            };
            this.currentNode = null;
            this.currentLevel = -1;
            this.openTags = {};
            this.documentStarted = false;
            this.documentCompleted = false;
            this.root = null;
          }
          XMLDocumentCB2.prototype.createChildNode = function(node) {
            var att, attName, attributes, child, i, len, ref1, ref2;
            switch (node.type) {
              case NodeType.CData:
                this.cdata(node.value);
                break;
              case NodeType.Comment:
                this.comment(node.value);
                break;
              case NodeType.Element:
                attributes = {};
                ref1 = node.attribs;
                for (attName in ref1) {
                  if (!hasProp.call(ref1, attName))
                    continue;
                  att = ref1[attName];
                  attributes[attName] = att.value;
                }
                this.node(node.name, attributes);
                break;
              case NodeType.Dummy:
                this.dummy();
                break;
              case NodeType.Raw:
                this.raw(node.value);
                break;
              case NodeType.Text:
                this.text(node.value);
                break;
              case NodeType.ProcessingInstruction:
                this.instruction(node.target, node.value);
                break;
              default:
                throw new Error("This XML node type is not supported in a JS object: " + node.constructor.name);
            }
            ref2 = node.children;
            for (i = 0, len = ref2.length; i < len; i++) {
              child = ref2[i];
              this.createChildNode(child);
              if (child.type === NodeType.Element) {
                this.up();
              }
            }
            return this;
          };
          XMLDocumentCB2.prototype.dummy = function() {
            return this;
          };
          XMLDocumentCB2.prototype.node = function(name, attributes, text) {
            var ref1;
            if (name == null) {
              throw new Error("Missing node name.");
            }
            if (this.root && this.currentLevel === -1) {
              throw new Error("Document can only have one root node. " + this.debugInfo(name));
            }
            this.openCurrent();
            name = getValue(name);
            if (attributes == null) {
              attributes = {};
            }
            attributes = getValue(attributes);
            if (!isObject(attributes)) {
              ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
            }
            this.currentNode = new XMLElement(this, name, attributes);
            this.currentNode.children = false;
            this.currentLevel++;
            this.openTags[this.currentLevel] = this.currentNode;
            if (text != null) {
              this.text(text);
            }
            return this;
          };
          XMLDocumentCB2.prototype.element = function(name, attributes, text) {
            var child, i, len, oldValidationFlag, ref1, root;
            if (this.currentNode && this.currentNode.type === NodeType.DocType) {
              this.dtdElement.apply(this, arguments);
            } else {
              if (Array.isArray(name) || isObject(name) || isFunction(name)) {
                oldValidationFlag = this.options.noValidation;
                this.options.noValidation = true;
                root = new XMLDocument(this.options).element("TEMP_ROOT");
                root.element(name);
                this.options.noValidation = oldValidationFlag;
                ref1 = root.children;
                for (i = 0, len = ref1.length; i < len; i++) {
                  child = ref1[i];
                  this.createChildNode(child);
                  if (child.type === NodeType.Element) {
                    this.up();
                  }
                }
              } else {
                this.node(name, attributes, text);
              }
            }
            return this;
          };
          XMLDocumentCB2.prototype.attribute = function(name, value) {
            var attName, attValue;
            if (!this.currentNode || this.currentNode.children) {
              throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(name));
            }
            if (name != null) {
              name = getValue(name);
            }
            if (isObject(name)) {
              for (attName in name) {
                if (!hasProp.call(name, attName))
                  continue;
                attValue = name[attName];
                this.attribute(attName, attValue);
              }
            } else {
              if (isFunction(value)) {
                value = value.apply();
              }
              if (this.options.keepNullAttributes && value == null) {
                this.currentNode.attribs[name] = new XMLAttribute(this, name, "");
              } else if (value != null) {
                this.currentNode.attribs[name] = new XMLAttribute(this, name, value);
              }
            }
            return this;
          };
          XMLDocumentCB2.prototype.text = function(value) {
            var node;
            this.openCurrent();
            node = new XMLText(this, value);
            this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
          };
          XMLDocumentCB2.prototype.cdata = function(value) {
            var node;
            this.openCurrent();
            node = new XMLCData(this, value);
            this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
          };
          XMLDocumentCB2.prototype.comment = function(value) {
            var node;
            this.openCurrent();
            node = new XMLComment(this, value);
            this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
          };
          XMLDocumentCB2.prototype.raw = function(value) {
            var node;
            this.openCurrent();
            node = new XMLRaw(this, value);
            this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
          };
          XMLDocumentCB2.prototype.instruction = function(target, value) {
            var i, insTarget, insValue, len, node;
            this.openCurrent();
            if (target != null) {
              target = getValue(target);
            }
            if (value != null) {
              value = getValue(value);
            }
            if (Array.isArray(target)) {
              for (i = 0, len = target.length; i < len; i++) {
                insTarget = target[i];
                this.instruction(insTarget);
              }
            } else if (isObject(target)) {
              for (insTarget in target) {
                if (!hasProp.call(target, insTarget))
                  continue;
                insValue = target[insTarget];
                this.instruction(insTarget, insValue);
              }
            } else {
              if (isFunction(value)) {
                value = value.apply();
              }
              node = new XMLProcessingInstruction(this, target, value);
              this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            }
            return this;
          };
          XMLDocumentCB2.prototype.declaration = function(version, encoding, standalone) {
            var node;
            this.openCurrent();
            if (this.documentStarted) {
              throw new Error("declaration() must be the first node.");
            }
            node = new XMLDeclaration(this, version, encoding, standalone);
            this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
          };
          XMLDocumentCB2.prototype.doctype = function(root, pubID, sysID) {
            this.openCurrent();
            if (root == null) {
              throw new Error("Missing root node name.");
            }
            if (this.root) {
              throw new Error("dtd() must come before the root node.");
            }
            this.currentNode = new XMLDocType(this, pubID, sysID);
            this.currentNode.rootNodeName = root;
            this.currentNode.children = false;
            this.currentLevel++;
            this.openTags[this.currentLevel] = this.currentNode;
            return this;
          };
          XMLDocumentCB2.prototype.dtdElement = function(name, value) {
            var node;
            this.openCurrent();
            node = new XMLDTDElement(this, name, value);
            this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
          };
          XMLDocumentCB2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
            var node;
            this.openCurrent();
            node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
            this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
          };
          XMLDocumentCB2.prototype.entity = function(name, value) {
            var node;
            this.openCurrent();
            node = new XMLDTDEntity(this, false, name, value);
            this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
          };
          XMLDocumentCB2.prototype.pEntity = function(name, value) {
            var node;
            this.openCurrent();
            node = new XMLDTDEntity(this, true, name, value);
            this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
          };
          XMLDocumentCB2.prototype.notation = function(name, value) {
            var node;
            this.openCurrent();
            node = new XMLDTDNotation(this, name, value);
            this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
          };
          XMLDocumentCB2.prototype.up = function() {
            if (this.currentLevel < 0) {
              throw new Error("The document node has no parent.");
            }
            if (this.currentNode) {
              if (this.currentNode.children) {
                this.closeNode(this.currentNode);
              } else {
                this.openNode(this.currentNode);
              }
              this.currentNode = null;
            } else {
              this.closeNode(this.openTags[this.currentLevel]);
            }
            delete this.openTags[this.currentLevel];
            this.currentLevel--;
            return this;
          };
          XMLDocumentCB2.prototype.end = function() {
            while (this.currentLevel >= 0) {
              this.up();
            }
            return this.onEnd();
          };
          XMLDocumentCB2.prototype.openCurrent = function() {
            if (this.currentNode) {
              this.currentNode.children = true;
              return this.openNode(this.currentNode);
            }
          };
          XMLDocumentCB2.prototype.openNode = function(node) {
            var att, chunk, name, ref1;
            if (!node.isOpen) {
              if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element) {
                this.root = node;
              }
              chunk = "";
              if (node.type === NodeType.Element) {
                this.writerOptions.state = WriterState.OpenTag;
                chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "<" + node.name;
                ref1 = node.attribs;
                for (name in ref1) {
                  if (!hasProp.call(ref1, name))
                    continue;
                  att = ref1[name];
                  chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);
                }
                chunk += (node.children ? ">" : "/>") + this.writer.endline(node, this.writerOptions, this.currentLevel);
                this.writerOptions.state = WriterState.InsideTag;
              } else {
                this.writerOptions.state = WriterState.OpenTag;
                chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "<!DOCTYPE " + node.rootNodeName;
                if (node.pubID && node.sysID) {
                  chunk += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
                } else if (node.sysID) {
                  chunk += ' SYSTEM "' + node.sysID + '"';
                }
                if (node.children) {
                  chunk += " [";
                  this.writerOptions.state = WriterState.InsideTag;
                } else {
                  this.writerOptions.state = WriterState.CloseTag;
                  chunk += ">";
                }
                chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);
              }
              this.onData(chunk, this.currentLevel);
              return node.isOpen = true;
            }
          };
          XMLDocumentCB2.prototype.closeNode = function(node) {
            var chunk;
            if (!node.isClosed) {
              chunk = "";
              this.writerOptions.state = WriterState.CloseTag;
              if (node.type === NodeType.Element) {
                chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "</" + node.name + ">" + this.writer.endline(node, this.writerOptions, this.currentLevel);
              } else {
                chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "]>" + this.writer.endline(node, this.writerOptions, this.currentLevel);
              }
              this.writerOptions.state = WriterState.None;
              this.onData(chunk, this.currentLevel);
              return node.isClosed = true;
            }
          };
          XMLDocumentCB2.prototype.onData = function(chunk, level) {
            this.documentStarted = true;
            return this.onDataCallback(chunk, level + 1);
          };
          XMLDocumentCB2.prototype.onEnd = function() {
            this.documentCompleted = true;
            return this.onEndCallback();
          };
          XMLDocumentCB2.prototype.debugInfo = function(name) {
            if (name == null) {
              return "";
            } else {
              return "node: <" + name + ">";
            }
          };
          XMLDocumentCB2.prototype.ele = function() {
            return this.element.apply(this, arguments);
          };
          XMLDocumentCB2.prototype.nod = function(name, attributes, text) {
            return this.node(name, attributes, text);
          };
          XMLDocumentCB2.prototype.txt = function(value) {
            return this.text(value);
          };
          XMLDocumentCB2.prototype.dat = function(value) {
            return this.cdata(value);
          };
          XMLDocumentCB2.prototype.com = function(value) {
            return this.comment(value);
          };
          XMLDocumentCB2.prototype.ins = function(target, value) {
            return this.instruction(target, value);
          };
          XMLDocumentCB2.prototype.dec = function(version, encoding, standalone) {
            return this.declaration(version, encoding, standalone);
          };
          XMLDocumentCB2.prototype.dtd = function(root, pubID, sysID) {
            return this.doctype(root, pubID, sysID);
          };
          XMLDocumentCB2.prototype.e = function(name, attributes, text) {
            return this.element(name, attributes, text);
          };
          XMLDocumentCB2.prototype.n = function(name, attributes, text) {
            return this.node(name, attributes, text);
          };
          XMLDocumentCB2.prototype.t = function(value) {
            return this.text(value);
          };
          XMLDocumentCB2.prototype.d = function(value) {
            return this.cdata(value);
          };
          XMLDocumentCB2.prototype.c = function(value) {
            return this.comment(value);
          };
          XMLDocumentCB2.prototype.r = function(value) {
            return this.raw(value);
          };
          XMLDocumentCB2.prototype.i = function(target, value) {
            return this.instruction(target, value);
          };
          XMLDocumentCB2.prototype.att = function() {
            if (this.currentNode && this.currentNode.type === NodeType.DocType) {
              return this.attList.apply(this, arguments);
            } else {
              return this.attribute.apply(this, arguments);
            }
          };
          XMLDocumentCB2.prototype.a = function() {
            if (this.currentNode && this.currentNode.type === NodeType.DocType) {
              return this.attList.apply(this, arguments);
            } else {
              return this.attribute.apply(this, arguments);
            }
          };
          XMLDocumentCB2.prototype.ent = function(name, value) {
            return this.entity(name, value);
          };
          XMLDocumentCB2.prototype.pent = function(name, value) {
            return this.pEntity(name, value);
          };
          XMLDocumentCB2.prototype.not = function(name, value) {
            return this.notation(name, value);
          };
          return XMLDocumentCB2;
        }();
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLStreamWriter.js
  var require_XMLStreamWriter = __commonJS({
    "node_modules/xmlbuilder/lib/XMLStreamWriter.js"(exports, module) {
      (function() {
        var NodeType, WriterState, XMLStreamWriter, XMLWriterBase, extend = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        NodeType = require_NodeType();
        XMLWriterBase = require_XMLWriterBase();
        WriterState = require_WriterState();
        module.exports = XMLStreamWriter = function(superClass) {
          extend(XMLStreamWriter2, superClass);
          function XMLStreamWriter2(stream, options) {
            this.stream = stream;
            XMLStreamWriter2.__super__.constructor.call(this, options);
          }
          XMLStreamWriter2.prototype.endline = function(node, options, level) {
            if (node.isLastRootNode && options.state === WriterState.CloseTag) {
              return "";
            } else {
              return XMLStreamWriter2.__super__.endline.call(this, node, options, level);
            }
          };
          XMLStreamWriter2.prototype.document = function(doc, options) {
            var child, i, j, k, len, len1, ref, ref1, results;
            ref = doc.children;
            for (i = j = 0, len = ref.length; j < len; i = ++j) {
              child = ref[i];
              child.isLastRootNode = i === doc.children.length - 1;
            }
            options = this.filterOptions(options);
            ref1 = doc.children;
            results = [];
            for (k = 0, len1 = ref1.length; k < len1; k++) {
              child = ref1[k];
              results.push(this.writeChildNode(child, options, 0));
            }
            return results;
          };
          XMLStreamWriter2.prototype.attribute = function(att, options, level) {
            return this.stream.write(XMLStreamWriter2.__super__.attribute.call(this, att, options, level));
          };
          XMLStreamWriter2.prototype.cdata = function(node, options, level) {
            return this.stream.write(XMLStreamWriter2.__super__.cdata.call(this, node, options, level));
          };
          XMLStreamWriter2.prototype.comment = function(node, options, level) {
            return this.stream.write(XMLStreamWriter2.__super__.comment.call(this, node, options, level));
          };
          XMLStreamWriter2.prototype.declaration = function(node, options, level) {
            return this.stream.write(XMLStreamWriter2.__super__.declaration.call(this, node, options, level));
          };
          XMLStreamWriter2.prototype.docType = function(node, options, level) {
            var child, j, len, ref;
            level || (level = 0);
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            this.stream.write(this.indent(node, options, level));
            this.stream.write("<!DOCTYPE " + node.root().name);
            if (node.pubID && node.sysID) {
              this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
            } else if (node.sysID) {
              this.stream.write(' SYSTEM "' + node.sysID + '"');
            }
            if (node.children.length > 0) {
              this.stream.write(" [");
              this.stream.write(this.endline(node, options, level));
              options.state = WriterState.InsideTag;
              ref = node.children;
              for (j = 0, len = ref.length; j < len; j++) {
                child = ref[j];
                this.writeChildNode(child, options, level + 1);
              }
              options.state = WriterState.CloseTag;
              this.stream.write("]");
            }
            options.state = WriterState.CloseTag;
            this.stream.write(options.spaceBeforeSlash + ">");
            this.stream.write(this.endline(node, options, level));
            options.state = WriterState.None;
            return this.closeNode(node, options, level);
          };
          XMLStreamWriter2.prototype.element = function(node, options, level) {
            var att, child, childNodeCount, firstChildNode, j, len, name, prettySuppressed, ref, ref1;
            level || (level = 0);
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            this.stream.write(this.indent(node, options, level) + "<" + node.name);
            ref = node.attribs;
            for (name in ref) {
              if (!hasProp.call(ref, name))
                continue;
              att = ref[name];
              this.attribute(att, options, level);
            }
            childNodeCount = node.children.length;
            firstChildNode = childNodeCount === 0 ? null : node.children[0];
            if (childNodeCount === 0 || node.children.every(function(e) {
              return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === "";
            })) {
              if (options.allowEmpty) {
                this.stream.write(">");
                options.state = WriterState.CloseTag;
                this.stream.write("</" + node.name + ">");
              } else {
                options.state = WriterState.CloseTag;
                this.stream.write(options.spaceBeforeSlash + "/>");
              }
            } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {
              this.stream.write(">");
              options.state = WriterState.InsideTag;
              options.suppressPrettyCount++;
              prettySuppressed = true;
              this.writeChildNode(firstChildNode, options, level + 1);
              options.suppressPrettyCount--;
              prettySuppressed = false;
              options.state = WriterState.CloseTag;
              this.stream.write("</" + node.name + ">");
            } else {
              this.stream.write(">" + this.endline(node, options, level));
              options.state = WriterState.InsideTag;
              ref1 = node.children;
              for (j = 0, len = ref1.length; j < len; j++) {
                child = ref1[j];
                this.writeChildNode(child, options, level + 1);
              }
              options.state = WriterState.CloseTag;
              this.stream.write(this.indent(node, options, level) + "</" + node.name + ">");
            }
            this.stream.write(this.endline(node, options, level));
            options.state = WriterState.None;
            return this.closeNode(node, options, level);
          };
          XMLStreamWriter2.prototype.processingInstruction = function(node, options, level) {
            return this.stream.write(XMLStreamWriter2.__super__.processingInstruction.call(this, node, options, level));
          };
          XMLStreamWriter2.prototype.raw = function(node, options, level) {
            return this.stream.write(XMLStreamWriter2.__super__.raw.call(this, node, options, level));
          };
          XMLStreamWriter2.prototype.text = function(node, options, level) {
            return this.stream.write(XMLStreamWriter2.__super__.text.call(this, node, options, level));
          };
          XMLStreamWriter2.prototype.dtdAttList = function(node, options, level) {
            return this.stream.write(XMLStreamWriter2.__super__.dtdAttList.call(this, node, options, level));
          };
          XMLStreamWriter2.prototype.dtdElement = function(node, options, level) {
            return this.stream.write(XMLStreamWriter2.__super__.dtdElement.call(this, node, options, level));
          };
          XMLStreamWriter2.prototype.dtdEntity = function(node, options, level) {
            return this.stream.write(XMLStreamWriter2.__super__.dtdEntity.call(this, node, options, level));
          };
          XMLStreamWriter2.prototype.dtdNotation = function(node, options, level) {
            return this.stream.write(XMLStreamWriter2.__super__.dtdNotation.call(this, node, options, level));
          };
          return XMLStreamWriter2;
        }(XMLWriterBase);
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/index.js
  var require_lib = __commonJS({
    "node_modules/xmlbuilder/lib/index.js"(exports, module) {
      (function() {
        var NodeType, WriterState, XMLDOMImplementation, XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;
        ref = require_Utility(), assign = ref.assign, isFunction = ref.isFunction;
        XMLDOMImplementation = require_XMLDOMImplementation();
        XMLDocument = require_XMLDocument();
        XMLDocumentCB = require_XMLDocumentCB();
        XMLStringWriter = require_XMLStringWriter();
        XMLStreamWriter = require_XMLStreamWriter();
        NodeType = require_NodeType();
        WriterState = require_WriterState();
        module.exports.create = function(name, xmldec, doctype, options) {
          var doc, root;
          if (name == null) {
            throw new Error("Root element needs a name.");
          }
          options = assign({}, xmldec, doctype, options);
          doc = new XMLDocument(options);
          root = doc.element(name);
          if (!options.headless) {
            doc.declaration(options);
            if (options.pubID != null || options.sysID != null) {
              doc.dtd(options);
            }
          }
          return root;
        };
        module.exports.begin = function(options, onData, onEnd) {
          var ref1;
          if (isFunction(options)) {
            ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];
            options = {};
          }
          if (onData) {
            return new XMLDocumentCB(options, onData, onEnd);
          } else {
            return new XMLDocument(options);
          }
        };
        module.exports.stringWriter = function(options) {
          return new XMLStringWriter(options);
        };
        module.exports.streamWriter = function(stream, options) {
          return new XMLStreamWriter(stream, options);
        };
        module.exports.implementation = new XMLDOMImplementation();
        module.exports.nodeType = NodeType;
        module.exports.writerState = WriterState;
      }).call(exports);
    }
  });

  // node_modules/xml2js/lib/builder.js
  var require_builder = __commonJS({
    "node_modules/xml2js/lib/builder.js"(exports) {
      (function() {
        "use strict";
        var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA, hasProp = {}.hasOwnProperty;
        builder = require_lib();
        defaults = require_defaults().defaults;
        requiresCDATA = function(entry) {
          return typeof entry === "string" && (entry.indexOf("&") >= 0 || entry.indexOf(">") >= 0 || entry.indexOf("<") >= 0);
        };
        wrapCDATA = function(entry) {
          return "<![CDATA[" + escapeCDATA(entry) + "]]>";
        };
        escapeCDATA = function(entry) {
          return entry.replace("]]>", "]]]]><![CDATA[>");
        };
        exports.Builder = function() {
          function Builder(opts) {
            var key, ref, value;
            this.options = {};
            ref = defaults["0.2"];
            for (key in ref) {
              if (!hasProp.call(ref, key))
                continue;
              value = ref[key];
              this.options[key] = value;
            }
            for (key in opts) {
              if (!hasProp.call(opts, key))
                continue;
              value = opts[key];
              this.options[key] = value;
            }
          }
          Builder.prototype.buildObject = function(rootObj) {
            var attrkey, charkey, render, rootElement, rootName;
            attrkey = this.options.attrkey;
            charkey = this.options.charkey;
            if (Object.keys(rootObj).length === 1 && this.options.rootName === defaults["0.2"].rootName) {
              rootName = Object.keys(rootObj)[0];
              rootObj = rootObj[rootName];
            } else {
              rootName = this.options.rootName;
            }
            render = function(_this) {
              return function(element, obj) {
                var attr, child, entry, index, key, value;
                if (typeof obj !== "object") {
                  if (_this.options.cdata && requiresCDATA(obj)) {
                    element.raw(wrapCDATA(obj));
                  } else {
                    element.txt(obj);
                  }
                } else if (Array.isArray(obj)) {
                  for (index in obj) {
                    if (!hasProp.call(obj, index))
                      continue;
                    child = obj[index];
                    for (key in child) {
                      entry = child[key];
                      element = render(element.ele(key), entry).up();
                    }
                  }
                } else {
                  for (key in obj) {
                    if (!hasProp.call(obj, key))
                      continue;
                    child = obj[key];
                    if (key === attrkey) {
                      if (typeof child === "object") {
                        for (attr in child) {
                          value = child[attr];
                          element = element.att(attr, value);
                        }
                      }
                    } else if (key === charkey) {
                      if (_this.options.cdata && requiresCDATA(child)) {
                        element = element.raw(wrapCDATA(child));
                      } else {
                        element = element.txt(child);
                      }
                    } else if (Array.isArray(child)) {
                      for (index in child) {
                        if (!hasProp.call(child, index))
                          continue;
                        entry = child[index];
                        if (typeof entry === "string") {
                          if (_this.options.cdata && requiresCDATA(entry)) {
                            element = element.ele(key).raw(wrapCDATA(entry)).up();
                          } else {
                            element = element.ele(key, entry).up();
                          }
                        } else {
                          element = render(element.ele(key), entry).up();
                        }
                      }
                    } else if (typeof child === "object") {
                      element = render(element.ele(key), child).up();
                    } else {
                      if (typeof child === "string" && _this.options.cdata && requiresCDATA(child)) {
                        element = element.ele(key).raw(wrapCDATA(child)).up();
                      } else {
                        if (child == null) {
                          child = "";
                        }
                        element = element.ele(key, child.toString()).up();
                      }
                    }
                  }
                }
                return element;
              };
            }(this);
            rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
              headless: this.options.headless,
              allowSurrogateChars: this.options.allowSurrogateChars
            });
            return render(rootElement, rootObj).end(this.options.renderOpts);
          };
          return Builder;
        }();
      }).call(exports);
    }
  });

  // node_modules/buffer/node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/buffer/node_modules/base64-js/index.js"(exports) {
      "use strict";
      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      var i;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1)
          validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
          );
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
          );
        }
        return parts.join("");
      }
    }
  });

  // node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/ieee754/index.js"(exports) {
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i - d] |= s * 128;
      };
    }
  });

  // node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "node_modules/buffer/index.js"(exports) {
      "use strict";
      var base64 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer2;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new Uint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, Uint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer2.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer2.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new Uint8Array(length);
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function Buffer2(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer2.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (ArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer2.from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b)
          return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer2.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(Buffer2, Uint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer2.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength(string, encoding) | 0;
        let buf = createBuffer(length);
        const actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        const length = array.length < 0 ? 0 : checked(array.length) | 0;
        const buf = createBuffer(length);
        for (let i = 0; i < length; i += 1) {
          buf[i] = array[i] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, Uint8Array)) {
          const copy = new Uint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new Uint8Array(array);
        } else if (length === void 0) {
          buf = new Uint8Array(array, byteOffset);
        } else {
          buf = new Uint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer2.isBuffer(obj)) {
          const len = checked(obj.length) | 0;
          const buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer2.alloc(+length);
      }
      Buffer2.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer2.prototype;
      };
      Buffer2.compare = function compare(a, b) {
        if (isInstance(a, Uint8Array))
          a = Buffer2.from(a, a.offset, a.byteLength);
        if (isInstance(b, Uint8Array))
          b = Buffer2.from(b, b.offset, b.byteLength);
        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b)
          return 0;
        let x = a.length;
        let y = b.length;
        for (let i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        let i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        const buffer = Buffer2.allocUnsafe(length);
        let pos = 0;
        for (i = 0; i < list.length; ++i) {
          let buf = list[i];
          if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
              if (!Buffer2.isBuffer(buf))
                buf = Buffer2.from(buf);
              buf.copy(buffer, pos);
            } else {
              Uint8Array.prototype.set.call(
                buffer,
                buf,
                pos
              );
            }
          } else if (!Buffer2.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string, encoding) {
        if (Buffer2.isBuffer(string)) {
          return string.length;
        }
        if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
          );
        }
        const len = string.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0)
          return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding)
          encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.prototype._isBuffer = true;
      function swap(b, n, m) {
        const i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer2.prototype.swap16 = function swap16() {
        const len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap32() {
        const len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap64() {
        const len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString() {
        const length = this.length;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
      Buffer2.prototype.equals = function equals(b) {
        if (!Buffer2.isBuffer(b))
          throw new TypeError("Argument must be a Buffer");
        if (this === b)
          return true;
        return Buffer2.compare(this, b) === 0;
      };
      Buffer2.prototype.inspect = function inspect() {
        let str = "";
        const max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max)
          str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
      }
      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, Uint8Array)) {
          target = Buffer2.from(target, target.offset, target.byteLength);
        }
        if (!Buffer2.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        let x = thisEnd - thisStart;
        let y = end - start;
        const len = Math.min(x, y);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer2.from(val, encoding);
        }
        if (Buffer2.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        let i;
        if (dir) {
          let foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i;
              if (i - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
              }
            }
            if (found)
              return i;
          }
        }
        return -1;
      }
      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        const remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i;
        for (i = 0; i < length; ++i) {
          const parsed = parseInt(string.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed))
            return i;
          buf[offset + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer2.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i = start;
        while (i < end) {
          const firstByte = buf[i];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        let out = "";
        for (let i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer2.prototype.slice = function slice(start, end) {
        const len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer2.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (offset + ext > length)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        let val = this[offset + --byteLength2];
        let mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let i = byteLength2;
        let mul = 1;
        let val = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
      });
      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = (first << 24) + // Overflow
        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
      });
      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer2.isBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let mul = 1;
        let i = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function wrtBigUInt64LE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        return offset;
      }
      function wrtBigUInt64BE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi;
        hi = hi >> 8;
        buf[offset + 2] = hi;
        hi = hi >> 8;
        buf[offset + 1] = hi;
        hi = hi >> 8;
        buf[offset] = hi;
        return offset + 8;
      }
      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = 0;
        let mul = 1;
        let sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        let sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer2.isBuffer(target))
          throw new TypeError("argument should be a Buffer");
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("Index out of range");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len = end - start;
        if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          Uint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len;
      };
      Buffer2.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        let i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
          const len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var errors = {};
      function E(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E(
        "ERR_OUT_OF_RANGE",
        function(str, range, input) {
          let msg = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i >= start + 4; i -= 3) {
          res = `_${val.slice(i - 3, i)}${res}`;
        }
        return `${val.slice(0, i)}${res}`;
      }
      function checkBounds(buf, offset, byteLength2) {
        validateNumber(offset, "offset");
        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
          boundsError(offset, buf.length - (byteLength2 + 1));
        }
      }
      function checkIntBI(value, min, max, buf, offset, byteLength2) {
        if (value > max || value < min) {
          const n = typeof min === "bigint" ? "n" : "";
          let range;
          if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
          } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range, value);
        }
        checkBounds(buf, offset, byteLength2);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type);
          throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          type || "offset",
          `>= ${type ? 1 : 0} and <= ${length}`,
          value
        );
      }
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2)
          return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        let codePoint;
        const length = string.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c, hi, lo;
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0)
            break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        let i;
        for (i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length)
            break;
          dst[i + offset] = src[i];
        }
        return i;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i = 0; i < 16; ++i) {
          const i16 = i * 16;
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }
        return table;
      }();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    }
  });

  // node_modules/string_decoder/index.js
  var require_string_decoder = __commonJS({
    "node_modules/string_decoder/index.js"(exports) {
      var Buffer2 = require_buffer().Buffer;
      var isBufferEncoding = Buffer2.isEncoding || function(encoding) {
        switch (encoding && encoding.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;
          default:
            return false;
        }
      };
      function assertEncoding(encoding) {
        if (encoding && !isBufferEncoding(encoding)) {
          throw new Error("Unknown encoding: " + encoding);
        }
      }
      var StringDecoder = exports.StringDecoder = function(encoding) {
        this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
        assertEncoding(encoding);
        switch (this.encoding) {
          case "utf8":
            this.surrogateSize = 3;
            break;
          case "ucs2":
          case "utf16le":
            this.surrogateSize = 2;
            this.detectIncompleteChar = utf16DetectIncompleteChar;
            break;
          case "base64":
            this.surrogateSize = 3;
            this.detectIncompleteChar = base64DetectIncompleteChar;
            break;
          default:
            this.write = passThroughWrite;
            return;
        }
        this.charBuffer = new Buffer2(6);
        this.charReceived = 0;
        this.charLength = 0;
      };
      StringDecoder.prototype.write = function(buffer) {
        var charStr = "";
        while (this.charLength) {
          var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
          buffer.copy(this.charBuffer, this.charReceived, 0, available);
          this.charReceived += available;
          if (this.charReceived < this.charLength) {
            return "";
          }
          buffer = buffer.slice(available, buffer.length);
          charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
          var charCode = charStr.charCodeAt(charStr.length - 1);
          if (charCode >= 55296 && charCode <= 56319) {
            this.charLength += this.surrogateSize;
            charStr = "";
            continue;
          }
          this.charReceived = this.charLength = 0;
          if (buffer.length === 0) {
            return charStr;
          }
          break;
        }
        this.detectIncompleteChar(buffer);
        var end = buffer.length;
        if (this.charLength) {
          buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
          end -= this.charReceived;
        }
        charStr += buffer.toString(this.encoding, 0, end);
        var end = charStr.length - 1;
        var charCode = charStr.charCodeAt(end);
        if (charCode >= 55296 && charCode <= 56319) {
          var size = this.surrogateSize;
          this.charLength += size;
          this.charReceived += size;
          this.charBuffer.copy(this.charBuffer, size, 0, size);
          buffer.copy(this.charBuffer, 0, 0, size);
          return charStr.substring(0, end);
        }
        return charStr;
      };
      StringDecoder.prototype.detectIncompleteChar = function(buffer) {
        var i = buffer.length >= 3 ? 3 : buffer.length;
        for (; i > 0; i--) {
          var c = buffer[buffer.length - i];
          if (i == 1 && c >> 5 == 6) {
            this.charLength = 2;
            break;
          }
          if (i <= 2 && c >> 4 == 14) {
            this.charLength = 3;
            break;
          }
          if (i <= 3 && c >> 3 == 30) {
            this.charLength = 4;
            break;
          }
        }
        this.charReceived = i;
      };
      StringDecoder.prototype.end = function(buffer) {
        var res = "";
        if (buffer && buffer.length)
          res = this.write(buffer);
        if (this.charReceived) {
          var cr = this.charReceived;
          var buf = this.charBuffer;
          var enc2 = this.encoding;
          res += buf.slice(0, cr).toString(enc2);
        }
        return res;
      };
      function passThroughWrite(buffer) {
        return buffer.toString(this.encoding);
      }
      function utf16DetectIncompleteChar(buffer) {
        this.charReceived = buffer.length % 2;
        this.charLength = this.charReceived ? 2 : 0;
      }
      function base64DetectIncompleteChar(buffer) {
        this.charReceived = buffer.length % 3;
        this.charLength = this.charReceived ? 3 : 0;
      }
    }
  });

  // node_modules/sax/lib/sax.js
  var require_sax = __commonJS({
    "node_modules/sax/lib/sax.js"(exports) {
      (function(sax) {
        sax.parser = function(strict, opt) {
          return new SAXParser(strict, opt);
        };
        sax.SAXParser = SAXParser;
        sax.SAXStream = SAXStream;
        sax.createStream = createStream;
        sax.MAX_BUFFER_LENGTH = 64 * 1024;
        var buffers = [
          "comment",
          "sgmlDecl",
          "textNode",
          "tagName",
          "doctype",
          "procInstName",
          "procInstBody",
          "entity",
          "attribName",
          "attribValue",
          "cdata",
          "script"
        ];
        sax.EVENTS = [
          "text",
          "processinginstruction",
          "sgmldeclaration",
          "doctype",
          "comment",
          "opentagstart",
          "attribute",
          "opentag",
          "closetag",
          "opencdata",
          "cdata",
          "closecdata",
          "error",
          "end",
          "ready",
          "script",
          "opennamespace",
          "closenamespace"
        ];
        function SAXParser(strict, opt) {
          if (!(this instanceof SAXParser)) {
            return new SAXParser(strict, opt);
          }
          var parser = this;
          clearBuffers(parser);
          parser.q = parser.c = "";
          parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
          parser.opt = opt || {};
          parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
          parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
          parser.tags = [];
          parser.closed = parser.closedRoot = parser.sawRoot = false;
          parser.tag = parser.error = null;
          parser.strict = !!strict;
          parser.noscript = !!(strict || parser.opt.noscript);
          parser.state = S.BEGIN;
          parser.strictEntities = parser.opt.strictEntities;
          parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
          parser.attribList = [];
          if (parser.opt.xmlns) {
            parser.ns = Object.create(rootNS);
          }
          parser.trackPosition = parser.opt.position !== false;
          if (parser.trackPosition) {
            parser.position = parser.line = parser.column = 0;
          }
          emit(parser, "onready");
        }
        if (!Object.create) {
          Object.create = function(o) {
            function F() {
            }
            F.prototype = o;
            var newf = new F();
            return newf;
          };
        }
        if (!Object.keys) {
          Object.keys = function(o) {
            var a = [];
            for (var i in o)
              if (o.hasOwnProperty(i))
                a.push(i);
            return a;
          };
        }
        function checkBufferLength(parser) {
          var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
          var maxActual = 0;
          for (var i = 0, l = buffers.length; i < l; i++) {
            var len = parser[buffers[i]].length;
            if (len > maxAllowed) {
              switch (buffers[i]) {
                case "textNode":
                  closeText(parser);
                  break;
                case "cdata":
                  emitNode(parser, "oncdata", parser.cdata);
                  parser.cdata = "";
                  break;
                case "script":
                  emitNode(parser, "onscript", parser.script);
                  parser.script = "";
                  break;
                default:
                  error(parser, "Max buffer length exceeded: " + buffers[i]);
              }
            }
            maxActual = Math.max(maxActual, len);
          }
          var m = sax.MAX_BUFFER_LENGTH - maxActual;
          parser.bufferCheckPosition = m + parser.position;
        }
        function clearBuffers(parser) {
          for (var i = 0, l = buffers.length; i < l; i++) {
            parser[buffers[i]] = "";
          }
        }
        function flushBuffers(parser) {
          closeText(parser);
          if (parser.cdata !== "") {
            emitNode(parser, "oncdata", parser.cdata);
            parser.cdata = "";
          }
          if (parser.script !== "") {
            emitNode(parser, "onscript", parser.script);
            parser.script = "";
          }
        }
        SAXParser.prototype = {
          end: function() {
            end(this);
          },
          write,
          resume: function() {
            this.error = null;
            return this;
          },
          close: function() {
            return this.write(null);
          },
          flush: function() {
            flushBuffers(this);
          }
        };
        var Stream;
        try {
          Stream = __require("stream").Stream;
        } catch (ex) {
          Stream = function() {
          };
        }
        var streamWraps = sax.EVENTS.filter(function(ev) {
          return ev !== "error" && ev !== "end";
        });
        function createStream(strict, opt) {
          return new SAXStream(strict, opt);
        }
        function SAXStream(strict, opt) {
          if (!(this instanceof SAXStream)) {
            return new SAXStream(strict, opt);
          }
          Stream.apply(this);
          this._parser = new SAXParser(strict, opt);
          this.writable = true;
          this.readable = true;
          var me = this;
          this._parser.onend = function() {
            me.emit("end");
          };
          this._parser.onerror = function(er) {
            me.emit("error", er);
            me._parser.error = null;
          };
          this._decoder = null;
          streamWraps.forEach(function(ev) {
            Object.defineProperty(me, "on" + ev, {
              get: function() {
                return me._parser["on" + ev];
              },
              set: function(h) {
                if (!h) {
                  me.removeAllListeners(ev);
                  me._parser["on" + ev] = h;
                  return h;
                }
                me.on(ev, h);
              },
              enumerable: true,
              configurable: false
            });
          });
        }
        SAXStream.prototype = Object.create(Stream.prototype, {
          constructor: {
            value: SAXStream
          }
        });
        SAXStream.prototype.write = function(data) {
          if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
            if (!this._decoder) {
              var SD = require_string_decoder().StringDecoder;
              this._decoder = new SD("utf8");
            }
            data = this._decoder.write(data);
          }
          this._parser.write(data.toString());
          this.emit("data", data);
          return true;
        };
        SAXStream.prototype.end = function(chunk) {
          if (chunk && chunk.length) {
            this.write(chunk);
          }
          this._parser.end();
          return true;
        };
        SAXStream.prototype.on = function(ev, handler) {
          var me = this;
          if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
            me._parser["on" + ev] = function() {
              var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
              args.splice(0, 0, ev);
              me.emit.apply(me, args);
            };
          }
          return Stream.prototype.on.call(me, ev, handler);
        };
        var CDATA = "[CDATA[";
        var DOCTYPE = "DOCTYPE";
        var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
        var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
        var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
        var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
        var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
        var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
        var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
        function isWhitespace(c) {
          return c === " " || c === "\n" || c === "\r" || c === "	";
        }
        function isQuote(c) {
          return c === '"' || c === "'";
        }
        function isAttribEnd(c) {
          return c === ">" || isWhitespace(c);
        }
        function isMatch(regex, c) {
          return regex.test(c);
        }
        function notMatch(regex, c) {
          return !isMatch(regex, c);
        }
        var S = 0;
        sax.STATE = {
          BEGIN: S++,
          // leading byte order mark or whitespace
          BEGIN_WHITESPACE: S++,
          // leading whitespace
          TEXT: S++,
          // general stuff
          TEXT_ENTITY: S++,
          // &amp and such.
          OPEN_WAKA: S++,
          // <
          SGML_DECL: S++,
          // <!BLARG
          SGML_DECL_QUOTED: S++,
          // <!BLARG foo "bar
          DOCTYPE: S++,
          // <!DOCTYPE
          DOCTYPE_QUOTED: S++,
          // <!DOCTYPE "//blah
          DOCTYPE_DTD: S++,
          // <!DOCTYPE "//blah" [ ...
          DOCTYPE_DTD_QUOTED: S++,
          // <!DOCTYPE "//blah" [ "foo
          COMMENT_STARTING: S++,
          // <!-
          COMMENT: S++,
          // <!--
          COMMENT_ENDING: S++,
          // <!-- blah -
          COMMENT_ENDED: S++,
          // <!-- blah --
          CDATA: S++,
          // <![CDATA[ something
          CDATA_ENDING: S++,
          // ]
          CDATA_ENDING_2: S++,
          // ]]
          PROC_INST: S++,
          // <?hi
          PROC_INST_BODY: S++,
          // <?hi there
          PROC_INST_ENDING: S++,
          // <?hi "there" ?
          OPEN_TAG: S++,
          // <strong
          OPEN_TAG_SLASH: S++,
          // <strong /
          ATTRIB: S++,
          // <a
          ATTRIB_NAME: S++,
          // <a foo
          ATTRIB_NAME_SAW_WHITE: S++,
          // <a foo _
          ATTRIB_VALUE: S++,
          // <a foo=
          ATTRIB_VALUE_QUOTED: S++,
          // <a foo="bar
          ATTRIB_VALUE_CLOSED: S++,
          // <a foo="bar"
          ATTRIB_VALUE_UNQUOTED: S++,
          // <a foo=bar
          ATTRIB_VALUE_ENTITY_Q: S++,
          // <foo bar="&quot;"
          ATTRIB_VALUE_ENTITY_U: S++,
          // <foo bar=&quot
          CLOSE_TAG: S++,
          // </a
          CLOSE_TAG_SAW_WHITE: S++,
          // </a   >
          SCRIPT: S++,
          // <script> ...
          SCRIPT_ENDING: S++
          // <script> ... <
        };
        sax.XML_ENTITIES = {
          "amp": "&",
          "gt": ">",
          "lt": "<",
          "quot": '"',
          "apos": "'"
        };
        sax.ENTITIES = {
          "amp": "&",
          "gt": ">",
          "lt": "<",
          "quot": '"',
          "apos": "'",
          "AElig": 198,
          "Aacute": 193,
          "Acirc": 194,
          "Agrave": 192,
          "Aring": 197,
          "Atilde": 195,
          "Auml": 196,
          "Ccedil": 199,
          "ETH": 208,
          "Eacute": 201,
          "Ecirc": 202,
          "Egrave": 200,
          "Euml": 203,
          "Iacute": 205,
          "Icirc": 206,
          "Igrave": 204,
          "Iuml": 207,
          "Ntilde": 209,
          "Oacute": 211,
          "Ocirc": 212,
          "Ograve": 210,
          "Oslash": 216,
          "Otilde": 213,
          "Ouml": 214,
          "THORN": 222,
          "Uacute": 218,
          "Ucirc": 219,
          "Ugrave": 217,
          "Uuml": 220,
          "Yacute": 221,
          "aacute": 225,
          "acirc": 226,
          "aelig": 230,
          "agrave": 224,
          "aring": 229,
          "atilde": 227,
          "auml": 228,
          "ccedil": 231,
          "eacute": 233,
          "ecirc": 234,
          "egrave": 232,
          "eth": 240,
          "euml": 235,
          "iacute": 237,
          "icirc": 238,
          "igrave": 236,
          "iuml": 239,
          "ntilde": 241,
          "oacute": 243,
          "ocirc": 244,
          "ograve": 242,
          "oslash": 248,
          "otilde": 245,
          "ouml": 246,
          "szlig": 223,
          "thorn": 254,
          "uacute": 250,
          "ucirc": 251,
          "ugrave": 249,
          "uuml": 252,
          "yacute": 253,
          "yuml": 255,
          "copy": 169,
          "reg": 174,
          "nbsp": 160,
          "iexcl": 161,
          "cent": 162,
          "pound": 163,
          "curren": 164,
          "yen": 165,
          "brvbar": 166,
          "sect": 167,
          "uml": 168,
          "ordf": 170,
          "laquo": 171,
          "not": 172,
          "shy": 173,
          "macr": 175,
          "deg": 176,
          "plusmn": 177,
          "sup1": 185,
          "sup2": 178,
          "sup3": 179,
          "acute": 180,
          "micro": 181,
          "para": 182,
          "middot": 183,
          "cedil": 184,
          "ordm": 186,
          "raquo": 187,
          "frac14": 188,
          "frac12": 189,
          "frac34": 190,
          "iquest": 191,
          "times": 215,
          "divide": 247,
          "OElig": 338,
          "oelig": 339,
          "Scaron": 352,
          "scaron": 353,
          "Yuml": 376,
          "fnof": 402,
          "circ": 710,
          "tilde": 732,
          "Alpha": 913,
          "Beta": 914,
          "Gamma": 915,
          "Delta": 916,
          "Epsilon": 917,
          "Zeta": 918,
          "Eta": 919,
          "Theta": 920,
          "Iota": 921,
          "Kappa": 922,
          "Lambda": 923,
          "Mu": 924,
          "Nu": 925,
          "Xi": 926,
          "Omicron": 927,
          "Pi": 928,
          "Rho": 929,
          "Sigma": 931,
          "Tau": 932,
          "Upsilon": 933,
          "Phi": 934,
          "Chi": 935,
          "Psi": 936,
          "Omega": 937,
          "alpha": 945,
          "beta": 946,
          "gamma": 947,
          "delta": 948,
          "epsilon": 949,
          "zeta": 950,
          "eta": 951,
          "theta": 952,
          "iota": 953,
          "kappa": 954,
          "lambda": 955,
          "mu": 956,
          "nu": 957,
          "xi": 958,
          "omicron": 959,
          "pi": 960,
          "rho": 961,
          "sigmaf": 962,
          "sigma": 963,
          "tau": 964,
          "upsilon": 965,
          "phi": 966,
          "chi": 967,
          "psi": 968,
          "omega": 969,
          "thetasym": 977,
          "upsih": 978,
          "piv": 982,
          "ensp": 8194,
          "emsp": 8195,
          "thinsp": 8201,
          "zwnj": 8204,
          "zwj": 8205,
          "lrm": 8206,
          "rlm": 8207,
          "ndash": 8211,
          "mdash": 8212,
          "lsquo": 8216,
          "rsquo": 8217,
          "sbquo": 8218,
          "ldquo": 8220,
          "rdquo": 8221,
          "bdquo": 8222,
          "dagger": 8224,
          "Dagger": 8225,
          "bull": 8226,
          "hellip": 8230,
          "permil": 8240,
          "prime": 8242,
          "Prime": 8243,
          "lsaquo": 8249,
          "rsaquo": 8250,
          "oline": 8254,
          "frasl": 8260,
          "euro": 8364,
          "image": 8465,
          "weierp": 8472,
          "real": 8476,
          "trade": 8482,
          "alefsym": 8501,
          "larr": 8592,
          "uarr": 8593,
          "rarr": 8594,
          "darr": 8595,
          "harr": 8596,
          "crarr": 8629,
          "lArr": 8656,
          "uArr": 8657,
          "rArr": 8658,
          "dArr": 8659,
          "hArr": 8660,
          "forall": 8704,
          "part": 8706,
          "exist": 8707,
          "empty": 8709,
          "nabla": 8711,
          "isin": 8712,
          "notin": 8713,
          "ni": 8715,
          "prod": 8719,
          "sum": 8721,
          "minus": 8722,
          "lowast": 8727,
          "radic": 8730,
          "prop": 8733,
          "infin": 8734,
          "ang": 8736,
          "and": 8743,
          "or": 8744,
          "cap": 8745,
          "cup": 8746,
          "int": 8747,
          "there4": 8756,
          "sim": 8764,
          "cong": 8773,
          "asymp": 8776,
          "ne": 8800,
          "equiv": 8801,
          "le": 8804,
          "ge": 8805,
          "sub": 8834,
          "sup": 8835,
          "nsub": 8836,
          "sube": 8838,
          "supe": 8839,
          "oplus": 8853,
          "otimes": 8855,
          "perp": 8869,
          "sdot": 8901,
          "lceil": 8968,
          "rceil": 8969,
          "lfloor": 8970,
          "rfloor": 8971,
          "lang": 9001,
          "rang": 9002,
          "loz": 9674,
          "spades": 9824,
          "clubs": 9827,
          "hearts": 9829,
          "diams": 9830
        };
        Object.keys(sax.ENTITIES).forEach(function(key) {
          var e = sax.ENTITIES[key];
          var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
          sax.ENTITIES[key] = s2;
        });
        for (var s in sax.STATE) {
          sax.STATE[sax.STATE[s]] = s;
        }
        S = sax.STATE;
        function emit(parser, event, data) {
          parser[event] && parser[event](data);
        }
        function emitNode(parser, nodeType, data) {
          if (parser.textNode)
            closeText(parser);
          emit(parser, nodeType, data);
        }
        function closeText(parser) {
          parser.textNode = textopts(parser.opt, parser.textNode);
          if (parser.textNode)
            emit(parser, "ontext", parser.textNode);
          parser.textNode = "";
        }
        function textopts(opt, text) {
          if (opt.trim)
            text = text.trim();
          if (opt.normalize)
            text = text.replace(/\s+/g, " ");
          return text;
        }
        function error(parser, er) {
          closeText(parser);
          if (parser.trackPosition) {
            er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
          }
          er = new Error(er);
          parser.error = er;
          emit(parser, "onerror", er);
          return parser;
        }
        function end(parser) {
          if (parser.sawRoot && !parser.closedRoot)
            strictFail(parser, "Unclosed root tag");
          if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
            error(parser, "Unexpected end");
          }
          closeText(parser);
          parser.c = "";
          parser.closed = true;
          emit(parser, "onend");
          SAXParser.call(parser, parser.strict, parser.opt);
          return parser;
        }
        function strictFail(parser, message) {
          if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
            throw new Error("bad call to strictFail");
          }
          if (parser.strict) {
            error(parser, message);
          }
        }
        function newTag(parser) {
          if (!parser.strict)
            parser.tagName = parser.tagName[parser.looseCase]();
          var parent = parser.tags[parser.tags.length - 1] || parser;
          var tag = parser.tag = { name: parser.tagName, attributes: {} };
          if (parser.opt.xmlns) {
            tag.ns = parent.ns;
          }
          parser.attribList.length = 0;
          emitNode(parser, "onopentagstart", tag);
        }
        function qname(name, attribute) {
          var i = name.indexOf(":");
          var qualName = i < 0 ? ["", name] : name.split(":");
          var prefix = qualName[0];
          var local = qualName[1];
          if (attribute && name === "xmlns") {
            prefix = "xmlns";
            local = "";
          }
          return { prefix, local };
        }
        function attrib(parser) {
          if (!parser.strict) {
            parser.attribName = parser.attribName[parser.looseCase]();
          }
          if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
            parser.attribName = parser.attribValue = "";
            return;
          }
          if (parser.opt.xmlns) {
            var qn = qname(parser.attribName, true);
            var prefix = qn.prefix;
            var local = qn.local;
            if (prefix === "xmlns") {
              if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
                strictFail(
                  parser,
                  "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
                );
              } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
                strictFail(
                  parser,
                  "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
                );
              } else {
                var tag = parser.tag;
                var parent = parser.tags[parser.tags.length - 1] || parser;
                if (tag.ns === parent.ns) {
                  tag.ns = Object.create(parent.ns);
                }
                tag.ns[local] = parser.attribValue;
              }
            }
            parser.attribList.push([parser.attribName, parser.attribValue]);
          } else {
            parser.tag.attributes[parser.attribName] = parser.attribValue;
            emitNode(parser, "onattribute", {
              name: parser.attribName,
              value: parser.attribValue
            });
          }
          parser.attribName = parser.attribValue = "";
        }
        function openTag(parser, selfClosing) {
          if (parser.opt.xmlns) {
            var tag = parser.tag;
            var qn = qname(parser.tagName);
            tag.prefix = qn.prefix;
            tag.local = qn.local;
            tag.uri = tag.ns[qn.prefix] || "";
            if (tag.prefix && !tag.uri) {
              strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
              tag.uri = qn.prefix;
            }
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (tag.ns && parent.ns !== tag.ns) {
              Object.keys(tag.ns).forEach(function(p) {
                emitNode(parser, "onopennamespace", {
                  prefix: p,
                  uri: tag.ns[p]
                });
              });
            }
            for (var i = 0, l = parser.attribList.length; i < l; i++) {
              var nv = parser.attribList[i];
              var name = nv[0];
              var value = nv[1];
              var qualName = qname(name, true);
              var prefix = qualName.prefix;
              var local = qualName.local;
              var uri = prefix === "" ? "" : tag.ns[prefix] || "";
              var a = {
                name,
                value,
                prefix,
                local,
                uri
              };
              if (prefix && prefix !== "xmlns" && !uri) {
                strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
                a.uri = prefix;
              }
              parser.tag.attributes[name] = a;
              emitNode(parser, "onattribute", a);
            }
            parser.attribList.length = 0;
          }
          parser.tag.isSelfClosing = !!selfClosing;
          parser.sawRoot = true;
          parser.tags.push(parser.tag);
          emitNode(parser, "onopentag", parser.tag);
          if (!selfClosing) {
            if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
              parser.state = S.SCRIPT;
            } else {
              parser.state = S.TEXT;
            }
            parser.tag = null;
            parser.tagName = "";
          }
          parser.attribName = parser.attribValue = "";
          parser.attribList.length = 0;
        }
        function closeTag(parser) {
          if (!parser.tagName) {
            strictFail(parser, "Weird empty close tag.");
            parser.textNode += "</>";
            parser.state = S.TEXT;
            return;
          }
          if (parser.script) {
            if (parser.tagName !== "script") {
              parser.script += "</" + parser.tagName + ">";
              parser.tagName = "";
              parser.state = S.SCRIPT;
              return;
            }
            emitNode(parser, "onscript", parser.script);
            parser.script = "";
          }
          var t = parser.tags.length;
          var tagName = parser.tagName;
          if (!parser.strict) {
            tagName = tagName[parser.looseCase]();
          }
          var closeTo = tagName;
          while (t--) {
            var close = parser.tags[t];
            if (close.name !== closeTo) {
              strictFail(parser, "Unexpected close tag");
            } else {
              break;
            }
          }
          if (t < 0) {
            strictFail(parser, "Unmatched closing tag: " + parser.tagName);
            parser.textNode += "</" + parser.tagName + ">";
            parser.state = S.TEXT;
            return;
          }
          parser.tagName = tagName;
          var s2 = parser.tags.length;
          while (s2-- > t) {
            var tag = parser.tag = parser.tags.pop();
            parser.tagName = parser.tag.name;
            emitNode(parser, "onclosetag", parser.tagName);
            var x = {};
            for (var i in tag.ns) {
              x[i] = tag.ns[i];
            }
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (parser.opt.xmlns && tag.ns !== parent.ns) {
              Object.keys(tag.ns).forEach(function(p) {
                var n = tag.ns[p];
                emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
              });
            }
          }
          if (t === 0)
            parser.closedRoot = true;
          parser.tagName = parser.attribValue = parser.attribName = "";
          parser.attribList.length = 0;
          parser.state = S.TEXT;
        }
        function parseEntity(parser) {
          var entity = parser.entity;
          var entityLC = entity.toLowerCase();
          var num;
          var numStr = "";
          if (parser.ENTITIES[entity]) {
            return parser.ENTITIES[entity];
          }
          if (parser.ENTITIES[entityLC]) {
            return parser.ENTITIES[entityLC];
          }
          entity = entityLC;
          if (entity.charAt(0) === "#") {
            if (entity.charAt(1) === "x") {
              entity = entity.slice(2);
              num = parseInt(entity, 16);
              numStr = num.toString(16);
            } else {
              entity = entity.slice(1);
              num = parseInt(entity, 10);
              numStr = num.toString(10);
            }
          }
          entity = entity.replace(/^0+/, "");
          if (isNaN(num) || numStr.toLowerCase() !== entity) {
            strictFail(parser, "Invalid character entity");
            return "&" + parser.entity + ";";
          }
          return String.fromCodePoint(num);
        }
        function beginWhiteSpace(parser, c) {
          if (c === "<") {
            parser.state = S.OPEN_WAKA;
            parser.startTagPosition = parser.position;
          } else if (!isWhitespace(c)) {
            strictFail(parser, "Non-whitespace before first tag.");
            parser.textNode = c;
            parser.state = S.TEXT;
          }
        }
        function charAt(chunk, i) {
          var result = "";
          if (i < chunk.length) {
            result = chunk.charAt(i);
          }
          return result;
        }
        function write(chunk) {
          var parser = this;
          if (this.error) {
            throw this.error;
          }
          if (parser.closed) {
            return error(
              parser,
              "Cannot write after close. Assign an onready handler."
            );
          }
          if (chunk === null) {
            return end(parser);
          }
          if (typeof chunk === "object") {
            chunk = chunk.toString();
          }
          var i = 0;
          var c = "";
          while (true) {
            c = charAt(chunk, i++);
            parser.c = c;
            if (!c) {
              break;
            }
            if (parser.trackPosition) {
              parser.position++;
              if (c === "\n") {
                parser.line++;
                parser.column = 0;
              } else {
                parser.column++;
              }
            }
            switch (parser.state) {
              case S.BEGIN:
                parser.state = S.BEGIN_WHITESPACE;
                if (c === "\uFEFF") {
                  continue;
                }
                beginWhiteSpace(parser, c);
                continue;
              case S.BEGIN_WHITESPACE:
                beginWhiteSpace(parser, c);
                continue;
              case S.TEXT:
                if (parser.sawRoot && !parser.closedRoot) {
                  var starti = i - 1;
                  while (c && c !== "<" && c !== "&") {
                    c = charAt(chunk, i++);
                    if (c && parser.trackPosition) {
                      parser.position++;
                      if (c === "\n") {
                        parser.line++;
                        parser.column = 0;
                      } else {
                        parser.column++;
                      }
                    }
                  }
                  parser.textNode += chunk.substring(starti, i - 1);
                }
                if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                  parser.state = S.OPEN_WAKA;
                  parser.startTagPosition = parser.position;
                } else {
                  if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                    strictFail(parser, "Text data outside of root node.");
                  }
                  if (c === "&") {
                    parser.state = S.TEXT_ENTITY;
                  } else {
                    parser.textNode += c;
                  }
                }
                continue;
              case S.SCRIPT:
                if (c === "<") {
                  parser.state = S.SCRIPT_ENDING;
                } else {
                  parser.script += c;
                }
                continue;
              case S.SCRIPT_ENDING:
                if (c === "/") {
                  parser.state = S.CLOSE_TAG;
                } else {
                  parser.script += "<" + c;
                  parser.state = S.SCRIPT;
                }
                continue;
              case S.OPEN_WAKA:
                if (c === "!") {
                  parser.state = S.SGML_DECL;
                  parser.sgmlDecl = "";
                } else if (isWhitespace(c)) {
                } else if (isMatch(nameStart, c)) {
                  parser.state = S.OPEN_TAG;
                  parser.tagName = c;
                } else if (c === "/") {
                  parser.state = S.CLOSE_TAG;
                  parser.tagName = "";
                } else if (c === "?") {
                  parser.state = S.PROC_INST;
                  parser.procInstName = parser.procInstBody = "";
                } else {
                  strictFail(parser, "Unencoded <");
                  if (parser.startTagPosition + 1 < parser.position) {
                    var pad = parser.position - parser.startTagPosition;
                    c = new Array(pad).join(" ") + c;
                  }
                  parser.textNode += "<" + c;
                  parser.state = S.TEXT;
                }
                continue;
              case S.SGML_DECL:
                if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                  emitNode(parser, "onopencdata");
                  parser.state = S.CDATA;
                  parser.sgmlDecl = "";
                  parser.cdata = "";
                } else if (parser.sgmlDecl + c === "--") {
                  parser.state = S.COMMENT;
                  parser.comment = "";
                  parser.sgmlDecl = "";
                } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                  parser.state = S.DOCTYPE;
                  if (parser.doctype || parser.sawRoot) {
                    strictFail(
                      parser,
                      "Inappropriately located doctype declaration"
                    );
                  }
                  parser.doctype = "";
                  parser.sgmlDecl = "";
                } else if (c === ">") {
                  emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                  parser.sgmlDecl = "";
                  parser.state = S.TEXT;
                } else if (isQuote(c)) {
                  parser.state = S.SGML_DECL_QUOTED;
                  parser.sgmlDecl += c;
                } else {
                  parser.sgmlDecl += c;
                }
                continue;
              case S.SGML_DECL_QUOTED:
                if (c === parser.q) {
                  parser.state = S.SGML_DECL;
                  parser.q = "";
                }
                parser.sgmlDecl += c;
                continue;
              case S.DOCTYPE:
                if (c === ">") {
                  parser.state = S.TEXT;
                  emitNode(parser, "ondoctype", parser.doctype);
                  parser.doctype = true;
                } else {
                  parser.doctype += c;
                  if (c === "[") {
                    parser.state = S.DOCTYPE_DTD;
                  } else if (isQuote(c)) {
                    parser.state = S.DOCTYPE_QUOTED;
                    parser.q = c;
                  }
                }
                continue;
              case S.DOCTYPE_QUOTED:
                parser.doctype += c;
                if (c === parser.q) {
                  parser.q = "";
                  parser.state = S.DOCTYPE;
                }
                continue;
              case S.DOCTYPE_DTD:
                parser.doctype += c;
                if (c === "]") {
                  parser.state = S.DOCTYPE;
                } else if (isQuote(c)) {
                  parser.state = S.DOCTYPE_DTD_QUOTED;
                  parser.q = c;
                }
                continue;
              case S.DOCTYPE_DTD_QUOTED:
                parser.doctype += c;
                if (c === parser.q) {
                  parser.state = S.DOCTYPE_DTD;
                  parser.q = "";
                }
                continue;
              case S.COMMENT:
                if (c === "-") {
                  parser.state = S.COMMENT_ENDING;
                } else {
                  parser.comment += c;
                }
                continue;
              case S.COMMENT_ENDING:
                if (c === "-") {
                  parser.state = S.COMMENT_ENDED;
                  parser.comment = textopts(parser.opt, parser.comment);
                  if (parser.comment) {
                    emitNode(parser, "oncomment", parser.comment);
                  }
                  parser.comment = "";
                } else {
                  parser.comment += "-" + c;
                  parser.state = S.COMMENT;
                }
                continue;
              case S.COMMENT_ENDED:
                if (c !== ">") {
                  strictFail(parser, "Malformed comment");
                  parser.comment += "--" + c;
                  parser.state = S.COMMENT;
                } else {
                  parser.state = S.TEXT;
                }
                continue;
              case S.CDATA:
                if (c === "]") {
                  parser.state = S.CDATA_ENDING;
                } else {
                  parser.cdata += c;
                }
                continue;
              case S.CDATA_ENDING:
                if (c === "]") {
                  parser.state = S.CDATA_ENDING_2;
                } else {
                  parser.cdata += "]" + c;
                  parser.state = S.CDATA;
                }
                continue;
              case S.CDATA_ENDING_2:
                if (c === ">") {
                  if (parser.cdata) {
                    emitNode(parser, "oncdata", parser.cdata);
                  }
                  emitNode(parser, "onclosecdata");
                  parser.cdata = "";
                  parser.state = S.TEXT;
                } else if (c === "]") {
                  parser.cdata += "]";
                } else {
                  parser.cdata += "]]" + c;
                  parser.state = S.CDATA;
                }
                continue;
              case S.PROC_INST:
                if (c === "?") {
                  parser.state = S.PROC_INST_ENDING;
                } else if (isWhitespace(c)) {
                  parser.state = S.PROC_INST_BODY;
                } else {
                  parser.procInstName += c;
                }
                continue;
              case S.PROC_INST_BODY:
                if (!parser.procInstBody && isWhitespace(c)) {
                  continue;
                } else if (c === "?") {
                  parser.state = S.PROC_INST_ENDING;
                } else {
                  parser.procInstBody += c;
                }
                continue;
              case S.PROC_INST_ENDING:
                if (c === ">") {
                  emitNode(parser, "onprocessinginstruction", {
                    name: parser.procInstName,
                    body: parser.procInstBody
                  });
                  parser.procInstName = parser.procInstBody = "";
                  parser.state = S.TEXT;
                } else {
                  parser.procInstBody += "?" + c;
                  parser.state = S.PROC_INST_BODY;
                }
                continue;
              case S.OPEN_TAG:
                if (isMatch(nameBody, c)) {
                  parser.tagName += c;
                } else {
                  newTag(parser);
                  if (c === ">") {
                    openTag(parser);
                  } else if (c === "/") {
                    parser.state = S.OPEN_TAG_SLASH;
                  } else {
                    if (!isWhitespace(c)) {
                      strictFail(parser, "Invalid character in tag name");
                    }
                    parser.state = S.ATTRIB;
                  }
                }
                continue;
              case S.OPEN_TAG_SLASH:
                if (c === ">") {
                  openTag(parser, true);
                  closeTag(parser);
                } else {
                  strictFail(parser, "Forward-slash in opening tag not followed by >");
                  parser.state = S.ATTRIB;
                }
                continue;
              case S.ATTRIB:
                if (isWhitespace(c)) {
                  continue;
                } else if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S.OPEN_TAG_SLASH;
                } else if (isMatch(nameStart, c)) {
                  parser.attribName = c;
                  parser.attribValue = "";
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                }
                continue;
              case S.ATTRIB_NAME:
                if (c === "=") {
                  parser.state = S.ATTRIB_VALUE;
                } else if (c === ">") {
                  strictFail(parser, "Attribute without value");
                  parser.attribValue = parser.attribName;
                  attrib(parser);
                  openTag(parser);
                } else if (isWhitespace(c)) {
                  parser.state = S.ATTRIB_NAME_SAW_WHITE;
                } else if (isMatch(nameBody, c)) {
                  parser.attribName += c;
                } else {
                  strictFail(parser, "Invalid attribute name");
                }
                continue;
              case S.ATTRIB_NAME_SAW_WHITE:
                if (c === "=") {
                  parser.state = S.ATTRIB_VALUE;
                } else if (isWhitespace(c)) {
                  continue;
                } else {
                  strictFail(parser, "Attribute without value");
                  parser.tag.attributes[parser.attribName] = "";
                  parser.attribValue = "";
                  emitNode(parser, "onattribute", {
                    name: parser.attribName,
                    value: ""
                  });
                  parser.attribName = "";
                  if (c === ">") {
                    openTag(parser);
                  } else if (isMatch(nameStart, c)) {
                    parser.attribName = c;
                    parser.state = S.ATTRIB_NAME;
                  } else {
                    strictFail(parser, "Invalid attribute name");
                    parser.state = S.ATTRIB;
                  }
                }
                continue;
              case S.ATTRIB_VALUE:
                if (isWhitespace(c)) {
                  continue;
                } else if (isQuote(c)) {
                  parser.q = c;
                  parser.state = S.ATTRIB_VALUE_QUOTED;
                } else {
                  strictFail(parser, "Unquoted attribute value");
                  parser.state = S.ATTRIB_VALUE_UNQUOTED;
                  parser.attribValue = c;
                }
                continue;
              case S.ATTRIB_VALUE_QUOTED:
                if (c !== parser.q) {
                  if (c === "&") {
                    parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                  } else {
                    parser.attribValue += c;
                  }
                  continue;
                }
                attrib(parser);
                parser.q = "";
                parser.state = S.ATTRIB_VALUE_CLOSED;
                continue;
              case S.ATTRIB_VALUE_CLOSED:
                if (isWhitespace(c)) {
                  parser.state = S.ATTRIB;
                } else if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S.OPEN_TAG_SLASH;
                } else if (isMatch(nameStart, c)) {
                  strictFail(parser, "No whitespace between attributes");
                  parser.attribName = c;
                  parser.attribValue = "";
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                }
                continue;
              case S.ATTRIB_VALUE_UNQUOTED:
                if (!isAttribEnd(c)) {
                  if (c === "&") {
                    parser.state = S.ATTRIB_VALUE_ENTITY_U;
                  } else {
                    parser.attribValue += c;
                  }
                  continue;
                }
                attrib(parser);
                if (c === ">") {
                  openTag(parser);
                } else {
                  parser.state = S.ATTRIB;
                }
                continue;
              case S.CLOSE_TAG:
                if (!parser.tagName) {
                  if (isWhitespace(c)) {
                    continue;
                  } else if (notMatch(nameStart, c)) {
                    if (parser.script) {
                      parser.script += "</" + c;
                      parser.state = S.SCRIPT;
                    } else {
                      strictFail(parser, "Invalid tagname in closing tag.");
                    }
                  } else {
                    parser.tagName = c;
                  }
                } else if (c === ">") {
                  closeTag(parser);
                } else if (isMatch(nameBody, c)) {
                  parser.tagName += c;
                } else if (parser.script) {
                  parser.script += "</" + parser.tagName;
                  parser.tagName = "";
                  parser.state = S.SCRIPT;
                } else {
                  if (!isWhitespace(c)) {
                    strictFail(parser, "Invalid tagname in closing tag");
                  }
                  parser.state = S.CLOSE_TAG_SAW_WHITE;
                }
                continue;
              case S.CLOSE_TAG_SAW_WHITE:
                if (isWhitespace(c)) {
                  continue;
                }
                if (c === ">") {
                  closeTag(parser);
                } else {
                  strictFail(parser, "Invalid characters in closing tag");
                }
                continue;
              case S.TEXT_ENTITY:
              case S.ATTRIB_VALUE_ENTITY_Q:
              case S.ATTRIB_VALUE_ENTITY_U:
                var returnState;
                var buffer;
                switch (parser.state) {
                  case S.TEXT_ENTITY:
                    returnState = S.TEXT;
                    buffer = "textNode";
                    break;
                  case S.ATTRIB_VALUE_ENTITY_Q:
                    returnState = S.ATTRIB_VALUE_QUOTED;
                    buffer = "attribValue";
                    break;
                  case S.ATTRIB_VALUE_ENTITY_U:
                    returnState = S.ATTRIB_VALUE_UNQUOTED;
                    buffer = "attribValue";
                    break;
                }
                if (c === ";") {
                  parser[buffer] += parseEntity(parser);
                  parser.entity = "";
                  parser.state = returnState;
                } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                  parser.entity += c;
                } else {
                  strictFail(parser, "Invalid character in entity name");
                  parser[buffer] += "&" + parser.entity + c;
                  parser.entity = "";
                  parser.state = returnState;
                }
                continue;
              default:
                throw new Error(parser, "Unknown state: " + parser.state);
            }
          }
          if (parser.position >= parser.bufferCheckPosition) {
            checkBufferLength(parser);
          }
          return parser;
        }
        if (!String.fromCodePoint) {
          (function() {
            var stringFromCharCode = String.fromCharCode;
            var floor = Math.floor;
            var fromCodePoint = function() {
              var MAX_SIZE = 16384;
              var codeUnits = [];
              var highSurrogate;
              var lowSurrogate;
              var index = -1;
              var length = arguments.length;
              if (!length) {
                return "";
              }
              var result = "";
              while (++index < length) {
                var codePoint = Number(arguments[index]);
                if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
                codePoint < 0 || // not a valid Unicode code point
                codePoint > 1114111 || // not a valid Unicode code point
                floor(codePoint) !== codePoint) {
                  throw RangeError("Invalid code point: " + codePoint);
                }
                if (codePoint <= 65535) {
                  codeUnits.push(codePoint);
                } else {
                  codePoint -= 65536;
                  highSurrogate = (codePoint >> 10) + 55296;
                  lowSurrogate = codePoint % 1024 + 56320;
                  codeUnits.push(highSurrogate, lowSurrogate);
                }
                if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                  result += stringFromCharCode.apply(null, codeUnits);
                  codeUnits.length = 0;
                }
              }
              return result;
            };
            if (Object.defineProperty) {
              Object.defineProperty(String, "fromCodePoint", {
                value: fromCodePoint,
                configurable: true,
                writable: true
              });
            } else {
              String.fromCodePoint = fromCodePoint;
            }
          })();
        }
      })(typeof exports === "undefined" ? exports.sax = {} : exports);
    }
  });

  // node_modules/events/events.js
  var require_events = __commonJS({
    "node_modules/events/events.js"(exports, module) {
      "use strict";
      var R = typeof Reflect === "object" ? Reflect : null;
      var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
        return Function.prototype.apply.call(target, receiver, args);
      };
      var ReflectOwnKeys;
      if (R && typeof R.ownKeys === "function") {
        ReflectOwnKeys = R.ownKeys;
      } else if (Object.getOwnPropertySymbols) {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
        };
      } else {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target);
        };
      }
      function ProcessEmitWarning(warning) {
        if (console && console.warn)
          console.warn(warning);
      }
      var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
        return value !== value;
      };
      function EventEmitter() {
        EventEmitter.init.call(this);
      }
      module.exports = EventEmitter;
      module.exports.once = once;
      EventEmitter.EventEmitter = EventEmitter;
      EventEmitter.prototype._events = void 0;
      EventEmitter.prototype._eventsCount = 0;
      EventEmitter.prototype._maxListeners = void 0;
      var defaultMaxListeners = 10;
      function checkListener(listener) {
        if (typeof listener !== "function") {
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
        }
      }
      Object.defineProperty(EventEmitter, "defaultMaxListeners", {
        enumerable: true,
        get: function() {
          return defaultMaxListeners;
        },
        set: function(arg) {
          if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
          }
          defaultMaxListeners = arg;
        }
      });
      EventEmitter.init = function() {
        if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || void 0;
      };
      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
        if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
        }
        this._maxListeners = n;
        return this;
      };
      function _getMaxListeners(that) {
        if (that._maxListeners === void 0)
          return EventEmitter.defaultMaxListeners;
        return that._maxListeners;
      }
      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
        return _getMaxListeners(this);
      };
      EventEmitter.prototype.emit = function emit(type) {
        var args = [];
        for (var i = 1; i < arguments.length; i++)
          args.push(arguments[i]);
        var doError = type === "error";
        var events = this._events;
        if (events !== void 0)
          doError = doError && events.error === void 0;
        else if (!doError)
          return false;
        if (doError) {
          var er;
          if (args.length > 0)
            er = args[0];
          if (er instanceof Error) {
            throw er;
          }
          var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
          err.context = er;
          throw err;
        }
        var handler = events[type];
        if (handler === void 0)
          return false;
        if (typeof handler === "function") {
          ReflectApply(handler, this, args);
        } else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            ReflectApply(listeners[i], this, args);
        }
        return true;
      };
      function _addListener(target, type, listener, prepend) {
        var m;
        var events;
        var existing;
        checkListener(listener);
        events = target._events;
        if (events === void 0) {
          events = target._events = /* @__PURE__ */ Object.create(null);
          target._eventsCount = 0;
        } else {
          if (events.newListener !== void 0) {
            target.emit(
              "newListener",
              type,
              listener.listener ? listener.listener : listener
            );
            events = target._events;
          }
          existing = events[type];
        }
        if (existing === void 0) {
          existing = events[type] = listener;
          ++target._eventsCount;
        } else {
          if (typeof existing === "function") {
            existing = events[type] = prepend ? [listener, existing] : [existing, listener];
          } else if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }
          m = _getMaxListeners(target);
          if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            ProcessEmitWarning(w);
          }
        }
        return target;
      }
      EventEmitter.prototype.addListener = function addListener(type, listener) {
        return _addListener(this, type, listener, false);
      };
      EventEmitter.prototype.on = EventEmitter.prototype.addListener;
      EventEmitter.prototype.prependListener = function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };
      function onceWrapper() {
        if (!this.fired) {
          this.target.removeListener(this.type, this.wrapFn);
          this.fired = true;
          if (arguments.length === 0)
            return this.listener.call(this.target);
          return this.listener.apply(this.target, arguments);
        }
      }
      function _onceWrap(target, type, listener) {
        var state = { fired: false, wrapFn: void 0, target, type, listener };
        var wrapped = onceWrapper.bind(state);
        wrapped.listener = listener;
        state.wrapFn = wrapped;
        return wrapped;
      }
      EventEmitter.prototype.once = function once2(type, listener) {
        checkListener(listener);
        this.on(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
        checkListener(listener);
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.removeListener = function removeListener(type, listener) {
        var list, events, position, i, originalListener;
        checkListener(listener);
        events = this._events;
        if (events === void 0)
          return this;
        list = events[type];
        if (list === void 0)
          return this;
        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else {
            delete events[type];
            if (events.removeListener)
              this.emit("removeListener", type, list.listener || listener);
          }
        } else if (typeof list !== "function") {
          position = -1;
          for (i = list.length - 1; i >= 0; i--) {
            if (list[i] === listener || list[i].listener === listener) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }
          if (position < 0)
            return this;
          if (position === 0)
            list.shift();
          else {
            spliceOne(list, position);
          }
          if (list.length === 1)
            events[type] = list[0];
          if (events.removeListener !== void 0)
            this.emit("removeListener", type, originalListener || listener);
        }
        return this;
      };
      EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
      EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
        var listeners, events, i;
        events = this._events;
        if (events === void 0)
          return this;
        if (events.removeListener === void 0) {
          if (arguments.length === 0) {
            this._events = /* @__PURE__ */ Object.create(null);
            this._eventsCount = 0;
          } else if (events[type] !== void 0) {
            if (--this._eventsCount === 0)
              this._events = /* @__PURE__ */ Object.create(null);
            else
              delete events[type];
          }
          return this;
        }
        if (arguments.length === 0) {
          var keys = Object.keys(events);
          var key;
          for (i = 0; i < keys.length; ++i) {
            key = keys[i];
            if (key === "removeListener")
              continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners("removeListener");
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
          return this;
        }
        listeners = events[type];
        if (typeof listeners === "function") {
          this.removeListener(type, listeners);
        } else if (listeners !== void 0) {
          for (i = listeners.length - 1; i >= 0; i--) {
            this.removeListener(type, listeners[i]);
          }
        }
        return this;
      };
      function _listeners(target, type, unwrap) {
        var events = target._events;
        if (events === void 0)
          return [];
        var evlistener = events[type];
        if (evlistener === void 0)
          return [];
        if (typeof evlistener === "function")
          return unwrap ? [evlistener.listener || evlistener] : [evlistener];
        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
      }
      EventEmitter.prototype.listeners = function listeners(type) {
        return _listeners(this, type, true);
      };
      EventEmitter.prototype.rawListeners = function rawListeners(type) {
        return _listeners(this, type, false);
      };
      EventEmitter.listenerCount = function(emitter, type) {
        if (typeof emitter.listenerCount === "function") {
          return emitter.listenerCount(type);
        } else {
          return listenerCount.call(emitter, type);
        }
      };
      EventEmitter.prototype.listenerCount = listenerCount;
      function listenerCount(type) {
        var events = this._events;
        if (events !== void 0) {
          var evlistener = events[type];
          if (typeof evlistener === "function") {
            return 1;
          } else if (evlistener !== void 0) {
            return evlistener.length;
          }
        }
        return 0;
      }
      EventEmitter.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
      };
      function arrayClone(arr, n) {
        var copy = new Array(n);
        for (var i = 0; i < n; ++i)
          copy[i] = arr[i];
        return copy;
      }
      function spliceOne(list, index) {
        for (; index + 1 < list.length; index++)
          list[index] = list[index + 1];
        list.pop();
      }
      function unwrapListeners(arr) {
        var ret = new Array(arr.length);
        for (var i = 0; i < ret.length; ++i) {
          ret[i] = arr[i].listener || arr[i];
        }
        return ret;
      }
      function once(emitter, name) {
        return new Promise(function(resolve, reject) {
          function errorListener(err) {
            emitter.removeListener(name, resolver);
            reject(err);
          }
          function resolver() {
            if (typeof emitter.removeListener === "function") {
              emitter.removeListener("error", errorListener);
            }
            resolve([].slice.call(arguments));
          }
          ;
          eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
          if (name !== "error") {
            addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
          }
        });
      }
      function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
        if (typeof emitter.on === "function") {
          eventTargetAgnosticAddListener(emitter, "error", handler, flags);
        }
      }
      function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
        if (typeof emitter.on === "function") {
          if (flags.once) {
            emitter.once(name, listener);
          } else {
            emitter.on(name, listener);
          }
        } else if (typeof emitter.addEventListener === "function") {
          emitter.addEventListener(name, function wrapListener(arg) {
            if (flags.once) {
              emitter.removeEventListener(name, wrapListener);
            }
            listener(arg);
          });
        } else {
          throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
        }
      }
    }
  });

  // node_modules/xml2js/lib/bom.js
  var require_bom = __commonJS({
    "node_modules/xml2js/lib/bom.js"(exports) {
      (function() {
        "use strict";
        exports.stripBOM = function(str) {
          if (str[0] === "\uFEFF") {
            return str.substring(1);
          } else {
            return str;
          }
        };
      }).call(exports);
    }
  });

  // node_modules/xml2js/lib/processors.js
  var require_processors = __commonJS({
    "node_modules/xml2js/lib/processors.js"(exports) {
      (function() {
        "use strict";
        var prefixMatch;
        prefixMatch = new RegExp(/(?!xmlns)^.*:/);
        exports.normalize = function(str) {
          return str.toLowerCase();
        };
        exports.firstCharLowerCase = function(str) {
          return str.charAt(0).toLowerCase() + str.slice(1);
        };
        exports.stripPrefix = function(str) {
          return str.replace(prefixMatch, "");
        };
        exports.parseNumbers = function(str) {
          if (!isNaN(str)) {
            str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
          }
          return str;
        };
        exports.parseBooleans = function(str) {
          if (/^(?:true|false)$/i.test(str)) {
            str = str.toLowerCase() === "true";
          }
          return str;
        };
      }).call(exports);
    }
  });

  // node_modules/timers/index.js
  var require_timers = __commonJS({
    "node_modules/timers/index.js"(exports) {
      exports.every = function(str) {
        return new Every(str);
      };
      var time = {
        millisecond: 1,
        second: 1e3,
        minute: 6e4,
        hour: 36e5,
        day: 864e5
      };
      for (key in time) {
        if (key === "millisecond") {
          time.ms = time[key];
        } else {
          time[key.charAt(0)] = time[key];
        }
        time[key + "s"] = time[key];
      }
      var key;
      function Every(str) {
        this.count = 0;
        var m = parse(str);
        if (m) {
          this.time = Number(m[0]) * time[m[1]];
          this.type = m[1];
        }
      }
      Every.prototype.do = function(cb) {
        if (this.time) {
          this.interval = setInterval(callback, this.time);
        }
        var that = this;
        function callback() {
          that.count++;
          cb.call(that);
        }
        return this;
      };
      Every.prototype.stop = function() {
        if (this.interval) {
          clearInterval(this.interval);
          delete this.interval;
        }
        return this;
      };
      var reg = /^\s*(\d+(?:\.\d+)?)\s*([a-z]+)\s*$/;
      function parse(str) {
        var m = str.match(reg);
        if (m && time[m[2]]) {
          return m.slice(1);
        }
        return null;
      }
    }
  });

  // node_modules/xml2js/lib/parser.js
  var require_parser = __commonJS({
    "node_modules/xml2js/lib/parser.js"(exports) {
      (function() {
        "use strict";
        var bom, defaults, events, isEmpty, processItem, processors, sax, setImmediate, bind = function(fn, me) {
          return function() {
            return fn.apply(me, arguments);
          };
        }, extend = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        sax = require_sax();
        events = require_events();
        bom = require_bom();
        processors = require_processors();
        setImmediate = require_timers().setImmediate;
        defaults = require_defaults().defaults;
        isEmpty = function(thing) {
          return typeof thing === "object" && thing != null && Object.keys(thing).length === 0;
        };
        processItem = function(processors2, item, key) {
          var i, len, process;
          for (i = 0, len = processors2.length; i < len; i++) {
            process = processors2[i];
            item = process(item, key);
          }
          return item;
        };
        exports.Parser = function(superClass) {
          extend(Parser, superClass);
          function Parser(opts) {
            this.parseStringPromise = bind(this.parseStringPromise, this);
            this.parseString = bind(this.parseString, this);
            this.reset = bind(this.reset, this);
            this.assignOrPush = bind(this.assignOrPush, this);
            this.processAsync = bind(this.processAsync, this);
            var key, ref, value;
            if (!(this instanceof exports.Parser)) {
              return new exports.Parser(opts);
            }
            this.options = {};
            ref = defaults["0.2"];
            for (key in ref) {
              if (!hasProp.call(ref, key))
                continue;
              value = ref[key];
              this.options[key] = value;
            }
            for (key in opts) {
              if (!hasProp.call(opts, key))
                continue;
              value = opts[key];
              this.options[key] = value;
            }
            if (this.options.xmlns) {
              this.options.xmlnskey = this.options.attrkey + "ns";
            }
            if (this.options.normalizeTags) {
              if (!this.options.tagNameProcessors) {
                this.options.tagNameProcessors = [];
              }
              this.options.tagNameProcessors.unshift(processors.normalize);
            }
            this.reset();
          }
          Parser.prototype.processAsync = function() {
            var chunk, err;
            try {
              if (this.remaining.length <= this.options.chunkSize) {
                chunk = this.remaining;
                this.remaining = "";
                this.saxParser = this.saxParser.write(chunk);
                return this.saxParser.close();
              } else {
                chunk = this.remaining.substr(0, this.options.chunkSize);
                this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
                this.saxParser = this.saxParser.write(chunk);
                return setImmediate(this.processAsync);
              }
            } catch (error1) {
              err = error1;
              if (!this.saxParser.errThrown) {
                this.saxParser.errThrown = true;
                return this.emit(err);
              }
            }
          };
          Parser.prototype.assignOrPush = function(obj, key, newValue) {
            if (!(key in obj)) {
              if (!this.options.explicitArray) {
                return obj[key] = newValue;
              } else {
                return obj[key] = [newValue];
              }
            } else {
              if (!(obj[key] instanceof Array)) {
                obj[key] = [obj[key]];
              }
              return obj[key].push(newValue);
            }
          };
          Parser.prototype.reset = function() {
            var attrkey, charkey, ontext, stack;
            this.removeAllListeners();
            this.saxParser = sax.parser(this.options.strict, {
              trim: false,
              normalize: false,
              xmlns: this.options.xmlns
            });
            this.saxParser.errThrown = false;
            this.saxParser.onerror = function(_this) {
              return function(error) {
                _this.saxParser.resume();
                if (!_this.saxParser.errThrown) {
                  _this.saxParser.errThrown = true;
                  return _this.emit("error", error);
                }
              };
            }(this);
            this.saxParser.onend = function(_this) {
              return function() {
                if (!_this.saxParser.ended) {
                  _this.saxParser.ended = true;
                  return _this.emit("end", _this.resultObject);
                }
              };
            }(this);
            this.saxParser.ended = false;
            this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
            this.resultObject = null;
            stack = [];
            attrkey = this.options.attrkey;
            charkey = this.options.charkey;
            this.saxParser.onopentag = function(_this) {
              return function(node) {
                var key, newValue, obj, processedKey, ref;
                obj = {};
                obj[charkey] = "";
                if (!_this.options.ignoreAttrs) {
                  ref = node.attributes;
                  for (key in ref) {
                    if (!hasProp.call(ref, key))
                      continue;
                    if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                      obj[attrkey] = {};
                    }
                    newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];
                    processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;
                    if (_this.options.mergeAttrs) {
                      _this.assignOrPush(obj, processedKey, newValue);
                    } else {
                      obj[attrkey][processedKey] = newValue;
                    }
                  }
                }
                obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;
                if (_this.options.xmlns) {
                  obj[_this.options.xmlnskey] = {
                    uri: node.uri,
                    local: node.local
                  };
                }
                return stack.push(obj);
              };
            }(this);
            this.saxParser.onclosetag = function(_this) {
              return function() {
                var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;
                obj = stack.pop();
                nodeName = obj["#name"];
                if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
                  delete obj["#name"];
                }
                if (obj.cdata === true) {
                  cdata = obj.cdata;
                  delete obj.cdata;
                }
                s = stack[stack.length - 1];
                if (obj[charkey].match(/^\s*$/) && !cdata) {
                  emptyStr = obj[charkey];
                  delete obj[charkey];
                } else {
                  if (_this.options.trim) {
                    obj[charkey] = obj[charkey].trim();
                  }
                  if (_this.options.normalize) {
                    obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
                  }
                  obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
                  if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                    obj = obj[charkey];
                  }
                }
                if (isEmpty(obj)) {
                  obj = _this.options.emptyTag !== "" ? _this.options.emptyTag : emptyStr;
                }
                if (_this.options.validator != null) {
                  xpath = "/" + function() {
                    var i, len, results;
                    results = [];
                    for (i = 0, len = stack.length; i < len; i++) {
                      node = stack[i];
                      results.push(node["#name"]);
                    }
                    return results;
                  }().concat(nodeName).join("/");
                  (function() {
                    var err;
                    try {
                      return obj = _this.options.validator(xpath, s && s[nodeName], obj);
                    } catch (error1) {
                      err = error1;
                      return _this.emit("error", err);
                    }
                  })();
                }
                if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === "object") {
                  if (!_this.options.preserveChildrenOrder) {
                    node = {};
                    if (_this.options.attrkey in obj) {
                      node[_this.options.attrkey] = obj[_this.options.attrkey];
                      delete obj[_this.options.attrkey];
                    }
                    if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                      node[_this.options.charkey] = obj[_this.options.charkey];
                      delete obj[_this.options.charkey];
                    }
                    if (Object.getOwnPropertyNames(obj).length > 0) {
                      node[_this.options.childkey] = obj;
                    }
                    obj = node;
                  } else if (s) {
                    s[_this.options.childkey] = s[_this.options.childkey] || [];
                    objClone = {};
                    for (key in obj) {
                      if (!hasProp.call(obj, key))
                        continue;
                      objClone[key] = obj[key];
                    }
                    s[_this.options.childkey].push(objClone);
                    delete obj["#name"];
                    if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                      obj = obj[charkey];
                    }
                  }
                }
                if (stack.length > 0) {
                  return _this.assignOrPush(s, nodeName, obj);
                } else {
                  if (_this.options.explicitRoot) {
                    old = obj;
                    obj = {};
                    obj[nodeName] = old;
                  }
                  _this.resultObject = obj;
                  _this.saxParser.ended = true;
                  return _this.emit("end", _this.resultObject);
                }
              };
            }(this);
            ontext = function(_this) {
              return function(text) {
                var charChild, s;
                s = stack[stack.length - 1];
                if (s) {
                  s[charkey] += text;
                  if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\n/g, "").trim() !== "")) {
                    s[_this.options.childkey] = s[_this.options.childkey] || [];
                    charChild = {
                      "#name": "__text__"
                    };
                    charChild[charkey] = text;
                    if (_this.options.normalize) {
                      charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
                    }
                    s[_this.options.childkey].push(charChild);
                  }
                  return s;
                }
              };
            }(this);
            this.saxParser.ontext = ontext;
            return this.saxParser.oncdata = function(_this) {
              return function(text) {
                var s;
                s = ontext(text);
                if (s) {
                  return s.cdata = true;
                }
              };
            }(this);
          };
          Parser.prototype.parseString = function(str, cb) {
            var err;
            if (cb != null && typeof cb === "function") {
              this.on("end", function(result) {
                this.reset();
                return cb(null, result);
              });
              this.on("error", function(err2) {
                this.reset();
                return cb(err2);
              });
            }
            try {
              str = str.toString();
              if (str.trim() === "") {
                this.emit("end", null);
                return true;
              }
              str = bom.stripBOM(str);
              if (this.options.async) {
                this.remaining = str;
                setImmediate(this.processAsync);
                return this.saxParser;
              }
              return this.saxParser.write(str).close();
            } catch (error1) {
              err = error1;
              if (!(this.saxParser.errThrown || this.saxParser.ended)) {
                this.emit("error", err);
                return this.saxParser.errThrown = true;
              } else if (this.saxParser.ended) {
                throw err;
              }
            }
          };
          Parser.prototype.parseStringPromise = function(str) {
            return new Promise(function(_this) {
              return function(resolve, reject) {
                return _this.parseString(str, function(err, value) {
                  if (err) {
                    return reject(err);
                  } else {
                    return resolve(value);
                  }
                });
              };
            }(this));
          };
          return Parser;
        }(events);
        exports.parseString = function(str, a, b) {
          var cb, options, parser;
          if (b != null) {
            if (typeof b === "function") {
              cb = b;
            }
            if (typeof a === "object") {
              options = a;
            }
          } else {
            if (typeof a === "function") {
              cb = a;
            }
            options = {};
          }
          parser = new exports.Parser(options);
          return parser.parseString(str, cb);
        };
        exports.parseStringPromise = function(str, a) {
          var options, parser;
          if (typeof a === "object") {
            options = a;
          }
          parser = new exports.Parser(options);
          return parser.parseStringPromise(str);
        };
      }).call(exports);
    }
  });

  // node_modules/xml2js/lib/xml2js.js
  var require_xml2js = __commonJS({
    "node_modules/xml2js/lib/xml2js.js"(exports) {
      (function() {
        "use strict";
        var builder, defaults, parser, processors, extend = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        defaults = require_defaults();
        builder = require_builder();
        parser = require_parser();
        processors = require_processors();
        exports.defaults = defaults.defaults;
        exports.processors = processors;
        exports.ValidationError = function(superClass) {
          extend(ValidationError, superClass);
          function ValidationError(message) {
            this.message = message;
          }
          return ValidationError;
        }(Error);
        exports.Builder = builder.Builder;
        exports.Parser = parser.Parser;
        exports.parseString = parser.parseString;
        exports.parseStringPromise = parser.parseStringPromise;
      }).call(exports);
    }
  });

  // (disabled):crypto
  var require_crypto = __commonJS({
    "(disabled):crypto"() {
    }
  });

  // ../zotero-style/node_modules/crypto-js/core.js
  var require_core = __commonJS({
    "../zotero-style/node_modules/crypto-js/core.js"(exports, module) {
      (function(root, factory) {
        if (typeof exports === "object") {
          module.exports = exports = factory();
        } else if (typeof define === "function" && define.amd) {
          define([], factory);
        } else {
          root.CryptoJS = factory();
        }
      })(exports, function() {
        var CryptoJS = CryptoJS || function(Math2, undefined2) {
          var crypto;
          if (typeof window !== "undefined" && window.crypto) {
            crypto = window.crypto;
          }
          if (typeof self !== "undefined" && self.crypto) {
            crypto = self.crypto;
          }
          if (typeof globalThis !== "undefined" && globalThis.crypto) {
            crypto = globalThis.crypto;
          }
          if (!crypto && typeof window !== "undefined" && window.msCrypto) {
            crypto = window.msCrypto;
          }
          if (!crypto && typeof global !== "undefined" && global.crypto) {
            crypto = global.crypto;
          }
          if (!crypto && typeof __require === "function") {
            try {
              crypto = require_crypto();
            } catch (err) {
            }
          }
          var cryptoSecureRandomInt = function() {
            if (crypto) {
              if (typeof crypto.getRandomValues === "function") {
                try {
                  return crypto.getRandomValues(new Uint32Array(1))[0];
                } catch (err) {
                }
              }
              if (typeof crypto.randomBytes === "function") {
                try {
                  return crypto.randomBytes(4).readInt32LE();
                } catch (err) {
                }
              }
            }
            throw new Error("Native crypto module could not be used to get secure random number.");
          };
          var create = Object.create || function() {
            function F() {
            }
            return function(obj) {
              var subtype;
              F.prototype = obj;
              subtype = new F();
              F.prototype = null;
              return subtype;
            };
          }();
          var C = {};
          var C_lib = C.lib = {};
          var Base = C_lib.Base = function() {
            return {
              /**
               * Creates a new object that inherits from this object.
               *
               * @param {Object} overrides Properties to copy into the new object.
               *
               * @return {Object} The new object.
               *
               * @static
               *
               * @example
               *
               *     var MyType = CryptoJS.lib.Base.extend({
               *         field: 'value',
               *
               *         method: function () {
               *         }
               *     });
               */
              extend: function(overrides) {
                var subtype = create(this);
                if (overrides) {
                  subtype.mixIn(overrides);
                }
                if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                  subtype.init = function() {
                    subtype.$super.init.apply(this, arguments);
                  };
                }
                subtype.init.prototype = subtype;
                subtype.$super = this;
                return subtype;
              },
              /**
               * Extends this object and runs the init method.
               * Arguments to create() will be passed to init().
               *
               * @return {Object} The new object.
               *
               * @static
               *
               * @example
               *
               *     var instance = MyType.create();
               */
              create: function() {
                var instance = this.extend();
                instance.init.apply(instance, arguments);
                return instance;
              },
              /**
               * Initializes a newly created object.
               * Override this method to add some logic when your objects are created.
               *
               * @example
               *
               *     var MyType = CryptoJS.lib.Base.extend({
               *         init: function () {
               *             // ...
               *         }
               *     });
               */
              init: function() {
              },
              /**
               * Copies properties into this object.
               *
               * @param {Object} properties The properties to mix in.
               *
               * @example
               *
               *     MyType.mixIn({
               *         field: 'value'
               *     });
               */
              mixIn: function(properties) {
                for (var propertyName in properties) {
                  if (properties.hasOwnProperty(propertyName)) {
                    this[propertyName] = properties[propertyName];
                  }
                }
                if (properties.hasOwnProperty("toString")) {
                  this.toString = properties.toString;
                }
              },
              /**
               * Creates a copy of this object.
               *
               * @return {Object} The clone.
               *
               * @example
               *
               *     var clone = instance.clone();
               */
              clone: function() {
                return this.init.prototype.extend(this);
              }
            };
          }();
          var WordArray = C_lib.WordArray = Base.extend({
            /**
             * Initializes a newly created word array.
             *
             * @param {Array} words (Optional) An array of 32-bit words.
             * @param {number} sigBytes (Optional) The number of significant bytes in the words.
             *
             * @example
             *
             *     var wordArray = CryptoJS.lib.WordArray.create();
             *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
             *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
             */
            init: function(words, sigBytes) {
              words = this.words = words || [];
              if (sigBytes != undefined2) {
                this.sigBytes = sigBytes;
              } else {
                this.sigBytes = words.length * 4;
              }
            },
            /**
             * Converts this word array to a string.
             *
             * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
             *
             * @return {string} The stringified word array.
             *
             * @example
             *
             *     var string = wordArray + '';
             *     var string = wordArray.toString();
             *     var string = wordArray.toString(CryptoJS.enc.Utf8);
             */
            toString: function(encoder) {
              return (encoder || Hex).stringify(this);
            },
            /**
             * Concatenates a word array to this word array.
             *
             * @param {WordArray} wordArray The word array to append.
             *
             * @return {WordArray} This word array.
             *
             * @example
             *
             *     wordArray1.concat(wordArray2);
             */
            concat: function(wordArray) {
              var thisWords = this.words;
              var thatWords = wordArray.words;
              var thisSigBytes = this.sigBytes;
              var thatSigBytes = wordArray.sigBytes;
              this.clamp();
              if (thisSigBytes % 4) {
                for (var i = 0; i < thatSigBytes; i++) {
                  var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                  thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
                }
              } else {
                for (var j = 0; j < thatSigBytes; j += 4) {
                  thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
                }
              }
              this.sigBytes += thatSigBytes;
              return this;
            },
            /**
             * Removes insignificant bits.
             *
             * @example
             *
             *     wordArray.clamp();
             */
            clamp: function() {
              var words = this.words;
              var sigBytes = this.sigBytes;
              words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
              words.length = Math2.ceil(sigBytes / 4);
            },
            /**
             * Creates a copy of this word array.
             *
             * @return {WordArray} The clone.
             *
             * @example
             *
             *     var clone = wordArray.clone();
             */
            clone: function() {
              var clone = Base.clone.call(this);
              clone.words = this.words.slice(0);
              return clone;
            },
            /**
             * Creates a word array filled with random bytes.
             *
             * @param {number} nBytes The number of random bytes to generate.
             *
             * @return {WordArray} The random word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.lib.WordArray.random(16);
             */
            random: function(nBytes) {
              var words = [];
              for (var i = 0; i < nBytes; i += 4) {
                words.push(cryptoSecureRandomInt());
              }
              return new WordArray.init(words, nBytes);
            }
          });
          var C_enc = C.enc = {};
          var Hex = C_enc.Hex = {
            /**
             * Converts a word array to a hex string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @return {string} The hex string.
             *
             * @static
             *
             * @example
             *
             *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
             */
            stringify: function(wordArray) {
              var words = wordArray.words;
              var sigBytes = wordArray.sigBytes;
              var hexChars = [];
              for (var i = 0; i < sigBytes; i++) {
                var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                hexChars.push((bite >>> 4).toString(16));
                hexChars.push((bite & 15).toString(16));
              }
              return hexChars.join("");
            },
            /**
             * Converts a hex string to a word array.
             *
             * @param {string} hexStr The hex string.
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
             */
            parse: function(hexStr) {
              var hexStrLength = hexStr.length;
              var words = [];
              for (var i = 0; i < hexStrLength; i += 2) {
                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
              }
              return new WordArray.init(words, hexStrLength / 2);
            }
          };
          var Latin1 = C_enc.Latin1 = {
            /**
             * Converts a word array to a Latin1 string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @return {string} The Latin1 string.
             *
             * @static
             *
             * @example
             *
             *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
             */
            stringify: function(wordArray) {
              var words = wordArray.words;
              var sigBytes = wordArray.sigBytes;
              var latin1Chars = [];
              for (var i = 0; i < sigBytes; i++) {
                var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                latin1Chars.push(String.fromCharCode(bite));
              }
              return latin1Chars.join("");
            },
            /**
             * Converts a Latin1 string to a word array.
             *
             * @param {string} latin1Str The Latin1 string.
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
             */
            parse: function(latin1Str) {
              var latin1StrLength = latin1Str.length;
              var words = [];
              for (var i = 0; i < latin1StrLength; i++) {
                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
              }
              return new WordArray.init(words, latin1StrLength);
            }
          };
          var Utf8 = C_enc.Utf8 = {
            /**
             * Converts a word array to a UTF-8 string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @return {string} The UTF-8 string.
             *
             * @static
             *
             * @example
             *
             *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
             */
            stringify: function(wordArray) {
              try {
                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
              } catch (e) {
                throw new Error("Malformed UTF-8 data");
              }
            },
            /**
             * Converts a UTF-8 string to a word array.
             *
             * @param {string} utf8Str The UTF-8 string.
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
             */
            parse: function(utf8Str) {
              return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
            }
          };
          var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
            /**
             * Resets this block algorithm's data buffer to its initial state.
             *
             * @example
             *
             *     bufferedBlockAlgorithm.reset();
             */
            reset: function() {
              this._data = new WordArray.init();
              this._nDataBytes = 0;
            },
            /**
             * Adds new data to this block algorithm's buffer.
             *
             * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
             *
             * @example
             *
             *     bufferedBlockAlgorithm._append('data');
             *     bufferedBlockAlgorithm._append(wordArray);
             */
            _append: function(data) {
              if (typeof data == "string") {
                data = Utf8.parse(data);
              }
              this._data.concat(data);
              this._nDataBytes += data.sigBytes;
            },
            /**
             * Processes available data blocks.
             *
             * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
             *
             * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
             *
             * @return {WordArray} The processed data.
             *
             * @example
             *
             *     var processedData = bufferedBlockAlgorithm._process();
             *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
             */
            _process: function(doFlush) {
              var processedWords;
              var data = this._data;
              var dataWords = data.words;
              var dataSigBytes = data.sigBytes;
              var blockSize = this.blockSize;
              var blockSizeBytes = blockSize * 4;
              var nBlocksReady = dataSigBytes / blockSizeBytes;
              if (doFlush) {
                nBlocksReady = Math2.ceil(nBlocksReady);
              } else {
                nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
              }
              var nWordsReady = nBlocksReady * blockSize;
              var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
              if (nWordsReady) {
                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                  this._doProcessBlock(dataWords, offset);
                }
                processedWords = dataWords.splice(0, nWordsReady);
                data.sigBytes -= nBytesReady;
              }
              return new WordArray.init(processedWords, nBytesReady);
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = bufferedBlockAlgorithm.clone();
             */
            clone: function() {
              var clone = Base.clone.call(this);
              clone._data = this._data.clone();
              return clone;
            },
            _minBufferSize: 0
          });
          var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
            /**
             * Configuration options.
             */
            cfg: Base.extend(),
            /**
             * Initializes a newly created hasher.
             *
             * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
             *
             * @example
             *
             *     var hasher = CryptoJS.algo.SHA256.create();
             */
            init: function(cfg) {
              this.cfg = this.cfg.extend(cfg);
              this.reset();
            },
            /**
             * Resets this hasher to its initial state.
             *
             * @example
             *
             *     hasher.reset();
             */
            reset: function() {
              BufferedBlockAlgorithm.reset.call(this);
              this._doReset();
            },
            /**
             * Updates this hasher with a message.
             *
             * @param {WordArray|string} messageUpdate The message to append.
             *
             * @return {Hasher} This hasher.
             *
             * @example
             *
             *     hasher.update('message');
             *     hasher.update(wordArray);
             */
            update: function(messageUpdate) {
              this._append(messageUpdate);
              this._process();
              return this;
            },
            /**
             * Finalizes the hash computation.
             * Note that the finalize operation is effectively a destructive, read-once operation.
             *
             * @param {WordArray|string} messageUpdate (Optional) A final message update.
             *
             * @return {WordArray} The hash.
             *
             * @example
             *
             *     var hash = hasher.finalize();
             *     var hash = hasher.finalize('message');
             *     var hash = hasher.finalize(wordArray);
             */
            finalize: function(messageUpdate) {
              if (messageUpdate) {
                this._append(messageUpdate);
              }
              var hash = this._doFinalize();
              return hash;
            },
            blockSize: 512 / 32,
            /**
             * Creates a shortcut function to a hasher's object interface.
             *
             * @param {Hasher} hasher The hasher to create a helper for.
             *
             * @return {Function} The shortcut function.
             *
             * @static
             *
             * @example
             *
             *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
             */
            _createHelper: function(hasher) {
              return function(message, cfg) {
                return new hasher.init(cfg).finalize(message);
              };
            },
            /**
             * Creates a shortcut function to the HMAC's object interface.
             *
             * @param {Hasher} hasher The hasher to use in this HMAC helper.
             *
             * @return {Function} The shortcut function.
             *
             * @static
             *
             * @example
             *
             *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
             */
            _createHmacHelper: function(hasher) {
              return function(message, key) {
                return new C_algo.HMAC.init(hasher, key).finalize(message);
              };
            }
          });
          var C_algo = C.algo = {};
          return C;
        }(Math);
        return CryptoJS;
      });
    }
  });

  // ../zotero-style/node_modules/crypto-js/x64-core.js
  var require_x64_core = __commonJS({
    "../zotero-style/node_modules/crypto-js/x64-core.js"(exports, module) {
      (function(root, factory) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function(undefined2) {
          var C = CryptoJS;
          var C_lib = C.lib;
          var Base = C_lib.Base;
          var X32WordArray = C_lib.WordArray;
          var C_x64 = C.x64 = {};
          var X64Word = C_x64.Word = Base.extend({
            /**
             * Initializes a newly created 64-bit word.
             *
             * @param {number} high The high 32 bits.
             * @param {number} low The low 32 bits.
             *
             * @example
             *
             *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
             */
            init: function(high, low) {
              this.high = high;
              this.low = low;
            }
            /**
             * Bitwise NOTs this word.
             *
             * @return {X64Word} A new x64-Word object after negating.
             *
             * @example
             *
             *     var negated = x64Word.not();
             */
            // not: function () {
            // var high = ~this.high;
            // var low = ~this.low;
            // return X64Word.create(high, low);
            // },
            /**
             * Bitwise ANDs this word with the passed word.
             *
             * @param {X64Word} word The x64-Word to AND with this word.
             *
             * @return {X64Word} A new x64-Word object after ANDing.
             *
             * @example
             *
             *     var anded = x64Word.and(anotherX64Word);
             */
            // and: function (word) {
            // var high = this.high & word.high;
            // var low = this.low & word.low;
            // return X64Word.create(high, low);
            // },
            /**
             * Bitwise ORs this word with the passed word.
             *
             * @param {X64Word} word The x64-Word to OR with this word.
             *
             * @return {X64Word} A new x64-Word object after ORing.
             *
             * @example
             *
             *     var ored = x64Word.or(anotherX64Word);
             */
            // or: function (word) {
            // var high = this.high | word.high;
            // var low = this.low | word.low;
            // return X64Word.create(high, low);
            // },
            /**
             * Bitwise XORs this word with the passed word.
             *
             * @param {X64Word} word The x64-Word to XOR with this word.
             *
             * @return {X64Word} A new x64-Word object after XORing.
             *
             * @example
             *
             *     var xored = x64Word.xor(anotherX64Word);
             */
            // xor: function (word) {
            // var high = this.high ^ word.high;
            // var low = this.low ^ word.low;
            // return X64Word.create(high, low);
            // },
            /**
             * Shifts this word n bits to the left.
             *
             * @param {number} n The number of bits to shift.
             *
             * @return {X64Word} A new x64-Word object after shifting.
             *
             * @example
             *
             *     var shifted = x64Word.shiftL(25);
             */
            // shiftL: function (n) {
            // if (n < 32) {
            // var high = (this.high << n) | (this.low >>> (32 - n));
            // var low = this.low << n;
            // } else {
            // var high = this.low << (n - 32);
            // var low = 0;
            // }
            // return X64Word.create(high, low);
            // },
            /**
             * Shifts this word n bits to the right.
             *
             * @param {number} n The number of bits to shift.
             *
             * @return {X64Word} A new x64-Word object after shifting.
             *
             * @example
             *
             *     var shifted = x64Word.shiftR(7);
             */
            // shiftR: function (n) {
            // if (n < 32) {
            // var low = (this.low >>> n) | (this.high << (32 - n));
            // var high = this.high >>> n;
            // } else {
            // var low = this.high >>> (n - 32);
            // var high = 0;
            // }
            // return X64Word.create(high, low);
            // },
            /**
             * Rotates this word n bits to the left.
             *
             * @param {number} n The number of bits to rotate.
             *
             * @return {X64Word} A new x64-Word object after rotating.
             *
             * @example
             *
             *     var rotated = x64Word.rotL(25);
             */
            // rotL: function (n) {
            // return this.shiftL(n).or(this.shiftR(64 - n));
            // },
            /**
             * Rotates this word n bits to the right.
             *
             * @param {number} n The number of bits to rotate.
             *
             * @return {X64Word} A new x64-Word object after rotating.
             *
             * @example
             *
             *     var rotated = x64Word.rotR(7);
             */
            // rotR: function (n) {
            // return this.shiftR(n).or(this.shiftL(64 - n));
            // },
            /**
             * Adds this word with the passed word.
             *
             * @param {X64Word} word The x64-Word to add with this word.
             *
             * @return {X64Word} A new x64-Word object after adding.
             *
             * @example
             *
             *     var added = x64Word.add(anotherX64Word);
             */
            // add: function (word) {
            // var low = (this.low + word.low) | 0;
            // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
            // var high = (this.high + word.high + carry) | 0;
            // return X64Word.create(high, low);
            // }
          });
          var X64WordArray = C_x64.WordArray = Base.extend({
            /**
             * Initializes a newly created word array.
             *
             * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
             * @param {number} sigBytes (Optional) The number of significant bytes in the words.
             *
             * @example
             *
             *     var wordArray = CryptoJS.x64.WordArray.create();
             *
             *     var wordArray = CryptoJS.x64.WordArray.create([
             *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
             *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
             *     ]);
             *
             *     var wordArray = CryptoJS.x64.WordArray.create([
             *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
             *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
             *     ], 10);
             */
            init: function(words, sigBytes) {
              words = this.words = words || [];
              if (sigBytes != undefined2) {
                this.sigBytes = sigBytes;
              } else {
                this.sigBytes = words.length * 8;
              }
            },
            /**
             * Converts this 64-bit word array to a 32-bit word array.
             *
             * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
             *
             * @example
             *
             *     var x32WordArray = x64WordArray.toX32();
             */
            toX32: function() {
              var x64Words = this.words;
              var x64WordsLength = x64Words.length;
              var x32Words = [];
              for (var i = 0; i < x64WordsLength; i++) {
                var x64Word = x64Words[i];
                x32Words.push(x64Word.high);
                x32Words.push(x64Word.low);
              }
              return X32WordArray.create(x32Words, this.sigBytes);
            },
            /**
             * Creates a copy of this word array.
             *
             * @return {X64WordArray} The clone.
             *
             * @example
             *
             *     var clone = x64WordArray.clone();
             */
            clone: function() {
              var clone = Base.clone.call(this);
              var words = clone.words = this.words.slice(0);
              var wordsLength = words.length;
              for (var i = 0; i < wordsLength; i++) {
                words[i] = words[i].clone();
              }
              return clone;
            }
          });
        })();
        return CryptoJS;
      });
    }
  });

  // ../zotero-style/node_modules/crypto-js/lib-typedarrays.js
  var require_lib_typedarrays = __commonJS({
    "../zotero-style/node_modules/crypto-js/lib-typedarrays.js"(exports, module) {
      (function(root, factory) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function() {
          if (typeof ArrayBuffer != "function") {
            return;
          }
          var C = CryptoJS;
          var C_lib = C.lib;
          var WordArray = C_lib.WordArray;
          var superInit = WordArray.init;
          var subInit = WordArray.init = function(typedArray) {
            if (typedArray instanceof ArrayBuffer) {
              typedArray = new Uint8Array(typedArray);
            }
            if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
              typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
            }
            if (typedArray instanceof Uint8Array) {
              var typedArrayByteLength = typedArray.byteLength;
              var words = [];
              for (var i = 0; i < typedArrayByteLength; i++) {
                words[i >>> 2] |= typedArray[i] << 24 - i % 4 * 8;
              }
              superInit.call(this, words, typedArrayByteLength);
            } else {
              superInit.apply(this, arguments);
            }
          };
          subInit.prototype = WordArray;
        })();
        return CryptoJS.lib.WordArray;
      });
    }
  });

  // ../zotero-style/node_modules/crypto-js/enc-utf16.js
  var require_enc_utf16 = __commonJS({
    "../zotero-style/node_modules/crypto-js/enc-utf16.js"(exports, module) {
      (function(root, factory) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function() {
          var C = CryptoJS;
          var C_lib = C.lib;
          var WordArray = C_lib.WordArray;
          var C_enc = C.enc;
          var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
            /**
             * Converts a word array to a UTF-16 BE string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @return {string} The UTF-16 BE string.
             *
             * @static
             *
             * @example
             *
             *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
             */
            stringify: function(wordArray) {
              var words = wordArray.words;
              var sigBytes = wordArray.sigBytes;
              var utf16Chars = [];
              for (var i = 0; i < sigBytes; i += 2) {
                var codePoint = words[i >>> 2] >>> 16 - i % 4 * 8 & 65535;
                utf16Chars.push(String.fromCharCode(codePoint));
              }
              return utf16Chars.join("");
            },
            /**
             * Converts a UTF-16 BE string to a word array.
             *
             * @param {string} utf16Str The UTF-16 BE string.
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
             */
            parse: function(utf16Str) {
              var utf16StrLength = utf16Str.length;
              var words = [];
              for (var i = 0; i < utf16StrLength; i++) {
                words[i >>> 1] |= utf16Str.charCodeAt(i) << 16 - i % 2 * 16;
              }
              return WordArray.create(words, utf16StrLength * 2);
            }
          };
          C_enc.Utf16LE = {
            /**
             * Converts a word array to a UTF-16 LE string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @return {string} The UTF-16 LE string.
             *
             * @static
             *
             * @example
             *
             *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
             */
            stringify: function(wordArray) {
              var words = wordArray.words;
              var sigBytes = wordArray.sigBytes;
              var utf16Chars = [];
              for (var i = 0; i < sigBytes; i += 2) {
                var codePoint = swapEndian(words[i >>> 2] >>> 16 - i % 4 * 8 & 65535);
                utf16Chars.push(String.fromCharCode(codePoint));
              }
              return utf16Chars.join("");
            },
            /**
             * Converts a UTF-16 LE string to a word array.
             *
             * @param {string} utf16Str The UTF-16 LE string.
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
             */
            parse: function(utf16Str) {
              var utf16StrLength = utf16Str.length;
              var words = [];
              for (var i = 0; i < utf16StrLength; i++) {
                words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << 16 - i % 2 * 16);
              }
              return WordArray.create(words, utf16StrLength * 2);
            }
          };
          function swapEndian(word) {
            return word << 8 & 4278255360 | word >>> 8 & 16711935;
          }
        })();
        return CryptoJS.enc.Utf16;
      });
    }
  });

  // ../zotero-style/node_modules/crypto-js/enc-base64.js
  var require_enc_base64 = __commonJS({
    "../zotero-style/node_modules/crypto-js/enc-base64.js"(exports, module) {
      (function(root, factory) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function() {
          var C = CryptoJS;
          var C_lib = C.lib;
          var WordArray = C_lib.WordArray;
          var C_enc = C.enc;
          var Base64 = C_enc.Base64 = {
            /**
             * Converts a word array to a Base64 string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @return {string} The Base64 string.
             *
             * @static
             *
             * @example
             *
             *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
             */
            stringify: function(wordArray) {
              var words = wordArray.words;
              var sigBytes = wordArray.sigBytes;
              var map = this._map;
              wordArray.clamp();
              var base64Chars = [];
              for (var i = 0; i < sigBytes; i += 3) {
                var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
                var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
                var triplet = byte1 << 16 | byte2 << 8 | byte3;
                for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                  base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
                }
              }
              var paddingChar = map.charAt(64);
              if (paddingChar) {
                while (base64Chars.length % 4) {
                  base64Chars.push(paddingChar);
                }
              }
              return base64Chars.join("");
            },
            /**
             * Converts a Base64 string to a word array.
             *
             * @param {string} base64Str The Base64 string.
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
             */
            parse: function(base64Str) {
              var base64StrLength = base64Str.length;
              var map = this._map;
              var reverseMap = this._reverseMap;
              if (!reverseMap) {
                reverseMap = this._reverseMap = [];
                for (var j = 0; j < map.length; j++) {
                  reverseMap[map.charCodeAt(j)] = j;
                }
              }
              var paddingChar = map.charAt(64);
              if (paddingChar) {
                var paddingIndex = base64Str.indexOf(paddingChar);
                if (paddingIndex !== -1) {
                  base64StrLength = paddingIndex;
                }
              }
              return parseLoop(base64Str, base64StrLength, reverseMap);
            },
            _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
          };
          function parseLoop(base64Str, base64StrLength, reverseMap) {
            var words = [];
            var nBytes = 0;
            for (var i = 0; i < base64StrLength; i++) {
              if (i % 4) {
                var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
                var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
                var bitsCombined = bits1 | bits2;
                words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
                nBytes++;
              }
            }
            return WordArray.create(words, nBytes);
          }
        })();
        return CryptoJS.enc.Base64;
      });
    }
  });

  // ../zotero-style/node_modules/crypto-js/enc-base64url.js
  var require_enc_base64url = __commonJS({
    "../zotero-style/node_modules/crypto-js/enc-base64url.js"(exports, module) {
      (function(root, factory) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function() {
          var C = CryptoJS;
          var C_lib = C.lib;
          var WordArray = C_lib.WordArray;
          var C_enc = C.enc;
          var Base64url = C_enc.Base64url = {
            /**
             * Converts a word array to a Base64url string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @param {boolean} urlSafe Whether to use url safe
             *
             * @return {string} The Base64url string.
             *
             * @static
             *
             * @example
             *
             *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
             */
            stringify: function(wordArray, urlSafe = true) {
              var words = wordArray.words;
              var sigBytes = wordArray.sigBytes;
              var map = urlSafe ? this._safe_map : this._map;
              wordArray.clamp();
              var base64Chars = [];
              for (var i = 0; i < sigBytes; i += 3) {
                var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
                var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
                var triplet = byte1 << 16 | byte2 << 8 | byte3;
                for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                  base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
                }
              }
              var paddingChar = map.charAt(64);
              if (paddingChar) {
                while (base64Chars.length % 4) {
                  base64Chars.push(paddingChar);
                }
              }
              return base64Chars.join("");
            },
            /**
             * Converts a Base64url string to a word array.
             *
             * @param {string} base64Str The Base64url string.
             *
             * @param {boolean} urlSafe Whether to use url safe
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
             */
            parse: function(base64Str, urlSafe = true) {
              var base64StrLength = base64Str.length;
              var map = urlSafe ? this._safe_map : this._map;
              var reverseMap = this._reverseMap;
              if (!reverseMap) {
                reverseMap = this._reverseMap = [];
                for (var j = 0; j < map.length; j++) {
                  reverseMap[map.charCodeAt(j)] = j;
                }
              }
              var paddingChar = map.charAt(64);
              if (paddingChar) {
                var paddingIndex = base64Str.indexOf(paddingChar);
                if (paddingIndex !== -1) {
                  base64StrLength = paddingIndex;
                }
              }
              return parseLoop(base64Str, base64StrLength, reverseMap);
            },
            _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
            _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
          };
          function parseLoop(base64Str, base64StrLength, reverseMap) {
            var words = [];
            var nBytes = 0;
            for (var i = 0; i < base64StrLength; i++) {
              if (i % 4) {
                var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
                var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
                var bitsCombined = bits1 | bits2;
                words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
                nBytes++;
              }
            }
            return WordArray.create(words, nBytes);
          }
        })();
        return CryptoJS.enc.Base64url;
      });
    }
  });

  // ../zotero-style/node_modules/crypto-js/md5.js
  var require_md5 = __commonJS({
    "../zotero-style/node_modules/crypto-js/md5.js"(exports, module) {
      (function(root, factory) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function(Math2) {
          var C = CryptoJS;
          var C_lib = C.lib;
          var WordArray = C_lib.WordArray;
          var Hasher = C_lib.Hasher;
          var C_algo = C.algo;
          var T = [];
          (function() {
            for (var i = 0; i < 64; i++) {
              T[i] = Math2.abs(Math2.sin(i + 1)) * 4294967296 | 0;
            }
          })();
          var MD5 = C_algo.MD5 = Hasher.extend({
            _doReset: function() {
              this._hash = new WordArray.init([
                1732584193,
                4023233417,
                2562383102,
                271733878
              ]);
            },
            _doProcessBlock: function(M, offset) {
              for (var i = 0; i < 16; i++) {
                var offset_i = offset + i;
                var M_offset_i = M[offset_i];
                M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
              }
              var H = this._hash.words;
              var M_offset_0 = M[offset + 0];
              var M_offset_1 = M[offset + 1];
              var M_offset_2 = M[offset + 2];
              var M_offset_3 = M[offset + 3];
              var M_offset_4 = M[offset + 4];
              var M_offset_5 = M[offset + 5];
              var M_offset_6 = M[offset + 6];
              var M_offset_7 = M[offset + 7];
              var M_offset_8 = M[offset + 8];
              var M_offset_9 = M[offset + 9];
              var M_offset_10 = M[offset + 10];
              var M_offset_11 = M[offset + 11];
              var M_offset_12 = M[offset + 12];
              var M_offset_13 = M[offset + 13];
              var M_offset_14 = M[offset + 14];
              var M_offset_15 = M[offset + 15];
              var a = H[0];
              var b = H[1];
              var c = H[2];
              var d = H[3];
              a = FF(a, b, c, d, M_offset_0, 7, T[0]);
              d = FF(d, a, b, c, M_offset_1, 12, T[1]);
              c = FF(c, d, a, b, M_offset_2, 17, T[2]);
              b = FF(b, c, d, a, M_offset_3, 22, T[3]);
              a = FF(a, b, c, d, M_offset_4, 7, T[4]);
              d = FF(d, a, b, c, M_offset_5, 12, T[5]);
              c = FF(c, d, a, b, M_offset_6, 17, T[6]);
              b = FF(b, c, d, a, M_offset_7, 22, T[7]);
              a = FF(a, b, c, d, M_offset_8, 7, T[8]);
              d = FF(d, a, b, c, M_offset_9, 12, T[9]);
              c = FF(c, d, a, b, M_offset_10, 17, T[10]);
              b = FF(b, c, d, a, M_offset_11, 22, T[11]);
              a = FF(a, b, c, d, M_offset_12, 7, T[12]);
              d = FF(d, a, b, c, M_offset_13, 12, T[13]);
              c = FF(c, d, a, b, M_offset_14, 17, T[14]);
              b = FF(b, c, d, a, M_offset_15, 22, T[15]);
              a = GG(a, b, c, d, M_offset_1, 5, T[16]);
              d = GG(d, a, b, c, M_offset_6, 9, T[17]);
              c = GG(c, d, a, b, M_offset_11, 14, T[18]);
              b = GG(b, c, d, a, M_offset_0, 20, T[19]);
              a = GG(a, b, c, d, M_offset_5, 5, T[20]);
              d = GG(d, a, b, c, M_offset_10, 9, T[21]);
              c = GG(c, d, a, b, M_offset_15, 14, T[22]);
              b = GG(b, c, d, a, M_offset_4, 20, T[23]);
              a = GG(a, b, c, d, M_offset_9, 5, T[24]);
              d = GG(d, a, b, c, M_offset_14, 9, T[25]);
              c = GG(c, d, a, b, M_offset_3, 14, T[26]);
              b = GG(b, c, d, a, M_offset_8, 20, T[27]);
              a = GG(a, b, c, d, M_offset_13, 5, T[28]);
              d = GG(d, a, b, c, M_offset_2, 9, T[29]);
              c = GG(c, d, a, b, M_offset_7, 14, T[30]);
              b = GG(b, c, d, a, M_offset_12, 20, T[31]);
              a = HH(a, b, c, d, M_offset_5, 4, T[32]);
              d = HH(d, a, b, c, M_offset_8, 11, T[33]);
              c = HH(c, d, a, b, M_offset_11, 16, T[34]);
              b = HH(b, c, d, a, M_offset_14, 23, T[35]);
              a = HH(a, b, c, d, M_offset_1, 4, T[36]);
              d = HH(d, a, b, c, M_offset_4, 11, T[37]);
              c = HH(c, d, a, b, M_offset_7, 16, T[38]);
              b = HH(b, c, d, a, M_offset_10, 23, T[39]);
              a = HH(a, b, c, d, M_offset_13, 4, T[40]);
              d = HH(d, a, b, c, M_offset_0, 11, T[41]);
              c = HH(c, d, a, b, M_offset_3, 16, T[42]);
              b = HH(b, c, d, a, M_offset_6, 23, T[43]);
              a = HH(a, b, c, d, M_offset_9, 4, T[44]);
              d = HH(d, a, b, c, M_offset_12, 11, T[45]);
              c = HH(c, d, a, b, M_offset_15, 16, T[46]);
              b = HH(b, c, d, a, M_offset_2, 23, T[47]);
              a = II(a, b, c, d, M_offset_0, 6, T[48]);
              d = II(d, a, b, c, M_offset_7, 10, T[49]);
              c = II(c, d, a, b, M_offset_14, 15, T[50]);
              b = II(b, c, d, a, M_offset_5, 21, T[51]);
              a = II(a, b, c, d, M_offset_12, 6, T[52]);
              d = II(d, a, b, c, M_offset_3, 10, T[53]);
              c = II(c, d, a, b, M_offset_10, 15, T[54]);
              b = II(b, c, d, a, M_offset_1, 21, T[55]);
              a = II(a, b, c, d, M_offset_8, 6, T[56]);
              d = II(d, a, b, c, M_offset_15, 10, T[57]);
              c = II(c, d, a, b, M_offset_6, 15, T[58]);
              b = II(b, c, d, a, M_offset_13, 21, T[59]);
              a = II(a, b, c, d, M_offset_4, 6, T[60]);
              d = II(d, a, b, c, M_offset_11, 10, T[61]);
              c = II(c, d, a, b, M_offset_2, 15, T[62]);
              b = II(b, c, d, a, M_offset_9, 21, T[63]);
              H[0] = H[0] + a | 0;
              H[1] = H[1] + b | 0;
              H[2] = H[2] + c | 0;
              H[3] = H[3] + d | 0;
            },
            _doFinalize: function() {
              var data = this._data;
              var dataWords = data.words;
              var nBitsTotal = this._nDataBytes * 8;
              var nBitsLeft = data.sigBytes * 8;
              dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
              var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
              var nBitsTotalL = nBitsTotal;
              dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
              dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
              data.sigBytes = (dataWords.length + 1) * 4;
              this._process();
              var hash = this._hash;
              var H = hash.words;
              for (var i = 0; i < 4; i++) {
                var H_i = H[i];
                H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
              }
              return hash;
            },
            clone: function() {
              var clone = Hasher.clone.call(this);
              clone._hash = this._hash.clone();
              return clone;
            }
          });
          function FF(a, b, c, d, x, s, t) {
            var n = a + (b & c | ~b & d) + x + t;
            return (n << s | n >>> 32 - s) + b;
          }
          function GG(a, b, c, d, x, s, t) {
            var n = a + (b & d | c & ~d) + x + t;
            return (n << s | n >>> 32 - s) + b;
          }
          function HH(a, b, c, d, x, s, t) {
            var n = a + (b ^ c ^ d) + x + t;
            return (n << s | n >>> 32 - s) + b;
          }
          function II(a, b, c, d, x, s, t) {
            var n = a + (c ^ (b | ~d)) + x + t;
            return (n << s | n >>> 32 - s) + b;
          }
          C.MD5 = Hasher._createHelper(MD5);
          C.HmacMD5 = Hasher._createHmacHelper(MD5);
        })(Math);
        return CryptoJS.MD5;
      });
    }
  });

  // ../zotero-style/node_modules/crypto-js/sha1.js
  var require_sha1 = __commonJS({
    "../zotero-style/node_modules/crypto-js/sha1.js"(exports, module) {
      (function(root, factory) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function() {
          var C = CryptoJS;
          var C_lib = C.lib;
          var WordArray = C_lib.WordArray;
          var Hasher = C_lib.Hasher;
          var C_algo = C.algo;
          var W = [];
          var SHA1 = C_algo.SHA1 = Hasher.extend({
            _doReset: function() {
              this._hash = new WordArray.init([
                1732584193,
                4023233417,
                2562383102,
                271733878,
                3285377520
              ]);
            },
            _doProcessBlock: function(M, offset) {
              var H = this._hash.words;
              var a = H[0];
              var b = H[1];
              var c = H[2];
              var d = H[3];
              var e = H[4];
              for (var i = 0; i < 80; i++) {
                if (i < 16) {
                  W[i] = M[offset + i] | 0;
                } else {
                  var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                  W[i] = n << 1 | n >>> 31;
                }
                var t = (a << 5 | a >>> 27) + e + W[i];
                if (i < 20) {
                  t += (b & c | ~b & d) + 1518500249;
                } else if (i < 40) {
                  t += (b ^ c ^ d) + 1859775393;
                } else if (i < 60) {
                  t += (b & c | b & d | c & d) - 1894007588;
                } else {
                  t += (b ^ c ^ d) - 899497514;
                }
                e = d;
                d = c;
                c = b << 30 | b >>> 2;
                b = a;
                a = t;
              }
              H[0] = H[0] + a | 0;
              H[1] = H[1] + b | 0;
              H[2] = H[2] + c | 0;
              H[3] = H[3] + d | 0;
              H[4] = H[4] + e | 0;
            },
            _doFinalize: function() {
              var data = this._data;
              var dataWords = data.words;
              var nBitsTotal = this._nDataBytes * 8;
              var nBitsLeft = data.sigBytes * 8;
              dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
              dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
              dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
              data.sigBytes = dataWords.length * 4;
              this._process();
              return this._hash;
            },
            clone: function() {
              var clone = Hasher.clone.call(this);
              clone._hash = this._hash.clone();
              return clone;
            }
          });
          C.SHA1 = Hasher._createHelper(SHA1);
          C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
        })();
        return CryptoJS.SHA1;
      });
    }
  });

  // ../zotero-style/node_modules/crypto-js/sha256.js
  var require_sha256 = __commonJS({
    "../zotero-style/node_modules/crypto-js/sha256.js"(exports, module) {
      (function(root, factory) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function(Math2) {
          var C = CryptoJS;
          var C_lib = C.lib;
          var WordArray = C_lib.WordArray;
          var Hasher = C_lib.Hasher;
          var C_algo = C.algo;
          var H = [];
          var K = [];
          (function() {
            function isPrime(n2) {
              var sqrtN = Math2.sqrt(n2);
              for (var factor = 2; factor <= sqrtN; factor++) {
                if (!(n2 % factor)) {
                  return false;
                }
              }
              return true;
            }
            function getFractionalBits(n2) {
              return (n2 - (n2 | 0)) * 4294967296 | 0;
            }
            var n = 2;
            var nPrime = 0;
            while (nPrime < 64) {
              if (isPrime(n)) {
                if (nPrime < 8) {
                  H[nPrime] = getFractionalBits(Math2.pow(n, 1 / 2));
                }
                K[nPrime] = getFractionalBits(Math2.pow(n, 1 / 3));
                nPrime++;
              }
              n++;
            }
          })();
          var W = [];
          var SHA256 = C_algo.SHA256 = Hasher.extend({
            _doReset: function() {
              this._hash = new WordArray.init(H.slice(0));
            },
            _doProcessBlock: function(M, offset) {
              var H2 = this._hash.words;
              var a = H2[0];
              var b = H2[1];
              var c = H2[2];
              var d = H2[3];
              var e = H2[4];
              var f = H2[5];
              var g = H2[6];
              var h = H2[7];
              for (var i = 0; i < 64; i++) {
                if (i < 16) {
                  W[i] = M[offset + i] | 0;
                } else {
                  var gamma0x = W[i - 15];
                  var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                  var gamma1x = W[i - 2];
                  var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                  W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
                }
                var ch = e & f ^ ~e & g;
                var maj = a & b ^ a & c ^ b & c;
                var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
                var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
                var t1 = h + sigma1 + ch + K[i] + W[i];
                var t2 = sigma0 + maj;
                h = g;
                g = f;
                f = e;
                e = d + t1 | 0;
                d = c;
                c = b;
                b = a;
                a = t1 + t2 | 0;
              }
              H2[0] = H2[0] + a | 0;
              H2[1] = H2[1] + b | 0;
              H2[2] = H2[2] + c | 0;
              H2[3] = H2[3] + d | 0;
              H2[4] = H2[4] + e | 0;
              H2[5] = H2[5] + f | 0;
              H2[6] = H2[6] + g | 0;
              H2[7] = H2[7] + h | 0;
            },
            _doFinalize: function() {
              var data = this._data;
              var dataWords = data.words;
              var nBitsTotal = this._nDataBytes * 8;
              var nBitsLeft = data.sigBytes * 8;
              dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
              dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
              dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
              data.sigBytes = dataWords.length * 4;
              this._process();
              return this._hash;
            },
            clone: function() {
              var clone = Hasher.clone.call(this);
              clone._hash = this._hash.clone();
              return clone;
            }
          });
          C.SHA256 = Hasher._createHelper(SHA256);
          C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
        })(Math);
        return CryptoJS.SHA256;
      });
    }
  });

  // ../zotero-style/node_modules/crypto-js/sha224.js
  var require_sha224 = __commonJS({
    "../zotero-style/node_modules/crypto-js/sha224.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_sha256());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./sha256"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function() {
          var C = CryptoJS;
          var C_lib = C.lib;
          var WordArray = C_lib.WordArray;
          var C_algo = C.algo;
          var SHA256 = C_algo.SHA256;
          var SHA224 = C_algo.SHA224 = SHA256.extend({
            _doReset: function() {
              this._hash = new WordArray.init([
                3238371032,
                914150663,
                812702999,
                4144912697,
                4290775857,
                1750603025,
                1694076839,
                3204075428
              ]);
            },
            _doFinalize: function() {
              var hash = SHA256._doFinalize.call(this);
              hash.sigBytes -= 4;
              return hash;
            }
          });
          C.SHA224 = SHA256._createHelper(SHA224);
          C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
        })();
        return CryptoJS.SHA224;
      });
    }
  });

  // ../zotero-style/node_modules/crypto-js/sha512.js
  var require_sha512 = __commonJS({
    "../zotero-style/node_modules/crypto-js/sha512.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_x64_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./x64-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function() {
          var C = CryptoJS;
          var C_lib = C.lib;
          var Hasher = C_lib.Hasher;
          var C_x64 = C.x64;
          var X64Word = C_x64.Word;
          var X64WordArray = C_x64.WordArray;
          var C_algo = C.algo;
          function X64Word_create() {
            return X64Word.create.apply(X64Word, arguments);
          }
          var K = [
            X64Word_create(1116352408, 3609767458),
            X64Word_create(1899447441, 602891725),
            X64Word_create(3049323471, 3964484399),
            X64Word_create(3921009573, 2173295548),
            X64Word_create(961987163, 4081628472),
            X64Word_create(1508970993, 3053834265),
            X64Word_create(2453635748, 2937671579),
            X64Word_create(2870763221, 3664609560),
            X64Word_create(3624381080, 2734883394),
            X64Word_create(310598401, 1164996542),
            X64Word_create(607225278, 1323610764),
            X64Word_create(1426881987, 3590304994),
            X64Word_create(1925078388, 4068182383),
            X64Word_create(2162078206, 991336113),
            X64Word_create(2614888103, 633803317),
            X64Word_create(3248222580, 3479774868),
            X64Word_create(3835390401, 2666613458),
            X64Word_create(4022224774, 944711139),
            X64Word_create(264347078, 2341262773),
            X64Word_create(604807628, 2007800933),
            X64Word_create(770255983, 1495990901),
            X64Word_create(1249150122, 1856431235),
            X64Word_create(1555081692, 3175218132),
            X64Word_create(1996064986, 2198950837),
            X64Word_create(2554220882, 3999719339),
            X64Word_create(2821834349, 766784016),
            X64Word_create(2952996808, 2566594879),
            X64Word_create(3210313671, 3203337956),
            X64Word_create(3336571891, 1034457026),
            X64Word_create(3584528711, 2466948901),
            X64Word_create(113926993, 3758326383),
            X64Word_create(338241895, 168717936),
            X64Word_create(666307205, 1188179964),
            X64Word_create(773529912, 1546045734),
            X64Word_create(1294757372, 1522805485),
            X64Word_create(1396182291, 2643833823),
            X64Word_create(1695183700, 2343527390),
            X64Word_create(1986661051, 1014477480),
            X64Word_create(2177026350, 1206759142),
            X64Word_create(2456956037, 344077627),
            X64Word_create(2730485921, 1290863460),
            X64Word_create(2820302411, 3158454273),
            X64Word_create(3259730800, 3505952657),
            X64Word_create(3345764771, 106217008),
            X64Word_create(3516065817, 3606008344),
            X64Word_create(3600352804, 1432725776),
            X64Word_create(4094571909, 1467031594),
            X64Word_create(275423344, 851169720),
            X64Word_create(430227734, 3100823752),
            X64Word_create(506948616, 1363258195),
            X64Word_create(659060556, 3750685593),
            X64Word_create(883997877, 3785050280),
            X64Word_create(958139571, 3318307427),
            X64Word_create(1322822218, 3812723403),
            X64Word_create(1537002063, 2003034995),
            X64Word_create(1747873779, 3602036899),
            X64Word_create(1955562222, 1575990012),
            X64Word_create(2024104815, 1125592928),
            X64Word_create(2227730452, 2716904306),
            X64Word_create(2361852424, 442776044),
            X64Word_create(2428436474, 593698344),
            X64Word_create(2756734187, 3733110249),
            X64Word_create(3204031479, 2999351573),
            X64Word_create(3329325298, 3815920427),
            X64Word_create(3391569614, 3928383900),
            X64Word_create(3515267271, 566280711),
            X64Word_create(3940187606, 3454069534),
            X64Word_create(4118630271, 4000239992),
            X64Word_create(116418474, 1914138554),
            X64Word_create(174292421, 2731055270),
            X64Word_create(289380356, 3203993006),
            X64Word_create(460393269, 320620315),
            X64Word_create(685471733, 587496836),
            X64Word_create(852142971, 1086792851),
            X64Word_create(1017036298, 365543100),
            X64Word_create(1126000580, 2618297676),
            X64Word_create(1288033470, 3409855158),
            X64Word_create(1501505948, 4234509866),
            X64Word_create(1607167915, 987167468),
            X64Word_create(1816402316, 1246189591)
          ];
          var W = [];
          (function() {
            for (var i = 0; i < 80; i++) {
              W[i] = X64Word_create();
            }
          })();
          var SHA512 = C_algo.SHA512 = Hasher.extend({
            _doReset: function() {
              this._hash = new X64WordArray.init([
                new X64Word.init(1779033703, 4089235720),
                new X64Word.init(3144134277, 2227873595),
                new X64Word.init(1013904242, 4271175723),
                new X64Word.init(2773480762, 1595750129),
                new X64Word.init(1359893119, 2917565137),
                new X64Word.init(2600822924, 725511199),
                new X64Word.init(528734635, 4215389547),
                new X64Word.init(1541459225, 327033209)
              ]);
            },
            _doProcessBlock: function(M, offset) {
              var H = this._hash.words;
              var H0 = H[0];
              var H1 = H[1];
              var H2 = H[2];
              var H3 = H[3];
              var H4 = H[4];
              var H5 = H[5];
              var H6 = H[6];
              var H7 = H[7];
              var H0h = H0.high;
              var H0l = H0.low;
              var H1h = H1.high;
              var H1l = H1.low;
              var H2h = H2.high;
              var H2l = H2.low;
              var H3h = H3.high;
              var H3l = H3.low;
              var H4h = H4.high;
              var H4l = H4.low;
              var H5h = H5.high;
              var H5l = H5.low;
              var H6h = H6.high;
              var H6l = H6.low;
              var H7h = H7.high;
              var H7l = H7.low;
              var ah = H0h;
              var al = H0l;
              var bh = H1h;
              var bl = H1l;
              var ch = H2h;
              var cl = H2l;
              var dh = H3h;
              var dl = H3l;
              var eh = H4h;
              var el = H4l;
              var fh = H5h;
              var fl = H5l;
              var gh = H6h;
              var gl = H6l;
              var hh = H7h;
              var hl = H7l;
              for (var i = 0; i < 80; i++) {
                var Wil;
                var Wih;
                var Wi = W[i];
                if (i < 16) {
                  Wih = Wi.high = M[offset + i * 2] | 0;
                  Wil = Wi.low = M[offset + i * 2 + 1] | 0;
                } else {
                  var gamma0x = W[i - 15];
                  var gamma0xh = gamma0x.high;
                  var gamma0xl = gamma0x.low;
                  var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                  var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                  var gamma1x = W[i - 2];
                  var gamma1xh = gamma1x.high;
                  var gamma1xl = gamma1x.low;
                  var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                  var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                  var Wi7 = W[i - 7];
                  var Wi7h = Wi7.high;
                  var Wi7l = Wi7.low;
                  var Wi16 = W[i - 16];
                  var Wi16h = Wi16.high;
                  var Wi16l = Wi16.low;
                  Wil = gamma0l + Wi7l;
                  Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                  Wil = Wil + gamma1l;
                  Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                  Wil = Wil + Wi16l;
                  Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                  Wi.high = Wih;
                  Wi.low = Wil;
                }
                var chh = eh & fh ^ ~eh & gh;
                var chl = el & fl ^ ~el & gl;
                var majh = ah & bh ^ ah & ch ^ bh & ch;
                var majl = al & bl ^ al & cl ^ bl & cl;
                var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
                var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
                var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
                var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);
                var Ki = K[i];
                var Kih = Ki.high;
                var Kil = Ki.low;
                var t1l = hl + sigma1l;
                var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
                var t1l = t1l + chl;
                var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
                var t1l = t1l + Kil;
                var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
                var t1l = t1l + Wil;
                var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
                var t2l = sigma0l + majl;
                var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
                hh = gh;
                hl = gl;
                gh = fh;
                gl = fl;
                fh = eh;
                fl = el;
                el = dl + t1l | 0;
                eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
                dh = ch;
                dl = cl;
                ch = bh;
                cl = bl;
                bh = ah;
                bl = al;
                al = t1l + t2l | 0;
                ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
              }
              H0l = H0.low = H0l + al;
              H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
              H1l = H1.low = H1l + bl;
              H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
              H2l = H2.low = H2l + cl;
              H2.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
              H3l = H3.low = H3l + dl;
              H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
              H4l = H4.low = H4l + el;
              H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
              H5l = H5.low = H5l + fl;
              H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
              H6l = H6.low = H6l + gl;
              H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
              H7l = H7.low = H7l + hl;
              H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
            },
            _doFinalize: function() {
              var data = this._data;
              var dataWords = data.words;
              var nBitsTotal = this._nDataBytes * 8;
              var nBitsLeft = data.sigBytes * 8;
              dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
              dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
              dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
              data.sigBytes = dataWords.length * 4;
              this._process();
              var hash = this._hash.toX32();
              return hash;
            },
            clone: function() {
              var clone = Hasher.clone.call(this);
              clone._hash = this._hash.clone();
              return clone;
            },
            blockSize: 1024 / 32
          });
          C.SHA512 = Hasher._createHelper(SHA512);
          C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
        })();
        return CryptoJS.SHA512;
      });
    }
  });

  // ../zotero-style/node_modules/crypto-js/sha384.js
  var require_sha384 = __commonJS({
    "../zotero-style/node_modules/crypto-js/sha384.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_x64_core(), require_sha512());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./x64-core", "./sha512"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function() {
          var C = CryptoJS;
          var C_x64 = C.x64;
          var X64Word = C_x64.Word;
          var X64WordArray = C_x64.WordArray;
          var C_algo = C.algo;
          var SHA512 = C_algo.SHA512;
          var SHA384 = C_algo.SHA384 = SHA512.extend({
            _doReset: function() {
              this._hash = new X64WordArray.init([
                new X64Word.init(3418070365, 3238371032),
                new X64Word.init(1654270250, 914150663),
                new X64Word.init(2438529370, 812702999),
                new X64Word.init(355462360, 4144912697),
                new X64Word.init(1731405415, 4290775857),
                new X64Word.init(2394180231, 1750603025),
                new X64Word.init(3675008525, 1694076839),
                new X64Word.init(1203062813, 3204075428)
              ]);
            },
            _doFinalize: function() {
              var hash = SHA512._doFinalize.call(this);
              hash.sigBytes -= 16;
              return hash;
            }
          });
          C.SHA384 = SHA512._createHelper(SHA384);
          C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
        })();
        return CryptoJS.SHA384;
      });
    }
  });

  // ../zotero-style/node_modules/crypto-js/sha3.js
  var require_sha3 = __commonJS({
    "../zotero-style/node_modules/crypto-js/sha3.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_x64_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./x64-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function(Math2) {
          var C = CryptoJS;
          var C_lib = C.lib;
          var WordArray = C_lib.WordArray;
          var Hasher = C_lib.Hasher;
          var C_x64 = C.x64;
          var X64Word = C_x64.Word;
          var C_algo = C.algo;
          var RHO_OFFSETS = [];
          var PI_INDEXES = [];
          var ROUND_CONSTANTS = [];
          (function() {
            var x = 1, y = 0;
            for (var t = 0; t < 24; t++) {
              RHO_OFFSETS[x + 5 * y] = (t + 1) * (t + 2) / 2 % 64;
              var newX = y % 5;
              var newY = (2 * x + 3 * y) % 5;
              x = newX;
              y = newY;
            }
            for (var x = 0; x < 5; x++) {
              for (var y = 0; y < 5; y++) {
                PI_INDEXES[x + 5 * y] = y + (2 * x + 3 * y) % 5 * 5;
              }
            }
            var LFSR = 1;
            for (var i = 0; i < 24; i++) {
              var roundConstantMsw = 0;
              var roundConstantLsw = 0;
              for (var j = 0; j < 7; j++) {
                if (LFSR & 1) {
                  var bitPosition = (1 << j) - 1;
                  if (bitPosition < 32) {
                    roundConstantLsw ^= 1 << bitPosition;
                  } else {
                    roundConstantMsw ^= 1 << bitPosition - 32;
                  }
                }
                if (LFSR & 128) {
                  LFSR = LFSR << 1 ^ 113;
                } else {
                  LFSR <<= 1;
                }
              }
              ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
            }
          })();
          var T = [];
          (function() {
            for (var i = 0; i < 25; i++) {
              T[i] = X64Word.create();
            }
          })();
          var SHA3 = C_algo.SHA3 = Hasher.extend({
            /**
             * Configuration options.
             *
             * @property {number} outputLength
             *   The desired number of bits in the output hash.
             *   Only values permitted are: 224, 256, 384, 512.
             *   Default: 512
             */
            cfg: Hasher.cfg.extend({
              outputLength: 512
            }),
            _doReset: function() {
              var state = this._state = [];
              for (var i = 0; i < 25; i++) {
                state[i] = new X64Word.init();
              }
              this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
            },
            _doProcessBlock: function(M, offset) {
              var state = this._state;
              var nBlockSizeLanes = this.blockSize / 2;
              for (var i = 0; i < nBlockSizeLanes; i++) {
                var M2i = M[offset + 2 * i];
                var M2i1 = M[offset + 2 * i + 1];
                M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
                M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
                var lane = state[i];
                lane.high ^= M2i1;
                lane.low ^= M2i;
              }
              for (var round = 0; round < 24; round++) {
                for (var x = 0; x < 5; x++) {
                  var tMsw = 0, tLsw = 0;
                  for (var y = 0; y < 5; y++) {
                    var lane = state[x + 5 * y];
                    tMsw ^= lane.high;
                    tLsw ^= lane.low;
                  }
                  var Tx = T[x];
                  Tx.high = tMsw;
                  Tx.low = tLsw;
                }
                for (var x = 0; x < 5; x++) {
                  var Tx4 = T[(x + 4) % 5];
                  var Tx1 = T[(x + 1) % 5];
                  var Tx1Msw = Tx1.high;
                  var Tx1Lsw = Tx1.low;
                  var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                  var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                  for (var y = 0; y < 5; y++) {
                    var lane = state[x + 5 * y];
                    lane.high ^= tMsw;
                    lane.low ^= tLsw;
                  }
                }
                for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                  var tMsw;
                  var tLsw;
                  var lane = state[laneIndex];
                  var laneMsw = lane.high;
                  var laneLsw = lane.low;
                  var rhoOffset = RHO_OFFSETS[laneIndex];
                  if (rhoOffset < 32) {
                    tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                    tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                  } else {
                    tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                    tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                  }
                  var TPiLane = T[PI_INDEXES[laneIndex]];
                  TPiLane.high = tMsw;
                  TPiLane.low = tLsw;
                }
                var T0 = T[0];
                var state0 = state[0];
                T0.high = state0.high;
                T0.low = state0.low;
                for (var x = 0; x < 5; x++) {
                  for (var y = 0; y < 5; y++) {
                    var laneIndex = x + 5 * y;
                    var lane = state[laneIndex];
                    var TLane = T[laneIndex];
                    var Tx1Lane = T[(x + 1) % 5 + 5 * y];
                    var Tx2Lane = T[(x + 2) % 5 + 5 * y];
                    lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                    lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                  }
                }
                var lane = state[0];
                var roundConstant = ROUND_CONSTANTS[round];
                lane.high ^= roundConstant.high;
                lane.low ^= roundConstant.low;
              }
            },
            _doFinalize: function() {
              var data = this._data;
              var dataWords = data.words;
              var nBitsTotal = this._nDataBytes * 8;
              var nBitsLeft = data.sigBytes * 8;
              var blockSizeBits = this.blockSize * 32;
              dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
              dataWords[(Math2.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
              data.sigBytes = dataWords.length * 4;
              this._process();
              var state = this._state;
              var outputLengthBytes = this.cfg.outputLength / 8;
              var outputLengthLanes = outputLengthBytes / 8;
              var hashWords = [];
              for (var i = 0; i < outputLengthLanes; i++) {
                var lane = state[i];
                var laneMsw = lane.high;
                var laneLsw = lane.low;
                laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
                laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
                hashWords.push(laneLsw);
                hashWords.push(laneMsw);
              }
              return new WordArray.init(hashWords, outputLengthBytes);
            },
            clone: function() {
              var clone = Hasher.clone.call(this);
              var state = clone._state = this._state.slice(0);
              for (var i = 0; i < 25; i++) {
                state[i] = state[i].clone();
              }
              return clone;
            }
          });
          C.SHA3 = Hasher._createHelper(SHA3);
          C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
        })(Math);
        return CryptoJS.SHA3;
      });
    }
  });

  // ../zotero-style/node_modules/crypto-js/ripemd160.js
  var require_ripemd160 = __commonJS({
    "../zotero-style/node_modules/crypto-js/ripemd160.js"(exports, module) {
      (function(root, factory) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function(Math2) {
          var C = CryptoJS;
          var C_lib = C.lib;
          var WordArray = C_lib.WordArray;
          var Hasher = C_lib.Hasher;
          var C_algo = C.algo;
          var _zl = WordArray.create([
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            7,
            4,
            13,
            1,
            10,
            6,
            15,
            3,
            12,
            0,
            9,
            5,
            2,
            14,
            11,
            8,
            3,
            10,
            14,
            4,
            9,
            15,
            8,
            1,
            2,
            7,
            0,
            6,
            13,
            11,
            5,
            12,
            1,
            9,
            11,
            10,
            0,
            8,
            12,
            4,
            13,
            3,
            7,
            15,
            14,
            5,
            6,
            2,
            4,
            0,
            5,
            9,
            7,
            12,
            2,
            10,
            14,
            1,
            3,
            8,
            11,
            6,
            15,
            13
          ]);
          var _zr = WordArray.create([
            5,
            14,
            7,
            0,
            9,
            2,
            11,
            4,
            13,
            6,
            15,
            8,
            1,
            10,
            3,
            12,
            6,
            11,
            3,
            7,
            0,
            13,
            5,
            10,
            14,
            15,
            8,
            12,
            4,
            9,
            1,
            2,
            15,
            5,
            1,
            3,
            7,
            14,
            6,
            9,
            11,
            8,
            12,
            2,
            10,
            0,
            4,
            13,
            8,
            6,
            4,
            1,
            3,
            11,
            15,
            0,
            5,
            12,
            2,
            13,
            9,
            7,
            10,
            14,
            12,
            15,
            10,
            4,
            1,
            5,
            8,
            7,
            6,
            2,
            13,
            14,
            0,
            3,
            9,
            11
          ]);
          var _sl = WordArray.create([
            11,
            14,
            15,
            12,
            5,
            8,
            7,
            9,
            11,
            13,
            14,
            15,
            6,
            7,
            9,
            8,
            7,
            6,
            8,
            13,
            11,
            9,
            7,
            15,
            7,
            12,
            15,
            9,
            11,
            7,
            13,
            12,
            11,
            13,
            6,
            7,
            14,
            9,
            13,
            15,
            14,
            8,
            13,
            6,
            5,
            12,
            7,
            5,
            11,
            12,
            14,
            15,
            14,
            15,
            9,
            8,
            9,
            14,
            5,
            6,
            8,
            6,
            5,
            12,
            9,
            15,
            5,
            11,
            6,
            8,
            13,
            12,
            5,
            12,
            13,
            14,
            11,
            8,
            5,
            6
          ]);
          var _sr = WordArray.create([
            8,
            9,
            9,
            11,
            13,
            15,
            15,
            5,
            7,
            7,
            8,
            11,
            14,
            14,
            12,
            6,
            9,
            13,
            15,
            7,
            12,
            8,
            9,
            11,
            7,
            7,
            12,
            7,
            6,
            15,
            13,
            11,
            9,
            7,
            15,
            11,
            8,
            6,
            6,
            14,
            12,
            13,
            5,
            14,
            13,
            13,
            7,
            5,
            15,
            5,
            8,
            11,
            14,
            14,
            6,
            14,
            6,
            9,
            12,
            9,
            12,
            5,
            15,
            8,
            8,
            5,
            12,
            9,
            12,
            5,
            14,
            6,
            8,
            13,
            6,
            5,
            15,
            13,
            11,
            11
          ]);
          var _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]);
          var _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]);
          var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
            _doReset: function() {
              this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
            },
            _doProcessBlock: function(M, offset) {
              for (var i = 0; i < 16; i++) {
                var offset_i = offset + i;
                var M_offset_i = M[offset_i];
                M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
              }
              var H = this._hash.words;
              var hl = _hl.words;
              var hr = _hr.words;
              var zl = _zl.words;
              var zr = _zr.words;
              var sl = _sl.words;
              var sr = _sr.words;
              var al, bl, cl, dl, el;
              var ar, br, cr, dr, er;
              ar = al = H[0];
              br = bl = H[1];
              cr = cl = H[2];
              dr = dl = H[3];
              er = el = H[4];
              var t;
              for (var i = 0; i < 80; i += 1) {
                t = al + M[offset + zl[i]] | 0;
                if (i < 16) {
                  t += f1(bl, cl, dl) + hl[0];
                } else if (i < 32) {
                  t += f2(bl, cl, dl) + hl[1];
                } else if (i < 48) {
                  t += f3(bl, cl, dl) + hl[2];
                } else if (i < 64) {
                  t += f4(bl, cl, dl) + hl[3];
                } else {
                  t += f5(bl, cl, dl) + hl[4];
                }
                t = t | 0;
                t = rotl(t, sl[i]);
                t = t + el | 0;
                al = el;
                el = dl;
                dl = rotl(cl, 10);
                cl = bl;
                bl = t;
                t = ar + M[offset + zr[i]] | 0;
                if (i < 16) {
                  t += f5(br, cr, dr) + hr[0];
                } else if (i < 32) {
                  t += f4(br, cr, dr) + hr[1];
                } else if (i < 48) {
                  t += f3(br, cr, dr) + hr[2];
                } else if (i < 64) {
                  t += f2(br, cr, dr) + hr[3];
                } else {
                  t += f1(br, cr, dr) + hr[4];
                }
                t = t | 0;
                t = rotl(t, sr[i]);
                t = t + er | 0;
                ar = er;
                er = dr;
                dr = rotl(cr, 10);
                cr = br;
                br = t;
              }
              t = H[1] + cl + dr | 0;
              H[1] = H[2] + dl + er | 0;
              H[2] = H[3] + el + ar | 0;
              H[3] = H[4] + al + br | 0;
              H[4] = H[0] + bl + cr | 0;
              H[0] = t;
            },
            _doFinalize: function() {
              var data = this._data;
              var dataWords = data.words;
              var nBitsTotal = this._nDataBytes * 8;
              var nBitsLeft = data.sigBytes * 8;
              dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
              dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
              data.sigBytes = (dataWords.length + 1) * 4;
              this._process();
              var hash = this._hash;
              var H = hash.words;
              for (var i = 0; i < 5; i++) {
                var H_i = H[i];
                H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
              }
              return hash;
            },
            clone: function() {
              var clone = Hasher.clone.call(this);
              clone._hash = this._hash.clone();
              return clone;
            }
          });
          function f1(x, y, z) {
            return x ^ y ^ z;
          }
          function f2(x, y, z) {
            return x & y | ~x & z;
          }
          function f3(x, y, z) {
            return (x | ~y) ^ z;
          }
          function f4(x, y, z) {
            return x & z | y & ~z;
          }
          function f5(x, y, z) {
            return x ^ (y | ~z);
          }
          function rotl(x, n) {
            return x << n | x >>> 32 - n;
          }
          C.RIPEMD160 = Hasher._createHelper(RIPEMD160);
          C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
        })(Math);
        return CryptoJS.RIPEMD160;
      });
    }
  });

  // ../zotero-style/node_modules/crypto-js/hmac.js
  var require_hmac = __commonJS({
    "../zotero-style/node_modules/crypto-js/hmac.js"(exports, module) {
      (function(root, factory) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function() {
          var C = CryptoJS;
          var C_lib = C.lib;
          var Base = C_lib.Base;
          var C_enc = C.enc;
          var Utf8 = C_enc.Utf8;
          var C_algo = C.algo;
          var HMAC = C_algo.HMAC = Base.extend({
            /**
             * Initializes a newly created HMAC.
             *
             * @param {Hasher} hasher The hash algorithm to use.
             * @param {WordArray|string} key The secret key.
             *
             * @example
             *
             *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
             */
            init: function(hasher, key) {
              hasher = this._hasher = new hasher.init();
              if (typeof key == "string") {
                key = Utf8.parse(key);
              }
              var hasherBlockSize = hasher.blockSize;
              var hasherBlockSizeBytes = hasherBlockSize * 4;
              if (key.sigBytes > hasherBlockSizeBytes) {
                key = hasher.finalize(key);
              }
              key.clamp();
              var oKey = this._oKey = key.clone();
              var iKey = this._iKey = key.clone();
              var oKeyWords = oKey.words;
              var iKeyWords = iKey.words;
              for (var i = 0; i < hasherBlockSize; i++) {
                oKeyWords[i] ^= 1549556828;
                iKeyWords[i] ^= 909522486;
              }
              oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
              this.reset();
            },
            /**
             * Resets this HMAC to its initial state.
             *
             * @example
             *
             *     hmacHasher.reset();
             */
            reset: function() {
              var hasher = this._hasher;
              hasher.reset();
              hasher.update(this._iKey);
            },
            /**
             * Updates this HMAC with a message.
             *
             * @param {WordArray|string} messageUpdate The message to append.
             *
             * @return {HMAC} This HMAC instance.
             *
             * @example
             *
             *     hmacHasher.update('message');
             *     hmacHasher.update(wordArray);
             */
            update: function(messageUpdate) {
              this._hasher.update(messageUpdate);
              return this;
            },
            /**
             * Finalizes the HMAC computation.
             * Note that the finalize operation is effectively a destructive, read-once operation.
             *
             * @param {WordArray|string} messageUpdate (Optional) A final message update.
             *
             * @return {WordArray} The HMAC.
             *
             * @example
             *
             *     var hmac = hmacHasher.finalize();
             *     var hmac = hmacHasher.finalize('message');
             *     var hmac = hmacHasher.finalize(wordArray);
             */
            finalize: function(messageUpdate) {
              var hasher = this._hasher;
              var innerHash = hasher.finalize(messageUpdate);
              hasher.reset();
              var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));
              return hmac;
            }
          });
        })();
      });
    }
  });

  // ../zotero-style/node_modules/crypto-js/pbkdf2.js
  var require_pbkdf2 = __commonJS({
    "../zotero-style/node_modules/crypto-js/pbkdf2.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_sha1(), require_hmac());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./sha1", "./hmac"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function() {
          var C = CryptoJS;
          var C_lib = C.lib;
          var Base = C_lib.Base;
          var WordArray = C_lib.WordArray;
          var C_algo = C.algo;
          var SHA1 = C_algo.SHA1;
          var HMAC = C_algo.HMAC;
          var PBKDF2 = C_algo.PBKDF2 = Base.extend({
            /**
             * Configuration options.
             *
             * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
             * @property {Hasher} hasher The hasher to use. Default: SHA1
             * @property {number} iterations The number of iterations to perform. Default: 1
             */
            cfg: Base.extend({
              keySize: 128 / 32,
              hasher: SHA1,
              iterations: 1
            }),
            /**
             * Initializes a newly created key derivation function.
             *
             * @param {Object} cfg (Optional) The configuration options to use for the derivation.
             *
             * @example
             *
             *     var kdf = CryptoJS.algo.PBKDF2.create();
             *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
             *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
             */
            init: function(cfg) {
              this.cfg = this.cfg.extend(cfg);
            },
            /**
             * Computes the Password-Based Key Derivation Function 2.
             *
             * @param {WordArray|string} password The password.
             * @param {WordArray|string} salt A salt.
             *
             * @return {WordArray} The derived key.
             *
             * @example
             *
             *     var key = kdf.compute(password, salt);
             */
            compute: function(password, salt) {
              var cfg = this.cfg;
              var hmac = HMAC.create(cfg.hasher, password);
              var derivedKey = WordArray.create();
              var blockIndex = WordArray.create([1]);
              var derivedKeyWords = derivedKey.words;
              var blockIndexWords = blockIndex.words;
              var keySize = cfg.keySize;
              var iterations = cfg.iterations;
              while (derivedKeyWords.length < keySize) {
                var block = hmac.update(salt).finalize(blockIndex);
                hmac.reset();
                var blockWords = block.words;
                var blockWordsLength = blockWords.length;
                var intermediate = block;
                for (var i = 1; i < iterations; i++) {
                  intermediate = hmac.finalize(intermediate);
                  hmac.reset();
                  var intermediateWords = intermediate.words;
                  for (var j = 0; j < blockWordsLength; j++) {
                    blockWords[j] ^= intermediateWords[j];
                  }
                }
                derivedKey.concat(block);
                blockIndexWords[0]++;
              }
              derivedKey.sigBytes = keySize * 4;
              return derivedKey;
            }
          });
          C.PBKDF2 = function(password, salt, cfg) {
            return PBKDF2.create(cfg).compute(password, salt);
          };
        })();
        return CryptoJS.PBKDF2;
      });
    }
  });

  // ../zotero-style/node_modules/crypto-js/evpkdf.js
  var require_evpkdf = __commonJS({
    "../zotero-style/node_modules/crypto-js/evpkdf.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_sha1(), require_hmac());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./sha1", "./hmac"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function() {
          var C = CryptoJS;
          var C_lib = C.lib;
          var Base = C_lib.Base;
          var WordArray = C_lib.WordArray;
          var C_algo = C.algo;
          var MD5 = C_algo.MD5;
          var EvpKDF = C_algo.EvpKDF = Base.extend({
            /**
             * Configuration options.
             *
             * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
             * @property {Hasher} hasher The hash algorithm to use. Default: MD5
             * @property {number} iterations The number of iterations to perform. Default: 1
             */
            cfg: Base.extend({
              keySize: 128 / 32,
              hasher: MD5,
              iterations: 1
            }),
            /**
             * Initializes a newly created key derivation function.
             *
             * @param {Object} cfg (Optional) The configuration options to use for the derivation.
             *
             * @example
             *
             *     var kdf = CryptoJS.algo.EvpKDF.create();
             *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
             *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
             */
            init: function(cfg) {
              this.cfg = this.cfg.extend(cfg);
            },
            /**
             * Derives a key from a password.
             *
             * @param {WordArray|string} password The password.
             * @param {WordArray|string} salt A salt.
             *
             * @return {WordArray} The derived key.
             *
             * @example
             *
             *     var key = kdf.compute(password, salt);
             */
            compute: function(password, salt) {
              var block;
              var cfg = this.cfg;
              var hasher = cfg.hasher.create();
              var derivedKey = WordArray.create();
              var derivedKeyWords = derivedKey.words;
              var keySize = cfg.keySize;
              var iterations = cfg.iterations;
              while (derivedKeyWords.length < keySize) {
                if (block) {
                  hasher.update(block);
                }
                block = hasher.update(password).finalize(salt);
                hasher.reset();
                for (var i = 1; i < iterations; i++) {
                  block = hasher.finalize(block);
                  hasher.reset();
                }
                derivedKey.concat(block);
              }
              derivedKey.sigBytes = keySize * 4;
              return derivedKey;
            }
          });
          C.EvpKDF = function(password, salt, cfg) {
            return EvpKDF.create(cfg).compute(password, salt);
          };
        })();
        return CryptoJS.EvpKDF;
      });
    }
  });

  // ../zotero-style/node_modules/crypto-js/cipher-core.js
  var require_cipher_core = __commonJS({
    "../zotero-style/node_modules/crypto-js/cipher-core.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_evpkdf());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./evpkdf"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        CryptoJS.lib.Cipher || function(undefined2) {
          var C = CryptoJS;
          var C_lib = C.lib;
          var Base = C_lib.Base;
          var WordArray = C_lib.WordArray;
          var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
          var C_enc = C.enc;
          var Utf8 = C_enc.Utf8;
          var Base64 = C_enc.Base64;
          var C_algo = C.algo;
          var EvpKDF = C_algo.EvpKDF;
          var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
            /**
             * Configuration options.
             *
             * @property {WordArray} iv The IV to use for this operation.
             */
            cfg: Base.extend(),
            /**
             * Creates this cipher in encryption mode.
             *
             * @param {WordArray} key The key.
             * @param {Object} cfg (Optional) The configuration options to use for this operation.
             *
             * @return {Cipher} A cipher instance.
             *
             * @static
             *
             * @example
             *
             *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
             */
            createEncryptor: function(key, cfg) {
              return this.create(this._ENC_XFORM_MODE, key, cfg);
            },
            /**
             * Creates this cipher in decryption mode.
             *
             * @param {WordArray} key The key.
             * @param {Object} cfg (Optional) The configuration options to use for this operation.
             *
             * @return {Cipher} A cipher instance.
             *
             * @static
             *
             * @example
             *
             *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
             */
            createDecryptor: function(key, cfg) {
              return this.create(this._DEC_XFORM_MODE, key, cfg);
            },
            /**
             * Initializes a newly created cipher.
             *
             * @param {number} xformMode Either the encryption or decryption transormation mode constant.
             * @param {WordArray} key The key.
             * @param {Object} cfg (Optional) The configuration options to use for this operation.
             *
             * @example
             *
             *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
             */
            init: function(xformMode, key, cfg) {
              this.cfg = this.cfg.extend(cfg);
              this._xformMode = xformMode;
              this._key = key;
              this.reset();
            },
            /**
             * Resets this cipher to its initial state.
             *
             * @example
             *
             *     cipher.reset();
             */
            reset: function() {
              BufferedBlockAlgorithm.reset.call(this);
              this._doReset();
            },
            /**
             * Adds data to be encrypted or decrypted.
             *
             * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
             *
             * @return {WordArray} The data after processing.
             *
             * @example
             *
             *     var encrypted = cipher.process('data');
             *     var encrypted = cipher.process(wordArray);
             */
            process: function(dataUpdate) {
              this._append(dataUpdate);
              return this._process();
            },
            /**
             * Finalizes the encryption or decryption process.
             * Note that the finalize operation is effectively a destructive, read-once operation.
             *
             * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
             *
             * @return {WordArray} The data after final processing.
             *
             * @example
             *
             *     var encrypted = cipher.finalize();
             *     var encrypted = cipher.finalize('data');
             *     var encrypted = cipher.finalize(wordArray);
             */
            finalize: function(dataUpdate) {
              if (dataUpdate) {
                this._append(dataUpdate);
              }
              var finalProcessedData = this._doFinalize();
              return finalProcessedData;
            },
            keySize: 128 / 32,
            ivSize: 128 / 32,
            _ENC_XFORM_MODE: 1,
            _DEC_XFORM_MODE: 2,
            /**
             * Creates shortcut functions to a cipher's object interface.
             *
             * @param {Cipher} cipher The cipher to create a helper for.
             *
             * @return {Object} An object with encrypt and decrypt shortcut functions.
             *
             * @static
             *
             * @example
             *
             *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
             */
            _createHelper: function() {
              function selectCipherStrategy(key) {
                if (typeof key == "string") {
                  return PasswordBasedCipher;
                } else {
                  return SerializableCipher;
                }
              }
              return function(cipher) {
                return {
                  encrypt: function(message, key, cfg) {
                    return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                  },
                  decrypt: function(ciphertext, key, cfg) {
                    return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                  }
                };
              };
            }()
          });
          var StreamCipher = C_lib.StreamCipher = Cipher.extend({
            _doFinalize: function() {
              var finalProcessedBlocks = this._process(true);
              return finalProcessedBlocks;
            },
            blockSize: 1
          });
          var C_mode = C.mode = {};
          var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
            /**
             * Creates this mode for encryption.
             *
             * @param {Cipher} cipher A block cipher instance.
             * @param {Array} iv The IV words.
             *
             * @static
             *
             * @example
             *
             *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
             */
            createEncryptor: function(cipher, iv) {
              return this.Encryptor.create(cipher, iv);
            },
            /**
             * Creates this mode for decryption.
             *
             * @param {Cipher} cipher A block cipher instance.
             * @param {Array} iv The IV words.
             *
             * @static
             *
             * @example
             *
             *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
             */
            createDecryptor: function(cipher, iv) {
              return this.Decryptor.create(cipher, iv);
            },
            /**
             * Initializes a newly created mode.
             *
             * @param {Cipher} cipher A block cipher instance.
             * @param {Array} iv The IV words.
             *
             * @example
             *
             *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
             */
            init: function(cipher, iv) {
              this._cipher = cipher;
              this._iv = iv;
            }
          });
          var CBC = C_mode.CBC = function() {
            var CBC2 = BlockCipherMode.extend();
            CBC2.Encryptor = CBC2.extend({
              /**
               * Processes the data block at offset.
               *
               * @param {Array} words The data words to operate on.
               * @param {number} offset The offset where the block starts.
               *
               * @example
               *
               *     mode.processBlock(data.words, offset);
               */
              processBlock: function(words, offset) {
                var cipher = this._cipher;
                var blockSize = cipher.blockSize;
                xorBlock.call(this, words, offset, blockSize);
                cipher.encryptBlock(words, offset);
                this._prevBlock = words.slice(offset, offset + blockSize);
              }
            });
            CBC2.Decryptor = CBC2.extend({
              /**
               * Processes the data block at offset.
               *
               * @param {Array} words The data words to operate on.
               * @param {number} offset The offset where the block starts.
               *
               * @example
               *
               *     mode.processBlock(data.words, offset);
               */
              processBlock: function(words, offset) {
                var cipher = this._cipher;
                var blockSize = cipher.blockSize;
                var thisBlock = words.slice(offset, offset + blockSize);
                cipher.decryptBlock(words, offset);
                xorBlock.call(this, words, offset, blockSize);
                this._prevBlock = thisBlock;
              }
            });
            function xorBlock(words, offset, blockSize) {
              var block;
              var iv = this._iv;
              if (iv) {
                block = iv;
                this._iv = undefined2;
              } else {
                block = this._prevBlock;
              }
              for (var i = 0; i < blockSize; i++) {
                words[offset + i] ^= block[i];
              }
            }
            return CBC2;
          }();
          var C_pad = C.pad = {};
          var Pkcs7 = C_pad.Pkcs7 = {
            /**
             * Pads data using the algorithm defined in PKCS #5/7.
             *
             * @param {WordArray} data The data to pad.
             * @param {number} blockSize The multiple that the data should be padded to.
             *
             * @static
             *
             * @example
             *
             *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
             */
            pad: function(data, blockSize) {
              var blockSizeBytes = blockSize * 4;
              var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
              var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
              var paddingWords = [];
              for (var i = 0; i < nPaddingBytes; i += 4) {
                paddingWords.push(paddingWord);
              }
              var padding = WordArray.create(paddingWords, nPaddingBytes);
              data.concat(padding);
            },
            /**
             * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
             *
             * @param {WordArray} data The data to unpad.
             *
             * @static
             *
             * @example
             *
             *     CryptoJS.pad.Pkcs7.unpad(wordArray);
             */
            unpad: function(data) {
              var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
              data.sigBytes -= nPaddingBytes;
            }
          };
          var BlockCipher = C_lib.BlockCipher = Cipher.extend({
            /**
             * Configuration options.
             *
             * @property {Mode} mode The block mode to use. Default: CBC
             * @property {Padding} padding The padding strategy to use. Default: Pkcs7
             */
            cfg: Cipher.cfg.extend({
              mode: CBC,
              padding: Pkcs7
            }),
            reset: function() {
              var modeCreator;
              Cipher.reset.call(this);
              var cfg = this.cfg;
              var iv = cfg.iv;
              var mode = cfg.mode;
              if (this._xformMode == this._ENC_XFORM_MODE) {
                modeCreator = mode.createEncryptor;
              } else {
                modeCreator = mode.createDecryptor;
                this._minBufferSize = 1;
              }
              if (this._mode && this._mode.__creator == modeCreator) {
                this._mode.init(this, iv && iv.words);
              } else {
                this._mode = modeCreator.call(mode, this, iv && iv.words);
                this._mode.__creator = modeCreator;
              }
            },
            _doProcessBlock: function(words, offset) {
              this._mode.processBlock(words, offset);
            },
            _doFinalize: function() {
              var finalProcessedBlocks;
              var padding = this.cfg.padding;
              if (this._xformMode == this._ENC_XFORM_MODE) {
                padding.pad(this._data, this.blockSize);
                finalProcessedBlocks = this._process(true);
              } else {
                finalProcessedBlocks = this._process(true);
                padding.unpad(finalProcessedBlocks);
              }
              return finalProcessedBlocks;
            },
            blockSize: 128 / 32
          });
          var CipherParams = C_lib.CipherParams = Base.extend({
            /**
             * Initializes a newly created cipher params object.
             *
             * @param {Object} cipherParams An object with any of the possible cipher parameters.
             *
             * @example
             *
             *     var cipherParams = CryptoJS.lib.CipherParams.create({
             *         ciphertext: ciphertextWordArray,
             *         key: keyWordArray,
             *         iv: ivWordArray,
             *         salt: saltWordArray,
             *         algorithm: CryptoJS.algo.AES,
             *         mode: CryptoJS.mode.CBC,
             *         padding: CryptoJS.pad.PKCS7,
             *         blockSize: 4,
             *         formatter: CryptoJS.format.OpenSSL
             *     });
             */
            init: function(cipherParams) {
              this.mixIn(cipherParams);
            },
            /**
             * Converts this cipher params object to a string.
             *
             * @param {Format} formatter (Optional) The formatting strategy to use.
             *
             * @return {string} The stringified cipher params.
             *
             * @throws Error If neither the formatter nor the default formatter is set.
             *
             * @example
             *
             *     var string = cipherParams + '';
             *     var string = cipherParams.toString();
             *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
             */
            toString: function(formatter) {
              return (formatter || this.formatter).stringify(this);
            }
          });
          var C_format = C.format = {};
          var OpenSSLFormatter = C_format.OpenSSL = {
            /**
             * Converts a cipher params object to an OpenSSL-compatible string.
             *
             * @param {CipherParams} cipherParams The cipher params object.
             *
             * @return {string} The OpenSSL-compatible string.
             *
             * @static
             *
             * @example
             *
             *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
             */
            stringify: function(cipherParams) {
              var wordArray;
              var ciphertext = cipherParams.ciphertext;
              var salt = cipherParams.salt;
              if (salt) {
                wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
              } else {
                wordArray = ciphertext;
              }
              return wordArray.toString(Base64);
            },
            /**
             * Converts an OpenSSL-compatible string to a cipher params object.
             *
             * @param {string} openSSLStr The OpenSSL-compatible string.
             *
             * @return {CipherParams} The cipher params object.
             *
             * @static
             *
             * @example
             *
             *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
             */
            parse: function(openSSLStr) {
              var salt;
              var ciphertext = Base64.parse(openSSLStr);
              var ciphertextWords = ciphertext.words;
              if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
                salt = WordArray.create(ciphertextWords.slice(2, 4));
                ciphertextWords.splice(0, 4);
                ciphertext.sigBytes -= 16;
              }
              return CipherParams.create({ ciphertext, salt });
            }
          };
          var SerializableCipher = C_lib.SerializableCipher = Base.extend({
            /**
             * Configuration options.
             *
             * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
             */
            cfg: Base.extend({
              format: OpenSSLFormatter
            }),
            /**
             * Encrypts a message.
             *
             * @param {Cipher} cipher The cipher algorithm to use.
             * @param {WordArray|string} message The message to encrypt.
             * @param {WordArray} key The key.
             * @param {Object} cfg (Optional) The configuration options to use for this operation.
             *
             * @return {CipherParams} A cipher params object.
             *
             * @static
             *
             * @example
             *
             *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
             *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
             *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
             */
            encrypt: function(cipher, message, key, cfg) {
              cfg = this.cfg.extend(cfg);
              var encryptor = cipher.createEncryptor(key, cfg);
              var ciphertext = encryptor.finalize(message);
              var cipherCfg = encryptor.cfg;
              return CipherParams.create({
                ciphertext,
                key,
                iv: cipherCfg.iv,
                algorithm: cipher,
                mode: cipherCfg.mode,
                padding: cipherCfg.padding,
                blockSize: cipher.blockSize,
                formatter: cfg.format
              });
            },
            /**
             * Decrypts serialized ciphertext.
             *
             * @param {Cipher} cipher The cipher algorithm to use.
             * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
             * @param {WordArray} key The key.
             * @param {Object} cfg (Optional) The configuration options to use for this operation.
             *
             * @return {WordArray} The plaintext.
             *
             * @static
             *
             * @example
             *
             *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
             *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
             */
            decrypt: function(cipher, ciphertext, key, cfg) {
              cfg = this.cfg.extend(cfg);
              ciphertext = this._parse(ciphertext, cfg.format);
              var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
              return plaintext;
            },
            /**
             * Converts serialized ciphertext to CipherParams,
             * else assumed CipherParams already and returns ciphertext unchanged.
             *
             * @param {CipherParams|string} ciphertext The ciphertext.
             * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
             *
             * @return {CipherParams} The unserialized ciphertext.
             *
             * @static
             *
             * @example
             *
             *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
             */
            _parse: function(ciphertext, format) {
              if (typeof ciphertext == "string") {
                return format.parse(ciphertext, this);
              } else {
                return ciphertext;
              }
            }
          });
          var C_kdf = C.kdf = {};
          var OpenSSLKdf = C_kdf.OpenSSL = {
            /**
             * Derives a key and IV from a password.
             *
             * @param {string} password The password to derive from.
             * @param {number} keySize The size in words of the key to generate.
             * @param {number} ivSize The size in words of the IV to generate.
             * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
             *
             * @return {CipherParams} A cipher params object with the key, IV, and salt.
             *
             * @static
             *
             * @example
             *
             *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
             *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
             */
            execute: function(password, keySize, ivSize, salt) {
              if (!salt) {
                salt = WordArray.random(64 / 8);
              }
              var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
              var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
              key.sigBytes = keySize * 4;
              return CipherParams.create({ key, iv, salt });
            }
          };
          var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
            /**
             * Configuration options.
             *
             * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
             */
            cfg: SerializableCipher.cfg.extend({
              kdf: OpenSSLKdf
            }),
            /**
             * Encrypts a message using a password.
             *
             * @param {Cipher} cipher The cipher algorithm to use.
             * @param {WordArray|string} message The message to encrypt.
             * @param {string} password The password.
             * @param {Object} cfg (Optional) The configuration options to use for this operation.
             *
             * @return {CipherParams} A cipher params object.
             *
             * @static
             *
             * @example
             *
             *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
             *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
             */
            encrypt: function(cipher, message, password, cfg) {
              cfg = this.cfg.extend(cfg);
              var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);
              cfg.iv = derivedParams.iv;
              var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
              ciphertext.mixIn(derivedParams);
              return ciphertext;
            },
            /**
             * Decrypts serialized ciphertext using a password.
             *
             * @param {Cipher} cipher The cipher algorithm to use.
             * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
             * @param {string} password The password.
             * @param {Object} cfg (Optional) The configuration options to use for this operation.
             *
             * @return {WordArray} The plaintext.
             *
             * @static
             *
             * @example
             *
             *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
             *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
             */
            decrypt: function(cipher, ciphertext, password, cfg) {
              cfg = this.cfg.extend(cfg);
              ciphertext = this._parse(ciphertext, cfg.format);
              var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);
              cfg.iv = derivedParams.iv;
              var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
              return plaintext;
            }
          });
        }();
      });
    }
  });

  // ../zotero-style/node_modules/crypto-js/mode-cfb.js
  var require_mode_cfb = __commonJS({
    "../zotero-style/node_modules/crypto-js/mode-cfb.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_cipher_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./cipher-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        CryptoJS.mode.CFB = function() {
          var CFB = CryptoJS.lib.BlockCipherMode.extend();
          CFB.Encryptor = CFB.extend({
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
              this._prevBlock = words.slice(offset, offset + blockSize);
            }
          });
          CFB.Decryptor = CFB.extend({
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var thisBlock = words.slice(offset, offset + blockSize);
              generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
              this._prevBlock = thisBlock;
            }
          });
          function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
            var keystream;
            var iv = this._iv;
            if (iv) {
              keystream = iv.slice(0);
              this._iv = void 0;
            } else {
              keystream = this._prevBlock;
            }
            cipher.encryptBlock(keystream, 0);
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= keystream[i];
            }
          }
          return CFB;
        }();
        return CryptoJS.mode.CFB;
      });
    }
  });

  // ../zotero-style/node_modules/crypto-js/mode-ctr.js
  var require_mode_ctr = __commonJS({
    "../zotero-style/node_modules/crypto-js/mode-ctr.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_cipher_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./cipher-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        CryptoJS.mode.CTR = function() {
          var CTR = CryptoJS.lib.BlockCipherMode.extend();
          var Encryptor = CTR.Encryptor = CTR.extend({
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var iv = this._iv;
              var counter = this._counter;
              if (iv) {
                counter = this._counter = iv.slice(0);
                this._iv = void 0;
              }
              var keystream = counter.slice(0);
              cipher.encryptBlock(keystream, 0);
              counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
              for (var i = 0; i < blockSize; i++) {
                words[offset + i] ^= keystream[i];
              }
            }
          });
          CTR.Decryptor = Encryptor;
          return CTR;
        }();
        return CryptoJS.mode.CTR;
      });
    }
  });

  // ../zotero-style/node_modules/crypto-js/mode-ctr-gladman.js
  var require_mode_ctr_gladman = __commonJS({
    "../zotero-style/node_modules/crypto-js/mode-ctr-gladman.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_cipher_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./cipher-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        CryptoJS.mode.CTRGladman = function() {
          var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();
          function incWord(word) {
            if ((word >> 24 & 255) === 255) {
              var b1 = word >> 16 & 255;
              var b2 = word >> 8 & 255;
              var b3 = word & 255;
              if (b1 === 255) {
                b1 = 0;
                if (b2 === 255) {
                  b2 = 0;
                  if (b3 === 255) {
                    b3 = 0;
                  } else {
                    ++b3;
                  }
                } else {
                  ++b2;
                }
              } else {
                ++b1;
              }
              word = 0;
              word += b1 << 16;
              word += b2 << 8;
              word += b3;
            } else {
              word += 1 << 24;
            }
            return word;
          }
          function incCounter(counter) {
            if ((counter[0] = incWord(counter[0])) === 0) {
              counter[1] = incWord(counter[1]);
            }
            return counter;
          }
          var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var iv = this._iv;
              var counter = this._counter;
              if (iv) {
                counter = this._counter = iv.slice(0);
                this._iv = void 0;
              }
              incCounter(counter);
              var keystream = counter.slice(0);
              cipher.encryptBlock(keystream, 0);
              for (var i = 0; i < blockSize; i++) {
                words[offset + i] ^= keystream[i];
              }
            }
          });
          CTRGladman.Decryptor = Encryptor;
          return CTRGladman;
        }();
        return CryptoJS.mode.CTRGladman;
      });
    }
  });

  // ../zotero-style/node_modules/crypto-js/mode-ofb.js
  var require_mode_ofb = __commonJS({
    "../zotero-style/node_modules/crypto-js/mode-ofb.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_cipher_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./cipher-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        CryptoJS.mode.OFB = function() {
          var OFB = CryptoJS.lib.BlockCipherMode.extend();
          var Encryptor = OFB.Encryptor = OFB.extend({
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var iv = this._iv;
              var keystream = this._keystream;
              if (iv) {
                keystream = this._keystream = iv.slice(0);
                this._iv = void 0;
              }
              cipher.encryptBlock(keystream, 0);
              for (var i = 0; i < blockSize; i++) {
                words[offset + i] ^= keystream[i];
              }
            }
          });
          OFB.Decryptor = Encryptor;
          return OFB;
        }();
        return CryptoJS.mode.OFB;
      });
    }
  });

  // ../zotero-style/node_modules/crypto-js/mode-ecb.js
  var require_mode_ecb = __commonJS({
    "../zotero-style/node_modules/crypto-js/mode-ecb.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_cipher_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./cipher-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        CryptoJS.mode.ECB = function() {
          var ECB = CryptoJS.lib.BlockCipherMode.extend();
          ECB.Encryptor = ECB.extend({
            processBlock: function(words, offset) {
              this._cipher.encryptBlock(words, offset);
            }
          });
          ECB.Decryptor = ECB.extend({
            processBlock: function(words, offset) {
              this._cipher.decryptBlock(words, offset);
            }
          });
          return ECB;
        }();
        return CryptoJS.mode.ECB;
      });
    }
  });

  // ../zotero-style/node_modules/crypto-js/pad-ansix923.js
  var require_pad_ansix923 = __commonJS({
    "../zotero-style/node_modules/crypto-js/pad-ansix923.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_cipher_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./cipher-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        CryptoJS.pad.AnsiX923 = {
          pad: function(data, blockSize) {
            var dataSigBytes = data.sigBytes;
            var blockSizeBytes = blockSize * 4;
            var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
            var lastBytePos = dataSigBytes + nPaddingBytes - 1;
            data.clamp();
            data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
            data.sigBytes += nPaddingBytes;
          },
          unpad: function(data) {
            var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
            data.sigBytes -= nPaddingBytes;
          }
        };
        return CryptoJS.pad.Ansix923;
      });
    }
  });

  // ../zotero-style/node_modules/crypto-js/pad-iso10126.js
  var require_pad_iso10126 = __commonJS({
    "../zotero-style/node_modules/crypto-js/pad-iso10126.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_cipher_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./cipher-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        CryptoJS.pad.Iso10126 = {
          pad: function(data, blockSize) {
            var blockSizeBytes = blockSize * 4;
            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
            data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
          },
          unpad: function(data) {
            var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
            data.sigBytes -= nPaddingBytes;
          }
        };
        return CryptoJS.pad.Iso10126;
      });
    }
  });

  // ../zotero-style/node_modules/crypto-js/pad-iso97971.js
  var require_pad_iso97971 = __commonJS({
    "../zotero-style/node_modules/crypto-js/pad-iso97971.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_cipher_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./cipher-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        CryptoJS.pad.Iso97971 = {
          pad: function(data, blockSize) {
            data.concat(CryptoJS.lib.WordArray.create([2147483648], 1));
            CryptoJS.pad.ZeroPadding.pad(data, blockSize);
          },
          unpad: function(data) {
            CryptoJS.pad.ZeroPadding.unpad(data);
            data.sigBytes--;
          }
        };
        return CryptoJS.pad.Iso97971;
      });
    }
  });

  // ../zotero-style/node_modules/crypto-js/pad-zeropadding.js
  var require_pad_zeropadding = __commonJS({
    "../zotero-style/node_modules/crypto-js/pad-zeropadding.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_cipher_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./cipher-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        CryptoJS.pad.ZeroPadding = {
          pad: function(data, blockSize) {
            var blockSizeBytes = blockSize * 4;
            data.clamp();
            data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);
          },
          unpad: function(data) {
            var dataWords = data.words;
            var i = data.sigBytes - 1;
            for (var i = data.sigBytes - 1; i >= 0; i--) {
              if (dataWords[i >>> 2] >>> 24 - i % 4 * 8 & 255) {
                data.sigBytes = i + 1;
                break;
              }
            }
          }
        };
        return CryptoJS.pad.ZeroPadding;
      });
    }
  });

  // ../zotero-style/node_modules/crypto-js/pad-nopadding.js
  var require_pad_nopadding = __commonJS({
    "../zotero-style/node_modules/crypto-js/pad-nopadding.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_cipher_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./cipher-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        CryptoJS.pad.NoPadding = {
          pad: function() {
          },
          unpad: function() {
          }
        };
        return CryptoJS.pad.NoPadding;
      });
    }
  });

  // ../zotero-style/node_modules/crypto-js/format-hex.js
  var require_format_hex = __commonJS({
    "../zotero-style/node_modules/crypto-js/format-hex.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_cipher_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./cipher-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function(undefined2) {
          var C = CryptoJS;
          var C_lib = C.lib;
          var CipherParams = C_lib.CipherParams;
          var C_enc = C.enc;
          var Hex = C_enc.Hex;
          var C_format = C.format;
          var HexFormatter = C_format.Hex = {
            /**
             * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
             *
             * @param {CipherParams} cipherParams The cipher params object.
             *
             * @return {string} The hexadecimally encoded string.
             *
             * @static
             *
             * @example
             *
             *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
             */
            stringify: function(cipherParams) {
              return cipherParams.ciphertext.toString(Hex);
            },
            /**
             * Converts a hexadecimally encoded ciphertext string to a cipher params object.
             *
             * @param {string} input The hexadecimally encoded string.
             *
             * @return {CipherParams} The cipher params object.
             *
             * @static
             *
             * @example
             *
             *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
             */
            parse: function(input) {
              var ciphertext = Hex.parse(input);
              return CipherParams.create({ ciphertext });
            }
          };
        })();
        return CryptoJS.format.Hex;
      });
    }
  });

  // ../zotero-style/node_modules/crypto-js/aes.js
  var require_aes = __commonJS({
    "../zotero-style/node_modules/crypto-js/aes.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function() {
          var C = CryptoJS;
          var C_lib = C.lib;
          var BlockCipher = C_lib.BlockCipher;
          var C_algo = C.algo;
          var SBOX = [];
          var INV_SBOX = [];
          var SUB_MIX_0 = [];
          var SUB_MIX_1 = [];
          var SUB_MIX_2 = [];
          var SUB_MIX_3 = [];
          var INV_SUB_MIX_0 = [];
          var INV_SUB_MIX_1 = [];
          var INV_SUB_MIX_2 = [];
          var INV_SUB_MIX_3 = [];
          (function() {
            var d = [];
            for (var i = 0; i < 256; i++) {
              if (i < 128) {
                d[i] = i << 1;
              } else {
                d[i] = i << 1 ^ 283;
              }
            }
            var x = 0;
            var xi = 0;
            for (var i = 0; i < 256; i++) {
              var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
              sx = sx >>> 8 ^ sx & 255 ^ 99;
              SBOX[x] = sx;
              INV_SBOX[sx] = x;
              var x2 = d[x];
              var x4 = d[x2];
              var x8 = d[x4];
              var t = d[sx] * 257 ^ sx * 16843008;
              SUB_MIX_0[x] = t << 24 | t >>> 8;
              SUB_MIX_1[x] = t << 16 | t >>> 16;
              SUB_MIX_2[x] = t << 8 | t >>> 24;
              SUB_MIX_3[x] = t;
              var t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
              INV_SUB_MIX_0[sx] = t << 24 | t >>> 8;
              INV_SUB_MIX_1[sx] = t << 16 | t >>> 16;
              INV_SUB_MIX_2[sx] = t << 8 | t >>> 24;
              INV_SUB_MIX_3[sx] = t;
              if (!x) {
                x = xi = 1;
              } else {
                x = x2 ^ d[d[d[x8 ^ x2]]];
                xi ^= d[d[xi]];
              }
            }
          })();
          var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
          var AES2 = C_algo.AES = BlockCipher.extend({
            _doReset: function() {
              var t;
              if (this._nRounds && this._keyPriorReset === this._key) {
                return;
              }
              var key = this._keyPriorReset = this._key;
              var keyWords = key.words;
              var keySize = key.sigBytes / 4;
              var nRounds = this._nRounds = keySize + 6;
              var ksRows = (nRounds + 1) * 4;
              var keySchedule = this._keySchedule = [];
              for (var ksRow = 0; ksRow < ksRows; ksRow++) {
                if (ksRow < keySize) {
                  keySchedule[ksRow] = keyWords[ksRow];
                } else {
                  t = keySchedule[ksRow - 1];
                  if (!(ksRow % keySize)) {
                    t = t << 8 | t >>> 24;
                    t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
                    t ^= RCON[ksRow / keySize | 0] << 24;
                  } else if (keySize > 6 && ksRow % keySize == 4) {
                    t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
                  }
                  keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
                }
              }
              var invKeySchedule = this._invKeySchedule = [];
              for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
                var ksRow = ksRows - invKsRow;
                if (invKsRow % 4) {
                  var t = keySchedule[ksRow];
                } else {
                  var t = keySchedule[ksRow - 4];
                }
                if (invKsRow < 4 || ksRow <= 4) {
                  invKeySchedule[invKsRow] = t;
                } else {
                  invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[t >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t & 255]];
                }
              }
            },
            encryptBlock: function(M, offset) {
              this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
            },
            decryptBlock: function(M, offset) {
              var t = M[offset + 1];
              M[offset + 1] = M[offset + 3];
              M[offset + 3] = t;
              this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
              var t = M[offset + 1];
              M[offset + 1] = M[offset + 3];
              M[offset + 3] = t;
            },
            _doCryptBlock: function(M, offset, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
              var nRounds = this._nRounds;
              var s0 = M[offset] ^ keySchedule[0];
              var s1 = M[offset + 1] ^ keySchedule[1];
              var s2 = M[offset + 2] ^ keySchedule[2];
              var s3 = M[offset + 3] ^ keySchedule[3];
              var ksRow = 4;
              for (var round = 1; round < nRounds; round++) {
                var t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s2 >>> 8 & 255] ^ SUB_MIX_32[s3 & 255] ^ keySchedule[ksRow++];
                var t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s2 >>> 16 & 255] ^ SUB_MIX_22[s3 >>> 8 & 255] ^ SUB_MIX_32[s0 & 255] ^ keySchedule[ksRow++];
                var t2 = SUB_MIX_02[s2 >>> 24] ^ SUB_MIX_12[s3 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
                var t3 = SUB_MIX_02[s3 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s2 & 255] ^ keySchedule[ksRow++];
                s0 = t0;
                s1 = t1;
                s2 = t2;
                s3 = t3;
              }
              var t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s2 >>> 8 & 255] << 8 | SBOX2[s3 & 255]) ^ keySchedule[ksRow++];
              var t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s2 >>> 16 & 255] << 16 | SBOX2[s3 >>> 8 & 255] << 8 | SBOX2[s0 & 255]) ^ keySchedule[ksRow++];
              var t2 = (SBOX2[s2 >>> 24] << 24 | SBOX2[s3 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
              var t3 = (SBOX2[s3 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s2 & 255]) ^ keySchedule[ksRow++];
              M[offset] = t0;
              M[offset + 1] = t1;
              M[offset + 2] = t2;
              M[offset + 3] = t3;
            },
            keySize: 256 / 32
          });
          C.AES = BlockCipher._createHelper(AES2);
        })();
        return CryptoJS.AES;
      });
    }
  });

  // ../zotero-style/node_modules/crypto-js/tripledes.js
  var require_tripledes = __commonJS({
    "../zotero-style/node_modules/crypto-js/tripledes.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function() {
          var C = CryptoJS;
          var C_lib = C.lib;
          var WordArray = C_lib.WordArray;
          var BlockCipher = C_lib.BlockCipher;
          var C_algo = C.algo;
          var PC1 = [
            57,
            49,
            41,
            33,
            25,
            17,
            9,
            1,
            58,
            50,
            42,
            34,
            26,
            18,
            10,
            2,
            59,
            51,
            43,
            35,
            27,
            19,
            11,
            3,
            60,
            52,
            44,
            36,
            63,
            55,
            47,
            39,
            31,
            23,
            15,
            7,
            62,
            54,
            46,
            38,
            30,
            22,
            14,
            6,
            61,
            53,
            45,
            37,
            29,
            21,
            13,
            5,
            28,
            20,
            12,
            4
          ];
          var PC2 = [
            14,
            17,
            11,
            24,
            1,
            5,
            3,
            28,
            15,
            6,
            21,
            10,
            23,
            19,
            12,
            4,
            26,
            8,
            16,
            7,
            27,
            20,
            13,
            2,
            41,
            52,
            31,
            37,
            47,
            55,
            30,
            40,
            51,
            45,
            33,
            48,
            44,
            49,
            39,
            56,
            34,
            53,
            46,
            42,
            50,
            36,
            29,
            32
          ];
          var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
          var SBOX_P = [
            {
              0: 8421888,
              268435456: 32768,
              536870912: 8421378,
              805306368: 2,
              1073741824: 512,
              1342177280: 8421890,
              1610612736: 8389122,
              1879048192: 8388608,
              2147483648: 514,
              2415919104: 8389120,
              2684354560: 33280,
              2952790016: 8421376,
              3221225472: 32770,
              3489660928: 8388610,
              3758096384: 0,
              4026531840: 33282,
              134217728: 0,
              402653184: 8421890,
              671088640: 33282,
              939524096: 32768,
              1207959552: 8421888,
              1476395008: 512,
              1744830464: 8421378,
              2013265920: 2,
              2281701376: 8389120,
              2550136832: 33280,
              2818572288: 8421376,
              3087007744: 8389122,
              3355443200: 8388610,
              3623878656: 32770,
              3892314112: 514,
              4160749568: 8388608,
              1: 32768,
              268435457: 2,
              536870913: 8421888,
              805306369: 8388608,
              1073741825: 8421378,
              1342177281: 33280,
              1610612737: 512,
              1879048193: 8389122,
              2147483649: 8421890,
              2415919105: 8421376,
              2684354561: 8388610,
              2952790017: 33282,
              3221225473: 514,
              3489660929: 8389120,
              3758096385: 32770,
              4026531841: 0,
              134217729: 8421890,
              402653185: 8421376,
              671088641: 8388608,
              939524097: 512,
              1207959553: 32768,
              1476395009: 8388610,
              1744830465: 2,
              2013265921: 33282,
              2281701377: 32770,
              2550136833: 8389122,
              2818572289: 514,
              3087007745: 8421888,
              3355443201: 8389120,
              3623878657: 0,
              3892314113: 33280,
              4160749569: 8421378
            },
            {
              0: 1074282512,
              16777216: 16384,
              33554432: 524288,
              50331648: 1074266128,
              67108864: 1073741840,
              83886080: 1074282496,
              100663296: 1073758208,
              117440512: 16,
              134217728: 540672,
              150994944: 1073758224,
              167772160: 1073741824,
              184549376: 540688,
              201326592: 524304,
              218103808: 0,
              234881024: 16400,
              251658240: 1074266112,
              8388608: 1073758208,
              25165824: 540688,
              41943040: 16,
              58720256: 1073758224,
              75497472: 1074282512,
              92274688: 1073741824,
              109051904: 524288,
              125829120: 1074266128,
              142606336: 524304,
              159383552: 0,
              176160768: 16384,
              192937984: 1074266112,
              209715200: 1073741840,
              226492416: 540672,
              243269632: 1074282496,
              260046848: 16400,
              268435456: 0,
              285212672: 1074266128,
              301989888: 1073758224,
              318767104: 1074282496,
              335544320: 1074266112,
              352321536: 16,
              369098752: 540688,
              385875968: 16384,
              402653184: 16400,
              419430400: 524288,
              436207616: 524304,
              452984832: 1073741840,
              469762048: 540672,
              486539264: 1073758208,
              503316480: 1073741824,
              520093696: 1074282512,
              276824064: 540688,
              293601280: 524288,
              310378496: 1074266112,
              327155712: 16384,
              343932928: 1073758208,
              360710144: 1074282512,
              377487360: 16,
              394264576: 1073741824,
              411041792: 1074282496,
              427819008: 1073741840,
              444596224: 1073758224,
              461373440: 524304,
              478150656: 0,
              494927872: 16400,
              511705088: 1074266128,
              528482304: 540672
            },
            {
              0: 260,
              1048576: 0,
              2097152: 67109120,
              3145728: 65796,
              4194304: 65540,
              5242880: 67108868,
              6291456: 67174660,
              7340032: 67174400,
              8388608: 67108864,
              9437184: 67174656,
              10485760: 65792,
              11534336: 67174404,
              12582912: 67109124,
              13631488: 65536,
              14680064: 4,
              15728640: 256,
              524288: 67174656,
              1572864: 67174404,
              2621440: 0,
              3670016: 67109120,
              4718592: 67108868,
              5767168: 65536,
              6815744: 65540,
              7864320: 260,
              8912896: 4,
              9961472: 256,
              11010048: 67174400,
              12058624: 65796,
              13107200: 65792,
              14155776: 67109124,
              15204352: 67174660,
              16252928: 67108864,
              16777216: 67174656,
              17825792: 65540,
              18874368: 65536,
              19922944: 67109120,
              20971520: 256,
              22020096: 67174660,
              23068672: 67108868,
              24117248: 0,
              25165824: 67109124,
              26214400: 67108864,
              27262976: 4,
              28311552: 65792,
              29360128: 67174400,
              30408704: 260,
              31457280: 65796,
              32505856: 67174404,
              17301504: 67108864,
              18350080: 260,
              19398656: 67174656,
              20447232: 0,
              21495808: 65540,
              22544384: 67109120,
              23592960: 256,
              24641536: 67174404,
              25690112: 65536,
              26738688: 67174660,
              27787264: 65796,
              28835840: 67108868,
              29884416: 67109124,
              30932992: 67174400,
              31981568: 4,
              33030144: 65792
            },
            {
              0: 2151682048,
              65536: 2147487808,
              131072: 4198464,
              196608: 2151677952,
              262144: 0,
              327680: 4198400,
              393216: 2147483712,
              458752: 4194368,
              524288: 2147483648,
              589824: 4194304,
              655360: 64,
              720896: 2147487744,
              786432: 2151678016,
              851968: 4160,
              917504: 4096,
              983040: 2151682112,
              32768: 2147487808,
              98304: 64,
              163840: 2151678016,
              229376: 2147487744,
              294912: 4198400,
              360448: 2151682112,
              425984: 0,
              491520: 2151677952,
              557056: 4096,
              622592: 2151682048,
              688128: 4194304,
              753664: 4160,
              819200: 2147483648,
              884736: 4194368,
              950272: 4198464,
              1015808: 2147483712,
              1048576: 4194368,
              1114112: 4198400,
              1179648: 2147483712,
              1245184: 0,
              1310720: 4160,
              1376256: 2151678016,
              1441792: 2151682048,
              1507328: 2147487808,
              1572864: 2151682112,
              1638400: 2147483648,
              1703936: 2151677952,
              1769472: 4198464,
              1835008: 2147487744,
              1900544: 4194304,
              1966080: 64,
              2031616: 4096,
              1081344: 2151677952,
              1146880: 2151682112,
              1212416: 0,
              1277952: 4198400,
              1343488: 4194368,
              1409024: 2147483648,
              1474560: 2147487808,
              1540096: 64,
              1605632: 2147483712,
              1671168: 4096,
              1736704: 2147487744,
              1802240: 2151678016,
              1867776: 4160,
              1933312: 2151682048,
              1998848: 4194304,
              2064384: 4198464
            },
            {
              0: 128,
              4096: 17039360,
              8192: 262144,
              12288: 536870912,
              16384: 537133184,
              20480: 16777344,
              24576: 553648256,
              28672: 262272,
              32768: 16777216,
              36864: 537133056,
              40960: 536871040,
              45056: 553910400,
              49152: 553910272,
              53248: 0,
              57344: 17039488,
              61440: 553648128,
              2048: 17039488,
              6144: 553648256,
              10240: 128,
              14336: 17039360,
              18432: 262144,
              22528: 537133184,
              26624: 553910272,
              30720: 536870912,
              34816: 537133056,
              38912: 0,
              43008: 553910400,
              47104: 16777344,
              51200: 536871040,
              55296: 553648128,
              59392: 16777216,
              63488: 262272,
              65536: 262144,
              69632: 128,
              73728: 536870912,
              77824: 553648256,
              81920: 16777344,
              86016: 553910272,
              90112: 537133184,
              94208: 16777216,
              98304: 553910400,
              102400: 553648128,
              106496: 17039360,
              110592: 537133056,
              114688: 262272,
              118784: 536871040,
              122880: 0,
              126976: 17039488,
              67584: 553648256,
              71680: 16777216,
              75776: 17039360,
              79872: 537133184,
              83968: 536870912,
              88064: 17039488,
              92160: 128,
              96256: 553910272,
              100352: 262272,
              104448: 553910400,
              108544: 0,
              112640: 553648128,
              116736: 16777344,
              120832: 262144,
              124928: 537133056,
              129024: 536871040
            },
            {
              0: 268435464,
              256: 8192,
              512: 270532608,
              768: 270540808,
              1024: 268443648,
              1280: 2097152,
              1536: 2097160,
              1792: 268435456,
              2048: 0,
              2304: 268443656,
              2560: 2105344,
              2816: 8,
              3072: 270532616,
              3328: 2105352,
              3584: 8200,
              3840: 270540800,
              128: 270532608,
              384: 270540808,
              640: 8,
              896: 2097152,
              1152: 2105352,
              1408: 268435464,
              1664: 268443648,
              1920: 8200,
              2176: 2097160,
              2432: 8192,
              2688: 268443656,
              2944: 270532616,
              3200: 0,
              3456: 270540800,
              3712: 2105344,
              3968: 268435456,
              4096: 268443648,
              4352: 270532616,
              4608: 270540808,
              4864: 8200,
              5120: 2097152,
              5376: 268435456,
              5632: 268435464,
              5888: 2105344,
              6144: 2105352,
              6400: 0,
              6656: 8,
              6912: 270532608,
              7168: 8192,
              7424: 268443656,
              7680: 270540800,
              7936: 2097160,
              4224: 8,
              4480: 2105344,
              4736: 2097152,
              4992: 268435464,
              5248: 268443648,
              5504: 8200,
              5760: 270540808,
              6016: 270532608,
              6272: 270540800,
              6528: 270532616,
              6784: 8192,
              7040: 2105352,
              7296: 2097160,
              7552: 0,
              7808: 268435456,
              8064: 268443656
            },
            {
              0: 1048576,
              16: 33555457,
              32: 1024,
              48: 1049601,
              64: 34604033,
              80: 0,
              96: 1,
              112: 34603009,
              128: 33555456,
              144: 1048577,
              160: 33554433,
              176: 34604032,
              192: 34603008,
              208: 1025,
              224: 1049600,
              240: 33554432,
              8: 34603009,
              24: 0,
              40: 33555457,
              56: 34604032,
              72: 1048576,
              88: 33554433,
              104: 33554432,
              120: 1025,
              136: 1049601,
              152: 33555456,
              168: 34603008,
              184: 1048577,
              200: 1024,
              216: 34604033,
              232: 1,
              248: 1049600,
              256: 33554432,
              272: 1048576,
              288: 33555457,
              304: 34603009,
              320: 1048577,
              336: 33555456,
              352: 34604032,
              368: 1049601,
              384: 1025,
              400: 34604033,
              416: 1049600,
              432: 1,
              448: 0,
              464: 34603008,
              480: 33554433,
              496: 1024,
              264: 1049600,
              280: 33555457,
              296: 34603009,
              312: 1,
              328: 33554432,
              344: 1048576,
              360: 1025,
              376: 34604032,
              392: 33554433,
              408: 34603008,
              424: 0,
              440: 34604033,
              456: 1049601,
              472: 1024,
              488: 33555456,
              504: 1048577
            },
            {
              0: 134219808,
              1: 131072,
              2: 134217728,
              3: 32,
              4: 131104,
              5: 134350880,
              6: 134350848,
              7: 2048,
              8: 134348800,
              9: 134219776,
              10: 133120,
              11: 134348832,
              12: 2080,
              13: 0,
              14: 134217760,
              15: 133152,
              2147483648: 2048,
              2147483649: 134350880,
              2147483650: 134219808,
              2147483651: 134217728,
              2147483652: 134348800,
              2147483653: 133120,
              2147483654: 133152,
              2147483655: 32,
              2147483656: 134217760,
              2147483657: 2080,
              2147483658: 131104,
              2147483659: 134350848,
              2147483660: 0,
              2147483661: 134348832,
              2147483662: 134219776,
              2147483663: 131072,
              16: 133152,
              17: 134350848,
              18: 32,
              19: 2048,
              20: 134219776,
              21: 134217760,
              22: 134348832,
              23: 131072,
              24: 0,
              25: 131104,
              26: 134348800,
              27: 134219808,
              28: 134350880,
              29: 133120,
              30: 2080,
              31: 134217728,
              2147483664: 131072,
              2147483665: 2048,
              2147483666: 134348832,
              2147483667: 133152,
              2147483668: 32,
              2147483669: 134348800,
              2147483670: 134217728,
              2147483671: 134219808,
              2147483672: 134350880,
              2147483673: 134217760,
              2147483674: 134219776,
              2147483675: 0,
              2147483676: 133120,
              2147483677: 2080,
              2147483678: 131104,
              2147483679: 134350848
            }
          ];
          var SBOX_MASK = [
            4160749569,
            528482304,
            33030144,
            2064384,
            129024,
            8064,
            504,
            2147483679
          ];
          var DES = C_algo.DES = BlockCipher.extend({
            _doReset: function() {
              var key = this._key;
              var keyWords = key.words;
              var keyBits = [];
              for (var i = 0; i < 56; i++) {
                var keyBitPos = PC1[i] - 1;
                keyBits[i] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
              }
              var subKeys = this._subKeys = [];
              for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
                var subKey = subKeys[nSubKey] = [];
                var bitShift = BIT_SHIFTS[nSubKey];
                for (var i = 0; i < 24; i++) {
                  subKey[i / 6 | 0] |= keyBits[(PC2[i] - 1 + bitShift) % 28] << 31 - i % 6;
                  subKey[4 + (i / 6 | 0)] |= keyBits[28 + (PC2[i + 24] - 1 + bitShift) % 28] << 31 - i % 6;
                }
                subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
                for (var i = 1; i < 7; i++) {
                  subKey[i] = subKey[i] >>> (i - 1) * 4 + 3;
                }
                subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
              }
              var invSubKeys = this._invSubKeys = [];
              for (var i = 0; i < 16; i++) {
                invSubKeys[i] = subKeys[15 - i];
              }
            },
            encryptBlock: function(M, offset) {
              this._doCryptBlock(M, offset, this._subKeys);
            },
            decryptBlock: function(M, offset) {
              this._doCryptBlock(M, offset, this._invSubKeys);
            },
            _doCryptBlock: function(M, offset, subKeys) {
              this._lBlock = M[offset];
              this._rBlock = M[offset + 1];
              exchangeLR.call(this, 4, 252645135);
              exchangeLR.call(this, 16, 65535);
              exchangeRL.call(this, 2, 858993459);
              exchangeRL.call(this, 8, 16711935);
              exchangeLR.call(this, 1, 1431655765);
              for (var round = 0; round < 16; round++) {
                var subKey = subKeys[round];
                var lBlock = this._lBlock;
                var rBlock = this._rBlock;
                var f = 0;
                for (var i = 0; i < 8; i++) {
                  f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
                }
                this._lBlock = rBlock;
                this._rBlock = lBlock ^ f;
              }
              var t = this._lBlock;
              this._lBlock = this._rBlock;
              this._rBlock = t;
              exchangeLR.call(this, 1, 1431655765);
              exchangeRL.call(this, 8, 16711935);
              exchangeRL.call(this, 2, 858993459);
              exchangeLR.call(this, 16, 65535);
              exchangeLR.call(this, 4, 252645135);
              M[offset] = this._lBlock;
              M[offset + 1] = this._rBlock;
            },
            keySize: 64 / 32,
            ivSize: 64 / 32,
            blockSize: 64 / 32
          });
          function exchangeLR(offset, mask) {
            var t = (this._lBlock >>> offset ^ this._rBlock) & mask;
            this._rBlock ^= t;
            this._lBlock ^= t << offset;
          }
          function exchangeRL(offset, mask) {
            var t = (this._rBlock >>> offset ^ this._lBlock) & mask;
            this._lBlock ^= t;
            this._rBlock ^= t << offset;
          }
          C.DES = BlockCipher._createHelper(DES);
          var TripleDES = C_algo.TripleDES = BlockCipher.extend({
            _doReset: function() {
              var key = this._key;
              var keyWords = key.words;
              if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
                throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
              }
              var key1 = keyWords.slice(0, 2);
              var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
              var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);
              this._des1 = DES.createEncryptor(WordArray.create(key1));
              this._des2 = DES.createEncryptor(WordArray.create(key2));
              this._des3 = DES.createEncryptor(WordArray.create(key3));
            },
            encryptBlock: function(M, offset) {
              this._des1.encryptBlock(M, offset);
              this._des2.decryptBlock(M, offset);
              this._des3.encryptBlock(M, offset);
            },
            decryptBlock: function(M, offset) {
              this._des3.decryptBlock(M, offset);
              this._des2.encryptBlock(M, offset);
              this._des1.decryptBlock(M, offset);
            },
            keySize: 192 / 32,
            ivSize: 64 / 32,
            blockSize: 64 / 32
          });
          C.TripleDES = BlockCipher._createHelper(TripleDES);
        })();
        return CryptoJS.TripleDES;
      });
    }
  });

  // ../zotero-style/node_modules/crypto-js/rc4.js
  var require_rc4 = __commonJS({
    "../zotero-style/node_modules/crypto-js/rc4.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function() {
          var C = CryptoJS;
          var C_lib = C.lib;
          var StreamCipher = C_lib.StreamCipher;
          var C_algo = C.algo;
          var RC4 = C_algo.RC4 = StreamCipher.extend({
            _doReset: function() {
              var key = this._key;
              var keyWords = key.words;
              var keySigBytes = key.sigBytes;
              var S = this._S = [];
              for (var i = 0; i < 256; i++) {
                S[i] = i;
              }
              for (var i = 0, j = 0; i < 256; i++) {
                var keyByteIndex = i % keySigBytes;
                var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
                j = (j + S[i] + keyByte) % 256;
                var t = S[i];
                S[i] = S[j];
                S[j] = t;
              }
              this._i = this._j = 0;
            },
            _doProcessBlock: function(M, offset) {
              M[offset] ^= generateKeystreamWord.call(this);
            },
            keySize: 256 / 32,
            ivSize: 0
          });
          function generateKeystreamWord() {
            var S = this._S;
            var i = this._i;
            var j = this._j;
            var keystreamWord = 0;
            for (var n = 0; n < 4; n++) {
              i = (i + 1) % 256;
              j = (j + S[i]) % 256;
              var t = S[i];
              S[i] = S[j];
              S[j] = t;
              keystreamWord |= S[(S[i] + S[j]) % 256] << 24 - n * 8;
            }
            this._i = i;
            this._j = j;
            return keystreamWord;
          }
          C.RC4 = StreamCipher._createHelper(RC4);
          var RC4Drop = C_algo.RC4Drop = RC4.extend({
            /**
             * Configuration options.
             *
             * @property {number} drop The number of keystream words to drop. Default 192
             */
            cfg: RC4.cfg.extend({
              drop: 192
            }),
            _doReset: function() {
              RC4._doReset.call(this);
              for (var i = this.cfg.drop; i > 0; i--) {
                generateKeystreamWord.call(this);
              }
            }
          });
          C.RC4Drop = StreamCipher._createHelper(RC4Drop);
        })();
        return CryptoJS.RC4;
      });
    }
  });

  // ../zotero-style/node_modules/crypto-js/rabbit.js
  var require_rabbit = __commonJS({
    "../zotero-style/node_modules/crypto-js/rabbit.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function() {
          var C = CryptoJS;
          var C_lib = C.lib;
          var StreamCipher = C_lib.StreamCipher;
          var C_algo = C.algo;
          var S = [];
          var C_ = [];
          var G = [];
          var Rabbit = C_algo.Rabbit = StreamCipher.extend({
            _doReset: function() {
              var K = this._key.words;
              var iv = this.cfg.iv;
              for (var i = 0; i < 4; i++) {
                K[i] = (K[i] << 8 | K[i] >>> 24) & 16711935 | (K[i] << 24 | K[i] >>> 8) & 4278255360;
              }
              var X = this._X = [
                K[0],
                K[3] << 16 | K[2] >>> 16,
                K[1],
                K[0] << 16 | K[3] >>> 16,
                K[2],
                K[1] << 16 | K[0] >>> 16,
                K[3],
                K[2] << 16 | K[1] >>> 16
              ];
              var C2 = this._C = [
                K[2] << 16 | K[2] >>> 16,
                K[0] & 4294901760 | K[1] & 65535,
                K[3] << 16 | K[3] >>> 16,
                K[1] & 4294901760 | K[2] & 65535,
                K[0] << 16 | K[0] >>> 16,
                K[2] & 4294901760 | K[3] & 65535,
                K[1] << 16 | K[1] >>> 16,
                K[3] & 4294901760 | K[0] & 65535
              ];
              this._b = 0;
              for (var i = 0; i < 4; i++) {
                nextState.call(this);
              }
              for (var i = 0; i < 8; i++) {
                C2[i] ^= X[i + 4 & 7];
              }
              if (iv) {
                var IV = iv.words;
                var IV_0 = IV[0];
                var IV_1 = IV[1];
                var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
                var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
                var i1 = i0 >>> 16 | i2 & 4294901760;
                var i3 = i2 << 16 | i0 & 65535;
                C2[0] ^= i0;
                C2[1] ^= i1;
                C2[2] ^= i2;
                C2[3] ^= i3;
                C2[4] ^= i0;
                C2[5] ^= i1;
                C2[6] ^= i2;
                C2[7] ^= i3;
                for (var i = 0; i < 4; i++) {
                  nextState.call(this);
                }
              }
            },
            _doProcessBlock: function(M, offset) {
              var X = this._X;
              nextState.call(this);
              S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
              S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
              S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
              S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
              for (var i = 0; i < 4; i++) {
                S[i] = (S[i] << 8 | S[i] >>> 24) & 16711935 | (S[i] << 24 | S[i] >>> 8) & 4278255360;
                M[offset + i] ^= S[i];
              }
            },
            blockSize: 128 / 32,
            ivSize: 64 / 32
          });
          function nextState() {
            var X = this._X;
            var C2 = this._C;
            for (var i = 0; i < 8; i++) {
              C_[i] = C2[i];
            }
            C2[0] = C2[0] + 1295307597 + this._b | 0;
            C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
            C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
            C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
            C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
            C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
            C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
            C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
            this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
            for (var i = 0; i < 8; i++) {
              var gx = X[i] + C2[i];
              var ga = gx & 65535;
              var gb = gx >>> 16;
              var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
              var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
              G[i] = gh ^ gl;
            }
            X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
            X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
            X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
            X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
            X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
            X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
            X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
            X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
          }
          C.Rabbit = StreamCipher._createHelper(Rabbit);
        })();
        return CryptoJS.Rabbit;
      });
    }
  });

  // ../zotero-style/node_modules/crypto-js/rabbit-legacy.js
  var require_rabbit_legacy = __commonJS({
    "../zotero-style/node_modules/crypto-js/rabbit-legacy.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function() {
          var C = CryptoJS;
          var C_lib = C.lib;
          var StreamCipher = C_lib.StreamCipher;
          var C_algo = C.algo;
          var S = [];
          var C_ = [];
          var G = [];
          var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
            _doReset: function() {
              var K = this._key.words;
              var iv = this.cfg.iv;
              var X = this._X = [
                K[0],
                K[3] << 16 | K[2] >>> 16,
                K[1],
                K[0] << 16 | K[3] >>> 16,
                K[2],
                K[1] << 16 | K[0] >>> 16,
                K[3],
                K[2] << 16 | K[1] >>> 16
              ];
              var C2 = this._C = [
                K[2] << 16 | K[2] >>> 16,
                K[0] & 4294901760 | K[1] & 65535,
                K[3] << 16 | K[3] >>> 16,
                K[1] & 4294901760 | K[2] & 65535,
                K[0] << 16 | K[0] >>> 16,
                K[2] & 4294901760 | K[3] & 65535,
                K[1] << 16 | K[1] >>> 16,
                K[3] & 4294901760 | K[0] & 65535
              ];
              this._b = 0;
              for (var i = 0; i < 4; i++) {
                nextState.call(this);
              }
              for (var i = 0; i < 8; i++) {
                C2[i] ^= X[i + 4 & 7];
              }
              if (iv) {
                var IV = iv.words;
                var IV_0 = IV[0];
                var IV_1 = IV[1];
                var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
                var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
                var i1 = i0 >>> 16 | i2 & 4294901760;
                var i3 = i2 << 16 | i0 & 65535;
                C2[0] ^= i0;
                C2[1] ^= i1;
                C2[2] ^= i2;
                C2[3] ^= i3;
                C2[4] ^= i0;
                C2[5] ^= i1;
                C2[6] ^= i2;
                C2[7] ^= i3;
                for (var i = 0; i < 4; i++) {
                  nextState.call(this);
                }
              }
            },
            _doProcessBlock: function(M, offset) {
              var X = this._X;
              nextState.call(this);
              S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
              S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
              S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
              S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
              for (var i = 0; i < 4; i++) {
                S[i] = (S[i] << 8 | S[i] >>> 24) & 16711935 | (S[i] << 24 | S[i] >>> 8) & 4278255360;
                M[offset + i] ^= S[i];
              }
            },
            blockSize: 128 / 32,
            ivSize: 64 / 32
          });
          function nextState() {
            var X = this._X;
            var C2 = this._C;
            for (var i = 0; i < 8; i++) {
              C_[i] = C2[i];
            }
            C2[0] = C2[0] + 1295307597 + this._b | 0;
            C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
            C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
            C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
            C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
            C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
            C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
            C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
            this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
            for (var i = 0; i < 8; i++) {
              var gx = X[i] + C2[i];
              var ga = gx & 65535;
              var gb = gx >>> 16;
              var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
              var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
              G[i] = gh ^ gl;
            }
            X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
            X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
            X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
            X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
            X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
            X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
            X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
            X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
          }
          C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
        })();
        return CryptoJS.RabbitLegacy;
      });
    }
  });

  // ../zotero-style/node_modules/crypto-js/index.js
  var require_crypto_js = __commonJS({
    "../zotero-style/node_modules/crypto-js/index.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_x64_core(), require_lib_typedarrays(), require_enc_utf16(), require_enc_base64(), require_enc_base64url(), require_md5(), require_sha1(), require_sha256(), require_sha224(), require_sha512(), require_sha384(), require_sha3(), require_ripemd160(), require_hmac(), require_pbkdf2(), require_evpkdf(), require_cipher_core(), require_mode_cfb(), require_mode_ctr(), require_mode_ctr_gladman(), require_mode_ofb(), require_mode_ecb(), require_pad_ansix923(), require_pad_iso10126(), require_pad_iso97971(), require_pad_zeropadding(), require_pad_nopadding(), require_format_hex(), require_aes(), require_tripledes(), require_rc4(), require_rabbit(), require_rabbit_legacy());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./x64-core", "./lib-typedarrays", "./enc-utf16", "./enc-base64", "./enc-base64url", "./md5", "./sha1", "./sha256", "./sha224", "./sha512", "./sha384", "./sha3", "./ripemd160", "./hmac", "./pbkdf2", "./evpkdf", "./cipher-core", "./mode-cfb", "./mode-ctr", "./mode-ctr-gladman", "./mode-ofb", "./mode-ecb", "./pad-ansix923", "./pad-iso10126", "./pad-iso97971", "./pad-zeropadding", "./pad-nopadding", "./format-hex", "./aes", "./tripledes", "./rc4", "./rabbit", "./rabbit-legacy"], factory);
        } else {
          root.CryptoJS = factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        return CryptoJS;
      });
    }
  });

  // ../zotero-style/node_modules/yamljs/lib/Pattern.js
  var require_Pattern = __commonJS({
    "../zotero-style/node_modules/yamljs/lib/Pattern.js"(exports, module) {
      var Pattern;
      Pattern = function() {
        Pattern2.prototype.regex = null;
        Pattern2.prototype.rawRegex = null;
        Pattern2.prototype.cleanedRegex = null;
        Pattern2.prototype.mapping = null;
        function Pattern2(rawRegex, modifiers) {
          var _char, capturingBracketNumber, cleanedRegex, i, len, mapping, name, part, subChar;
          if (modifiers == null) {
            modifiers = "";
          }
          cleanedRegex = "";
          len = rawRegex.length;
          mapping = null;
          capturingBracketNumber = 0;
          i = 0;
          while (i < len) {
            _char = rawRegex.charAt(i);
            if (_char === "\\") {
              cleanedRegex += rawRegex.slice(i, +(i + 1) + 1 || 9e9);
              i++;
            } else if (_char === "(") {
              if (i < len - 2) {
                part = rawRegex.slice(i, +(i + 2) + 1 || 9e9);
                if (part === "(?:") {
                  i += 2;
                  cleanedRegex += part;
                } else if (part === "(?<") {
                  capturingBracketNumber++;
                  i += 2;
                  name = "";
                  while (i + 1 < len) {
                    subChar = rawRegex.charAt(i + 1);
                    if (subChar === ">") {
                      cleanedRegex += "(";
                      i++;
                      if (name.length > 0) {
                        if (mapping == null) {
                          mapping = {};
                        }
                        mapping[name] = capturingBracketNumber;
                      }
                      break;
                    } else {
                      name += subChar;
                    }
                    i++;
                  }
                } else {
                  cleanedRegex += _char;
                  capturingBracketNumber++;
                }
              } else {
                cleanedRegex += _char;
              }
            } else {
              cleanedRegex += _char;
            }
            i++;
          }
          this.rawRegex = rawRegex;
          this.cleanedRegex = cleanedRegex;
          this.regex = new RegExp(this.cleanedRegex, "g" + modifiers.replace("g", ""));
          this.mapping = mapping;
        }
        Pattern2.prototype.exec = function(str) {
          var index, matches, name, ref;
          this.regex.lastIndex = 0;
          matches = this.regex.exec(str);
          if (matches == null) {
            return null;
          }
          if (this.mapping != null) {
            ref = this.mapping;
            for (name in ref) {
              index = ref[name];
              matches[name] = matches[index];
            }
          }
          return matches;
        };
        Pattern2.prototype.test = function(str) {
          this.regex.lastIndex = 0;
          return this.regex.test(str);
        };
        Pattern2.prototype.replace = function(str, replacement) {
          this.regex.lastIndex = 0;
          return str.replace(this.regex, replacement);
        };
        Pattern2.prototype.replaceAll = function(str, replacement, limit) {
          var count;
          if (limit == null) {
            limit = 0;
          }
          this.regex.lastIndex = 0;
          count = 0;
          while (this.regex.test(str) && (limit === 0 || count < limit)) {
            this.regex.lastIndex = 0;
            str = str.replace(this.regex, replacement);
            count++;
          }
          return [str, count];
        };
        return Pattern2;
      }();
      module.exports = Pattern;
    }
  });

  // ../zotero-style/node_modules/yamljs/lib/Utils.js
  var require_Utils = __commonJS({
    "../zotero-style/node_modules/yamljs/lib/Utils.js"(exports, module) {
      var Pattern;
      var Utils2;
      var hasProp = {}.hasOwnProperty;
      Pattern = require_Pattern();
      Utils2 = function() {
        function Utils3() {
        }
        Utils3.REGEX_LEFT_TRIM_BY_CHAR = {};
        Utils3.REGEX_RIGHT_TRIM_BY_CHAR = {};
        Utils3.REGEX_SPACES = /\s+/g;
        Utils3.REGEX_DIGITS = /^\d+$/;
        Utils3.REGEX_OCTAL = /[^0-7]/gi;
        Utils3.REGEX_HEXADECIMAL = /[^a-f0-9]/gi;
        Utils3.PATTERN_DATE = new Pattern("^(?<year>[0-9][0-9][0-9][0-9])-(?<month>[0-9][0-9]?)-(?<day>[0-9][0-9]?)(?:(?:[Tt]|[ 	]+)(?<hour>[0-9][0-9]?):(?<minute>[0-9][0-9]):(?<second>[0-9][0-9])(?:.(?<fraction>[0-9]*))?(?:[ 	]*(?<tz>Z|(?<tz_sign>[-+])(?<tz_hour>[0-9][0-9]?)(?::(?<tz_minute>[0-9][0-9]))?))?)?$", "i");
        Utils3.LOCAL_TIMEZONE_OFFSET = (/* @__PURE__ */ new Date()).getTimezoneOffset() * 60 * 1e3;
        Utils3.trim = function(str, _char) {
          var regexLeft, regexRight;
          if (_char == null) {
            _char = "\\s";
          }
          regexLeft = this.REGEX_LEFT_TRIM_BY_CHAR[_char];
          if (regexLeft == null) {
            this.REGEX_LEFT_TRIM_BY_CHAR[_char] = regexLeft = new RegExp("^" + _char + _char + "*");
          }
          regexLeft.lastIndex = 0;
          regexRight = this.REGEX_RIGHT_TRIM_BY_CHAR[_char];
          if (regexRight == null) {
            this.REGEX_RIGHT_TRIM_BY_CHAR[_char] = regexRight = new RegExp(_char + "" + _char + "*$");
          }
          regexRight.lastIndex = 0;
          return str.replace(regexLeft, "").replace(regexRight, "");
        };
        Utils3.ltrim = function(str, _char) {
          var regexLeft;
          if (_char == null) {
            _char = "\\s";
          }
          regexLeft = this.REGEX_LEFT_TRIM_BY_CHAR[_char];
          if (regexLeft == null) {
            this.REGEX_LEFT_TRIM_BY_CHAR[_char] = regexLeft = new RegExp("^" + _char + _char + "*");
          }
          regexLeft.lastIndex = 0;
          return str.replace(regexLeft, "");
        };
        Utils3.rtrim = function(str, _char) {
          var regexRight;
          if (_char == null) {
            _char = "\\s";
          }
          regexRight = this.REGEX_RIGHT_TRIM_BY_CHAR[_char];
          if (regexRight == null) {
            this.REGEX_RIGHT_TRIM_BY_CHAR[_char] = regexRight = new RegExp(_char + "" + _char + "*$");
          }
          regexRight.lastIndex = 0;
          return str.replace(regexRight, "");
        };
        Utils3.isEmpty = function(value) {
          return !value || value === "" || value === "0" || value instanceof Array && value.length === 0 || this.isEmptyObject(value);
        };
        Utils3.isEmptyObject = function(value) {
          var k;
          return value instanceof Object && function() {
            var results;
            results = [];
            for (k in value) {
              if (!hasProp.call(value, k))
                continue;
              results.push(k);
            }
            return results;
          }().length === 0;
        };
        Utils3.subStrCount = function(string, subString, start, length) {
          var c, i, j, len, ref, sublen;
          c = 0;
          string = "" + string;
          subString = "" + subString;
          if (start != null) {
            string = string.slice(start);
          }
          if (length != null) {
            string = string.slice(0, length);
          }
          len = string.length;
          sublen = subString.length;
          for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            if (subString === string.slice(i, sublen)) {
              c++;
              i += sublen - 1;
            }
          }
          return c;
        };
        Utils3.isDigits = function(input) {
          this.REGEX_DIGITS.lastIndex = 0;
          return this.REGEX_DIGITS.test(input);
        };
        Utils3.octDec = function(input) {
          this.REGEX_OCTAL.lastIndex = 0;
          return parseInt((input + "").replace(this.REGEX_OCTAL, ""), 8);
        };
        Utils3.hexDec = function(input) {
          this.REGEX_HEXADECIMAL.lastIndex = 0;
          input = this.trim(input);
          if ((input + "").slice(0, 2) === "0x") {
            input = (input + "").slice(2);
          }
          return parseInt((input + "").replace(this.REGEX_HEXADECIMAL, ""), 16);
        };
        Utils3.utf8chr = function(c) {
          var ch;
          ch = String.fromCharCode;
          if (128 > (c %= 2097152)) {
            return ch(c);
          }
          if (2048 > c) {
            return ch(192 | c >> 6) + ch(128 | c & 63);
          }
          if (65536 > c) {
            return ch(224 | c >> 12) + ch(128 | c >> 6 & 63) + ch(128 | c & 63);
          }
          return ch(240 | c >> 18) + ch(128 | c >> 12 & 63) + ch(128 | c >> 6 & 63) + ch(128 | c & 63);
        };
        Utils3.parseBoolean = function(input, strict) {
          var lowerInput;
          if (strict == null) {
            strict = true;
          }
          if (typeof input === "string") {
            lowerInput = input.toLowerCase();
            if (!strict) {
              if (lowerInput === "no") {
                return false;
              }
            }
            if (lowerInput === "0") {
              return false;
            }
            if (lowerInput === "false") {
              return false;
            }
            if (lowerInput === "") {
              return false;
            }
            return true;
          }
          return !!input;
        };
        Utils3.isNumeric = function(input) {
          this.REGEX_SPACES.lastIndex = 0;
          return typeof input === "number" || typeof input === "string" && !isNaN(input) && input.replace(this.REGEX_SPACES, "") !== "";
        };
        Utils3.stringToDate = function(str) {
          var date, day, fraction, hour, info, minute, month, second, tz_hour, tz_minute, tz_offset, year;
          if (!(str != null ? str.length : void 0)) {
            return null;
          }
          info = this.PATTERN_DATE.exec(str);
          if (!info) {
            return null;
          }
          year = parseInt(info.year, 10);
          month = parseInt(info.month, 10) - 1;
          day = parseInt(info.day, 10);
          if (info.hour == null) {
            date = new Date(Date.UTC(year, month, day));
            return date;
          }
          hour = parseInt(info.hour, 10);
          minute = parseInt(info.minute, 10);
          second = parseInt(info.second, 10);
          if (info.fraction != null) {
            fraction = info.fraction.slice(0, 3);
            while (fraction.length < 3) {
              fraction += "0";
            }
            fraction = parseInt(fraction, 10);
          } else {
            fraction = 0;
          }
          if (info.tz != null) {
            tz_hour = parseInt(info.tz_hour, 10);
            if (info.tz_minute != null) {
              tz_minute = parseInt(info.tz_minute, 10);
            } else {
              tz_minute = 0;
            }
            tz_offset = (tz_hour * 60 + tz_minute) * 6e4;
            if ("-" === info.tz_sign) {
              tz_offset *= -1;
            }
          }
          date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
          if (tz_offset) {
            date.setTime(date.getTime() - tz_offset);
          }
          return date;
        };
        Utils3.strRepeat = function(str, number) {
          var i, res;
          res = "";
          i = 0;
          while (i < number) {
            res += str;
            i++;
          }
          return res;
        };
        Utils3.getStringFromFile = function(path, callback) {
          var data, fs, j, len1, name, ref, req, xhr;
          if (callback == null) {
            callback = null;
          }
          xhr = null;
          if (typeof window !== "undefined" && window !== null) {
            if (window.XMLHttpRequest) {
              xhr = new XMLHttpRequest();
            } else if (window.ActiveXObject) {
              ref = ["Msxml2.XMLHTTP.6.0", "Msxml2.XMLHTTP.3.0", "Msxml2.XMLHTTP", "Microsoft.XMLHTTP"];
              for (j = 0, len1 = ref.length; j < len1; j++) {
                name = ref[j];
                try {
                  xhr = new ActiveXObject(name);
                } catch (error) {
                }
              }
            }
          }
          if (xhr != null) {
            if (callback != null) {
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  if (xhr.status === 200 || xhr.status === 0) {
                    return callback(xhr.responseText);
                  } else {
                    return callback(null);
                  }
                }
              };
              xhr.open("GET", path, true);
              return xhr.send(null);
            } else {
              xhr.open("GET", path, false);
              xhr.send(null);
              if (xhr.status === 200 || xhr.status === 0) {
                return xhr.responseText;
              }
              return null;
            }
          } else {
            req = __require;
            fs = req("fs");
            if (callback != null) {
              return fs.readFile(path, function(err, data2) {
                if (err) {
                  return callback(null);
                } else {
                  return callback(String(data2));
                }
              });
            } else {
              data = fs.readFileSync(path);
              if (data != null) {
                return String(data);
              }
              return null;
            }
          }
        };
        return Utils3;
      }();
      module.exports = Utils2;
    }
  });

  // ../zotero-style/node_modules/yamljs/lib/Unescaper.js
  var require_Unescaper = __commonJS({
    "../zotero-style/node_modules/yamljs/lib/Unescaper.js"(exports, module) {
      var Pattern;
      var Unescaper;
      var Utils2;
      Utils2 = require_Utils();
      Pattern = require_Pattern();
      Unescaper = function() {
        function Unescaper2() {
        }
        Unescaper2.PATTERN_ESCAPED_CHARACTER = new Pattern('\\\\([0abt	nvfre "\\/\\\\N_LP]|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|U[0-9a-fA-F]{8})');
        Unescaper2.unescapeSingleQuotedString = function(value) {
          return value.replace(/\'\'/g, "'");
        };
        Unescaper2.unescapeDoubleQuotedString = function(value) {
          if (this._unescapeCallback == null) {
            this._unescapeCallback = function(_this) {
              return function(str) {
                return _this.unescapeCharacter(str);
              };
            }(this);
          }
          return this.PATTERN_ESCAPED_CHARACTER.replace(value, this._unescapeCallback);
        };
        Unescaper2.unescapeCharacter = function(value) {
          var ch;
          ch = String.fromCharCode;
          switch (value.charAt(1)) {
            case "0":
              return ch(0);
            case "a":
              return ch(7);
            case "b":
              return ch(8);
            case "t":
              return "	";
            case "	":
              return "	";
            case "n":
              return "\n";
            case "v":
              return ch(11);
            case "f":
              return ch(12);
            case "r":
              return ch(13);
            case "e":
              return ch(27);
            case " ":
              return " ";
            case '"':
              return '"';
            case "/":
              return "/";
            case "\\":
              return "\\";
            case "N":
              return ch(133);
            case "_":
              return ch(160);
            case "L":
              return ch(8232);
            case "P":
              return ch(8233);
            case "x":
              return Utils2.utf8chr(Utils2.hexDec(value.substr(2, 2)));
            case "u":
              return Utils2.utf8chr(Utils2.hexDec(value.substr(2, 4)));
            case "U":
              return Utils2.utf8chr(Utils2.hexDec(value.substr(2, 8)));
            default:
              return "";
          }
        };
        return Unescaper2;
      }();
      module.exports = Unescaper;
    }
  });

  // ../zotero-style/node_modules/yamljs/lib/Escaper.js
  var require_Escaper = __commonJS({
    "../zotero-style/node_modules/yamljs/lib/Escaper.js"(exports, module) {
      var Escaper;
      var Pattern;
      Pattern = require_Pattern();
      Escaper = function() {
        var ch;
        function Escaper2() {
        }
        Escaper2.LIST_ESCAPEES = ["\\", "\\\\", '\\"', '"', "\0", "", "", "", "", "", "", "\x07", "\b", "	", "\n", "\v", "\f", "\r", "", "", "", "", "", "", "", "", "", "", "", "", "", "\x1B", "", "", "", "", (ch = String.fromCharCode)(133), ch(160), ch(8232), ch(8233)];
        Escaper2.LIST_ESCAPED = ["\\\\", '\\"', '\\"', '\\"', "\\0", "\\x01", "\\x02", "\\x03", "\\x04", "\\x05", "\\x06", "\\a", "\\b", "\\t", "\\n", "\\v", "\\f", "\\r", "\\x0e", "\\x0f", "\\x10", "\\x11", "\\x12", "\\x13", "\\x14", "\\x15", "\\x16", "\\x17", "\\x18", "\\x19", "\\x1a", "\\e", "\\x1c", "\\x1d", "\\x1e", "\\x1f", "\\N", "\\_", "\\L", "\\P"];
        Escaper2.MAPPING_ESCAPEES_TO_ESCAPED = function() {
          var i, j, mapping, ref;
          mapping = {};
          for (i = j = 0, ref = Escaper2.LIST_ESCAPEES.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            mapping[Escaper2.LIST_ESCAPEES[i]] = Escaper2.LIST_ESCAPED[i];
          }
          return mapping;
        }();
        Escaper2.PATTERN_CHARACTERS_TO_ESCAPE = new Pattern("[\\x00-\\x1f]|\xC2\x85|\xC2\xA0|\xE2\x80\xA8|\xE2\x80\xA9");
        Escaper2.PATTERN_MAPPING_ESCAPEES = new Pattern(Escaper2.LIST_ESCAPEES.join("|").split("\\").join("\\\\"));
        Escaper2.PATTERN_SINGLE_QUOTING = new Pattern("[\\s'\":{}[\\],&*#?]|^[-?|<>=!%@`]");
        Escaper2.requiresDoubleQuoting = function(value) {
          return this.PATTERN_CHARACTERS_TO_ESCAPE.test(value);
        };
        Escaper2.escapeWithDoubleQuotes = function(value) {
          var result;
          result = this.PATTERN_MAPPING_ESCAPEES.replace(value, function(_this) {
            return function(str) {
              return _this.MAPPING_ESCAPEES_TO_ESCAPED[str];
            };
          }(this));
          return '"' + result + '"';
        };
        Escaper2.requiresSingleQuoting = function(value) {
          return this.PATTERN_SINGLE_QUOTING.test(value);
        };
        Escaper2.escapeWithSingleQuotes = function(value) {
          return "'" + value.replace(/'/g, "''") + "'";
        };
        return Escaper2;
      }();
      module.exports = Escaper;
    }
  });

  // ../zotero-style/node_modules/yamljs/lib/Exception/ParseException.js
  var require_ParseException = __commonJS({
    "../zotero-style/node_modules/yamljs/lib/Exception/ParseException.js"(exports, module) {
      var ParseException;
      var extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      };
      var hasProp = {}.hasOwnProperty;
      ParseException = function(superClass) {
        extend(ParseException2, superClass);
        function ParseException2(message, parsedLine, snippet) {
          this.message = message;
          this.parsedLine = parsedLine;
          this.snippet = snippet;
        }
        ParseException2.prototype.toString = function() {
          if (this.parsedLine != null && this.snippet != null) {
            return "<ParseException> " + this.message + " (line " + this.parsedLine + ": '" + this.snippet + "')";
          } else {
            return "<ParseException> " + this.message;
          }
        };
        return ParseException2;
      }(Error);
      module.exports = ParseException;
    }
  });

  // ../zotero-style/node_modules/yamljs/lib/Exception/ParseMore.js
  var require_ParseMore = __commonJS({
    "../zotero-style/node_modules/yamljs/lib/Exception/ParseMore.js"(exports, module) {
      var ParseMore;
      var extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      };
      var hasProp = {}.hasOwnProperty;
      ParseMore = function(superClass) {
        extend(ParseMore2, superClass);
        function ParseMore2(message, parsedLine, snippet) {
          this.message = message;
          this.parsedLine = parsedLine;
          this.snippet = snippet;
        }
        ParseMore2.prototype.toString = function() {
          if (this.parsedLine != null && this.snippet != null) {
            return "<ParseMore> " + this.message + " (line " + this.parsedLine + ": '" + this.snippet + "')";
          } else {
            return "<ParseMore> " + this.message;
          }
        };
        return ParseMore2;
      }(Error);
      module.exports = ParseMore;
    }
  });

  // ../zotero-style/node_modules/yamljs/lib/Exception/DumpException.js
  var require_DumpException = __commonJS({
    "../zotero-style/node_modules/yamljs/lib/Exception/DumpException.js"(exports, module) {
      var DumpException;
      var extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      };
      var hasProp = {}.hasOwnProperty;
      DumpException = function(superClass) {
        extend(DumpException2, superClass);
        function DumpException2(message, parsedLine, snippet) {
          this.message = message;
          this.parsedLine = parsedLine;
          this.snippet = snippet;
        }
        DumpException2.prototype.toString = function() {
          if (this.parsedLine != null && this.snippet != null) {
            return "<DumpException> " + this.message + " (line " + this.parsedLine + ": '" + this.snippet + "')";
          } else {
            return "<DumpException> " + this.message;
          }
        };
        return DumpException2;
      }(Error);
      module.exports = DumpException;
    }
  });

  // ../zotero-style/node_modules/yamljs/lib/Inline.js
  var require_Inline = __commonJS({
    "../zotero-style/node_modules/yamljs/lib/Inline.js"(exports, module) {
      var DumpException;
      var Escaper;
      var Inline;
      var ParseException;
      var ParseMore;
      var Pattern;
      var Unescaper;
      var Utils2;
      var indexOf = [].indexOf || function(item) {
        for (var i = 0, l = this.length; i < l; i++) {
          if (i in this && this[i] === item)
            return i;
        }
        return -1;
      };
      Pattern = require_Pattern();
      Unescaper = require_Unescaper();
      Escaper = require_Escaper();
      Utils2 = require_Utils();
      ParseException = require_ParseException();
      ParseMore = require_ParseMore();
      DumpException = require_DumpException();
      Inline = function() {
        function Inline2() {
        }
        Inline2.REGEX_QUOTED_STRING = `(?:"(?:[^"\\\\]*(?:\\\\.[^"\\\\]*)*)"|'(?:[^']*(?:''[^']*)*)')`;
        Inline2.PATTERN_TRAILING_COMMENTS = new Pattern("^\\s*#.*$");
        Inline2.PATTERN_QUOTED_SCALAR = new Pattern("^" + Inline2.REGEX_QUOTED_STRING);
        Inline2.PATTERN_THOUSAND_NUMERIC_SCALAR = new Pattern("^(-|\\+)?[0-9,]+(\\.[0-9]+)?$");
        Inline2.PATTERN_SCALAR_BY_DELIMITERS = {};
        Inline2.settings = {};
        Inline2.configure = function(exceptionOnInvalidType, objectDecoder) {
          if (exceptionOnInvalidType == null) {
            exceptionOnInvalidType = null;
          }
          if (objectDecoder == null) {
            objectDecoder = null;
          }
          this.settings.exceptionOnInvalidType = exceptionOnInvalidType;
          this.settings.objectDecoder = objectDecoder;
        };
        Inline2.parse = function(value, exceptionOnInvalidType, objectDecoder) {
          var context, result;
          if (exceptionOnInvalidType == null) {
            exceptionOnInvalidType = false;
          }
          if (objectDecoder == null) {
            objectDecoder = null;
          }
          this.settings.exceptionOnInvalidType = exceptionOnInvalidType;
          this.settings.objectDecoder = objectDecoder;
          if (value == null) {
            return "";
          }
          value = Utils2.trim(value);
          if (0 === value.length) {
            return "";
          }
          context = {
            exceptionOnInvalidType,
            objectDecoder,
            i: 0
          };
          switch (value.charAt(0)) {
            case "[":
              result = this.parseSequence(value, context);
              ++context.i;
              break;
            case "{":
              result = this.parseMapping(value, context);
              ++context.i;
              break;
            default:
              result = this.parseScalar(value, null, ['"', "'"], context);
          }
          if (this.PATTERN_TRAILING_COMMENTS.replace(value.slice(context.i), "") !== "") {
            throw new ParseException('Unexpected characters near "' + value.slice(context.i) + '".');
          }
          return result;
        };
        Inline2.dump = function(value, exceptionOnInvalidType, objectEncoder) {
          var ref, result, type;
          if (exceptionOnInvalidType == null) {
            exceptionOnInvalidType = false;
          }
          if (objectEncoder == null) {
            objectEncoder = null;
          }
          if (value == null) {
            return "null";
          }
          type = typeof value;
          if (type === "object") {
            if (value instanceof Date) {
              return value.toISOString();
            } else if (objectEncoder != null) {
              result = objectEncoder(value);
              if (typeof result === "string" || result != null) {
                return result;
              }
            }
            return this.dumpObject(value);
          }
          if (type === "boolean") {
            return value ? "true" : "false";
          }
          if (Utils2.isDigits(value)) {
            return type === "string" ? "'" + value + "'" : String(parseInt(value));
          }
          if (Utils2.isNumeric(value)) {
            return type === "string" ? "'" + value + "'" : String(parseFloat(value));
          }
          if (type === "number") {
            return value === Infinity ? ".Inf" : value === -Infinity ? "-.Inf" : isNaN(value) ? ".NaN" : value;
          }
          if (Escaper.requiresDoubleQuoting(value)) {
            return Escaper.escapeWithDoubleQuotes(value);
          }
          if (Escaper.requiresSingleQuoting(value)) {
            return Escaper.escapeWithSingleQuotes(value);
          }
          if ("" === value) {
            return '""';
          }
          if (Utils2.PATTERN_DATE.test(value)) {
            return "'" + value + "'";
          }
          if ((ref = value.toLowerCase()) === "null" || ref === "~" || ref === "true" || ref === "false") {
            return "'" + value + "'";
          }
          return value;
        };
        Inline2.dumpObject = function(value, exceptionOnInvalidType, objectSupport) {
          var j, key, len1, output, val;
          if (objectSupport == null) {
            objectSupport = null;
          }
          if (value instanceof Array) {
            output = [];
            for (j = 0, len1 = value.length; j < len1; j++) {
              val = value[j];
              output.push(this.dump(val));
            }
            return "[" + output.join(", ") + "]";
          } else {
            output = [];
            for (key in value) {
              val = value[key];
              output.push(this.dump(key) + ": " + this.dump(val));
            }
            return "{" + output.join(", ") + "}";
          }
        };
        Inline2.parseScalar = function(scalar, delimiters, stringDelimiters, context, evaluate) {
          var i, joinedDelimiters, match, output, pattern, ref, ref1, strpos, tmp;
          if (delimiters == null) {
            delimiters = null;
          }
          if (stringDelimiters == null) {
            stringDelimiters = ['"', "'"];
          }
          if (context == null) {
            context = null;
          }
          if (evaluate == null) {
            evaluate = true;
          }
          if (context == null) {
            context = {
              exceptionOnInvalidType: this.settings.exceptionOnInvalidType,
              objectDecoder: this.settings.objectDecoder,
              i: 0
            };
          }
          i = context.i;
          if (ref = scalar.charAt(i), indexOf.call(stringDelimiters, ref) >= 0) {
            output = this.parseQuotedScalar(scalar, context);
            i = context.i;
            if (delimiters != null) {
              tmp = Utils2.ltrim(scalar.slice(i), " ");
              if (!(ref1 = tmp.charAt(0), indexOf.call(delimiters, ref1) >= 0)) {
                throw new ParseException("Unexpected characters (" + scalar.slice(i) + ").");
              }
            }
          } else {
            if (!delimiters) {
              output = scalar.slice(i);
              i += output.length;
              strpos = output.indexOf(" #");
              if (strpos !== -1) {
                output = Utils2.rtrim(output.slice(0, strpos));
              }
            } else {
              joinedDelimiters = delimiters.join("|");
              pattern = this.PATTERN_SCALAR_BY_DELIMITERS[joinedDelimiters];
              if (pattern == null) {
                pattern = new Pattern("^(.+?)(" + joinedDelimiters + ")");
                this.PATTERN_SCALAR_BY_DELIMITERS[joinedDelimiters] = pattern;
              }
              if (match = pattern.exec(scalar.slice(i))) {
                output = match[1];
                i += output.length;
              } else {
                throw new ParseException("Malformed inline YAML string (" + scalar + ").");
              }
            }
            if (evaluate) {
              output = this.evaluateScalar(output, context);
            }
          }
          context.i = i;
          return output;
        };
        Inline2.parseQuotedScalar = function(scalar, context) {
          var i, match, output;
          i = context.i;
          if (!(match = this.PATTERN_QUOTED_SCALAR.exec(scalar.slice(i)))) {
            throw new ParseMore("Malformed inline YAML string (" + scalar.slice(i) + ").");
          }
          output = match[0].substr(1, match[0].length - 2);
          if ('"' === scalar.charAt(i)) {
            output = Unescaper.unescapeDoubleQuotedString(output);
          } else {
            output = Unescaper.unescapeSingleQuotedString(output);
          }
          i += match[0].length;
          context.i = i;
          return output;
        };
        Inline2.parseSequence = function(sequence, context) {
          var e, i, isQuoted, len, output, ref, value;
          output = [];
          len = sequence.length;
          i = context.i;
          i += 1;
          while (i < len) {
            context.i = i;
            switch (sequence.charAt(i)) {
              case "[":
                output.push(this.parseSequence(sequence, context));
                i = context.i;
                break;
              case "{":
                output.push(this.parseMapping(sequence, context));
                i = context.i;
                break;
              case "]":
                return output;
              case ",":
              case " ":
              case "\n":
                break;
              default:
                isQuoted = (ref = sequence.charAt(i)) === '"' || ref === "'";
                value = this.parseScalar(sequence, [",", "]"], ['"', "'"], context);
                i = context.i;
                if (!isQuoted && typeof value === "string" && (value.indexOf(": ") !== -1 || value.indexOf(":\n") !== -1)) {
                  try {
                    value = this.parseMapping("{" + value + "}");
                  } catch (error) {
                    e = error;
                  }
                }
                output.push(value);
                --i;
            }
            ++i;
          }
          throw new ParseMore("Malformed inline YAML string " + sequence);
        };
        Inline2.parseMapping = function(mapping, context) {
          var done, i, key, len, output, shouldContinueWhileLoop, value;
          output = {};
          len = mapping.length;
          i = context.i;
          i += 1;
          shouldContinueWhileLoop = false;
          while (i < len) {
            context.i = i;
            switch (mapping.charAt(i)) {
              case " ":
              case ",":
              case "\n":
                ++i;
                context.i = i;
                shouldContinueWhileLoop = true;
                break;
              case "}":
                return output;
            }
            if (shouldContinueWhileLoop) {
              shouldContinueWhileLoop = false;
              continue;
            }
            key = this.parseScalar(mapping, [":", " ", "\n"], ['"', "'"], context, false);
            i = context.i;
            done = false;
            while (i < len) {
              context.i = i;
              switch (mapping.charAt(i)) {
                case "[":
                  value = this.parseSequence(mapping, context);
                  i = context.i;
                  if (output[key] === void 0) {
                    output[key] = value;
                  }
                  done = true;
                  break;
                case "{":
                  value = this.parseMapping(mapping, context);
                  i = context.i;
                  if (output[key] === void 0) {
                    output[key] = value;
                  }
                  done = true;
                  break;
                case ":":
                case " ":
                case "\n":
                  break;
                default:
                  value = this.parseScalar(mapping, [",", "}"], ['"', "'"], context);
                  i = context.i;
                  if (output[key] === void 0) {
                    output[key] = value;
                  }
                  done = true;
                  --i;
              }
              ++i;
              if (done) {
                break;
              }
            }
          }
          throw new ParseMore("Malformed inline YAML string " + mapping);
        };
        Inline2.evaluateScalar = function(scalar, context) {
          var cast, date, exceptionOnInvalidType, firstChar, firstSpace, firstWord, objectDecoder, raw, scalarLower, subValue, trimmedScalar;
          scalar = Utils2.trim(scalar);
          scalarLower = scalar.toLowerCase();
          switch (scalarLower) {
            case "null":
            case "":
            case "~":
              return null;
            case "true":
              return true;
            case "false":
              return false;
            case ".inf":
              return Infinity;
            case ".nan":
              return 0 / 0;
            case "-.inf":
              return Infinity;
            default:
              firstChar = scalarLower.charAt(0);
              switch (firstChar) {
                case "!":
                  firstSpace = scalar.indexOf(" ");
                  if (firstSpace === -1) {
                    firstWord = scalarLower;
                  } else {
                    firstWord = scalarLower.slice(0, firstSpace);
                  }
                  switch (firstWord) {
                    case "!":
                      if (firstSpace !== -1) {
                        return parseInt(this.parseScalar(scalar.slice(2)));
                      }
                      return null;
                    case "!str":
                      return Utils2.ltrim(scalar.slice(4));
                    case "!!str":
                      return Utils2.ltrim(scalar.slice(5));
                    case "!!int":
                      return parseInt(this.parseScalar(scalar.slice(5)));
                    case "!!bool":
                      return Utils2.parseBoolean(this.parseScalar(scalar.slice(6)), false);
                    case "!!float":
                      return parseFloat(this.parseScalar(scalar.slice(7)));
                    case "!!timestamp":
                      return Utils2.stringToDate(Utils2.ltrim(scalar.slice(11)));
                    default:
                      if (context == null) {
                        context = {
                          exceptionOnInvalidType: this.settings.exceptionOnInvalidType,
                          objectDecoder: this.settings.objectDecoder,
                          i: 0
                        };
                      }
                      objectDecoder = context.objectDecoder, exceptionOnInvalidType = context.exceptionOnInvalidType;
                      if (objectDecoder) {
                        trimmedScalar = Utils2.rtrim(scalar);
                        firstSpace = trimmedScalar.indexOf(" ");
                        if (firstSpace === -1) {
                          return objectDecoder(trimmedScalar, null);
                        } else {
                          subValue = Utils2.ltrim(trimmedScalar.slice(firstSpace + 1));
                          if (!(subValue.length > 0)) {
                            subValue = null;
                          }
                          return objectDecoder(trimmedScalar.slice(0, firstSpace), subValue);
                        }
                      }
                      if (exceptionOnInvalidType) {
                        throw new ParseException("Custom object support when parsing a YAML file has been disabled.");
                      }
                      return null;
                  }
                  break;
                case "0":
                  if ("0x" === scalar.slice(0, 2)) {
                    return Utils2.hexDec(scalar);
                  } else if (Utils2.isDigits(scalar)) {
                    return Utils2.octDec(scalar);
                  } else if (Utils2.isNumeric(scalar)) {
                    return parseFloat(scalar);
                  } else {
                    return scalar;
                  }
                  break;
                case "+":
                  if (Utils2.isDigits(scalar)) {
                    raw = scalar;
                    cast = parseInt(raw);
                    if (raw === String(cast)) {
                      return cast;
                    } else {
                      return raw;
                    }
                  } else if (Utils2.isNumeric(scalar)) {
                    return parseFloat(scalar);
                  } else if (this.PATTERN_THOUSAND_NUMERIC_SCALAR.test(scalar)) {
                    return parseFloat(scalar.replace(",", ""));
                  }
                  return scalar;
                case "-":
                  if (Utils2.isDigits(scalar.slice(1))) {
                    if ("0" === scalar.charAt(1)) {
                      return -Utils2.octDec(scalar.slice(1));
                    } else {
                      raw = scalar.slice(1);
                      cast = parseInt(raw);
                      if (raw === String(cast)) {
                        return -cast;
                      } else {
                        return -raw;
                      }
                    }
                  } else if (Utils2.isNumeric(scalar)) {
                    return parseFloat(scalar);
                  } else if (this.PATTERN_THOUSAND_NUMERIC_SCALAR.test(scalar)) {
                    return parseFloat(scalar.replace(",", ""));
                  }
                  return scalar;
                default:
                  if (date = Utils2.stringToDate(scalar)) {
                    return date;
                  } else if (Utils2.isNumeric(scalar)) {
                    return parseFloat(scalar);
                  } else if (this.PATTERN_THOUSAND_NUMERIC_SCALAR.test(scalar)) {
                    return parseFloat(scalar.replace(",", ""));
                  }
                  return scalar;
              }
          }
        };
        return Inline2;
      }();
      module.exports = Inline;
    }
  });

  // ../zotero-style/node_modules/yamljs/lib/Parser.js
  var require_Parser = __commonJS({
    "../zotero-style/node_modules/yamljs/lib/Parser.js"(exports, module) {
      var Inline;
      var ParseException;
      var ParseMore;
      var Parser;
      var Pattern;
      var Utils2;
      Inline = require_Inline();
      Pattern = require_Pattern();
      Utils2 = require_Utils();
      ParseException = require_ParseException();
      ParseMore = require_ParseMore();
      Parser = function() {
        Parser2.prototype.PATTERN_FOLDED_SCALAR_ALL = new Pattern("^(?:(?<type>![^\\|>]*)\\s+)?(?<separator>\\||>)(?<modifiers>\\+|\\-|\\d+|\\+\\d+|\\-\\d+|\\d+\\+|\\d+\\-)?(?<comments> +#.*)?$");
        Parser2.prototype.PATTERN_FOLDED_SCALAR_END = new Pattern("(?<separator>\\||>)(?<modifiers>\\+|\\-|\\d+|\\+\\d+|\\-\\d+|\\d+\\+|\\d+\\-)?(?<comments> +#.*)?$");
        Parser2.prototype.PATTERN_SEQUENCE_ITEM = new Pattern("^\\-((?<leadspaces>\\s+)(?<value>.+?))?\\s*$");
        Parser2.prototype.PATTERN_ANCHOR_VALUE = new Pattern("^&(?<ref>[^ ]+) *(?<value>.*)");
        Parser2.prototype.PATTERN_COMPACT_NOTATION = new Pattern("^(?<key>" + Inline.REGEX_QUOTED_STRING + `|[^ '"\\{\\[].*?) *\\:(\\s+(?<value>.+?))?\\s*$`);
        Parser2.prototype.PATTERN_MAPPING_ITEM = new Pattern("^(?<key>" + Inline.REGEX_QUOTED_STRING + `|[^ '"\\[\\{].*?) *\\:(\\s+(?<value>.+?))?\\s*$`);
        Parser2.prototype.PATTERN_DECIMAL = new Pattern("\\d+");
        Parser2.prototype.PATTERN_INDENT_SPACES = new Pattern("^ +");
        Parser2.prototype.PATTERN_TRAILING_LINES = new Pattern("(\n*)$");
        Parser2.prototype.PATTERN_YAML_HEADER = new Pattern("^\\%YAML[: ][\\d\\.]+.*\n", "m");
        Parser2.prototype.PATTERN_LEADING_COMMENTS = new Pattern("^(\\#.*?\n)+", "m");
        Parser2.prototype.PATTERN_DOCUMENT_MARKER_START = new Pattern("^\\-\\-\\-.*?\n", "m");
        Parser2.prototype.PATTERN_DOCUMENT_MARKER_END = new Pattern("^\\.\\.\\.\\s*$", "m");
        Parser2.prototype.PATTERN_FOLDED_SCALAR_BY_INDENTATION = {};
        Parser2.prototype.CONTEXT_NONE = 0;
        Parser2.prototype.CONTEXT_SEQUENCE = 1;
        Parser2.prototype.CONTEXT_MAPPING = 2;
        function Parser2(offset) {
          this.offset = offset != null ? offset : 0;
          this.lines = [];
          this.currentLineNb = -1;
          this.currentLine = "";
          this.refs = {};
        }
        Parser2.prototype.parse = function(value, exceptionOnInvalidType, objectDecoder) {
          var alias, allowOverwrite, block, c, context, data, e, first, i, indent, isRef, j, k, key, l, lastKey, len, len1, len2, len3, lineCount, m, matches, mergeNode, n, name, parsed, parsedItem, parser, ref, ref1, ref2, refName, refValue, val, values;
          if (exceptionOnInvalidType == null) {
            exceptionOnInvalidType = false;
          }
          if (objectDecoder == null) {
            objectDecoder = null;
          }
          this.currentLineNb = -1;
          this.currentLine = "";
          this.lines = this.cleanup(value).split("\n");
          data = null;
          context = this.CONTEXT_NONE;
          allowOverwrite = false;
          while (this.moveToNextLine()) {
            if (this.isCurrentLineEmpty()) {
              continue;
            }
            if ("	" === this.currentLine[0]) {
              throw new ParseException("A YAML file cannot contain tabs as indentation.", this.getRealCurrentLineNb() + 1, this.currentLine);
            }
            isRef = mergeNode = false;
            if (values = this.PATTERN_SEQUENCE_ITEM.exec(this.currentLine)) {
              if (this.CONTEXT_MAPPING === context) {
                throw new ParseException("You cannot define a sequence item when in a mapping");
              }
              context = this.CONTEXT_SEQUENCE;
              if (data == null) {
                data = [];
              }
              if (values.value != null && (matches = this.PATTERN_ANCHOR_VALUE.exec(values.value))) {
                isRef = matches.ref;
                values.value = matches.value;
              }
              if (!(values.value != null) || "" === Utils2.trim(values.value, " ") || Utils2.ltrim(values.value, " ").indexOf("#") === 0) {
                if (this.currentLineNb < this.lines.length - 1 && !this.isNextLineUnIndentedCollection()) {
                  c = this.getRealCurrentLineNb() + 1;
                  parser = new Parser2(c);
                  parser.refs = this.refs;
                  data.push(parser.parse(this.getNextEmbedBlock(null, true), exceptionOnInvalidType, objectDecoder));
                } else {
                  data.push(null);
                }
              } else {
                if (((ref = values.leadspaces) != null ? ref.length : void 0) && (matches = this.PATTERN_COMPACT_NOTATION.exec(values.value))) {
                  c = this.getRealCurrentLineNb();
                  parser = new Parser2(c);
                  parser.refs = this.refs;
                  block = values.value;
                  indent = this.getCurrentLineIndentation();
                  if (this.isNextLineIndented(false)) {
                    block += "\n" + this.getNextEmbedBlock(indent + values.leadspaces.length + 1, true);
                  }
                  data.push(parser.parse(block, exceptionOnInvalidType, objectDecoder));
                } else {
                  data.push(this.parseValue(values.value, exceptionOnInvalidType, objectDecoder));
                }
              }
            } else if ((values = this.PATTERN_MAPPING_ITEM.exec(this.currentLine)) && values.key.indexOf(" #") === -1) {
              if (this.CONTEXT_SEQUENCE === context) {
                throw new ParseException("You cannot define a mapping item when in a sequence");
              }
              context = this.CONTEXT_MAPPING;
              if (data == null) {
                data = {};
              }
              Inline.configure(exceptionOnInvalidType, objectDecoder);
              try {
                key = Inline.parseScalar(values.key);
              } catch (error) {
                e = error;
                e.parsedLine = this.getRealCurrentLineNb() + 1;
                e.snippet = this.currentLine;
                throw e;
              }
              if ("<<" === key) {
                mergeNode = true;
                allowOverwrite = true;
                if (((ref1 = values.value) != null ? ref1.indexOf("*") : void 0) === 0) {
                  refName = values.value.slice(1);
                  if (this.refs[refName] == null) {
                    throw new ParseException('Reference "' + refName + '" does not exist.', this.getRealCurrentLineNb() + 1, this.currentLine);
                  }
                  refValue = this.refs[refName];
                  if (typeof refValue !== "object") {
                    throw new ParseException("YAML merge keys used with a scalar value instead of an object.", this.getRealCurrentLineNb() + 1, this.currentLine);
                  }
                  if (refValue instanceof Array) {
                    for (i = j = 0, len = refValue.length; j < len; i = ++j) {
                      value = refValue[i];
                      if (data[name = String(i)] == null) {
                        data[name] = value;
                      }
                    }
                  } else {
                    for (key in refValue) {
                      value = refValue[key];
                      if (data[key] == null) {
                        data[key] = value;
                      }
                    }
                  }
                } else {
                  if (values.value != null && values.value !== "") {
                    value = values.value;
                  } else {
                    value = this.getNextEmbedBlock();
                  }
                  c = this.getRealCurrentLineNb() + 1;
                  parser = new Parser2(c);
                  parser.refs = this.refs;
                  parsed = parser.parse(value, exceptionOnInvalidType);
                  if (typeof parsed !== "object") {
                    throw new ParseException("YAML merge keys used with a scalar value instead of an object.", this.getRealCurrentLineNb() + 1, this.currentLine);
                  }
                  if (parsed instanceof Array) {
                    for (l = 0, len1 = parsed.length; l < len1; l++) {
                      parsedItem = parsed[l];
                      if (typeof parsedItem !== "object") {
                        throw new ParseException("Merge items must be objects.", this.getRealCurrentLineNb() + 1, parsedItem);
                      }
                      if (parsedItem instanceof Array) {
                        for (i = m = 0, len2 = parsedItem.length; m < len2; i = ++m) {
                          value = parsedItem[i];
                          k = String(i);
                          if (!data.hasOwnProperty(k)) {
                            data[k] = value;
                          }
                        }
                      } else {
                        for (key in parsedItem) {
                          value = parsedItem[key];
                          if (!data.hasOwnProperty(key)) {
                            data[key] = value;
                          }
                        }
                      }
                    }
                  } else {
                    for (key in parsed) {
                      value = parsed[key];
                      if (!data.hasOwnProperty(key)) {
                        data[key] = value;
                      }
                    }
                  }
                }
              } else if (values.value != null && (matches = this.PATTERN_ANCHOR_VALUE.exec(values.value))) {
                isRef = matches.ref;
                values.value = matches.value;
              }
              if (mergeNode) {
              } else if (!(values.value != null) || "" === Utils2.trim(values.value, " ") || Utils2.ltrim(values.value, " ").indexOf("#") === 0) {
                if (!this.isNextLineIndented() && !this.isNextLineUnIndentedCollection()) {
                  if (allowOverwrite || data[key] === void 0) {
                    data[key] = null;
                  }
                } else {
                  c = this.getRealCurrentLineNb() + 1;
                  parser = new Parser2(c);
                  parser.refs = this.refs;
                  val = parser.parse(this.getNextEmbedBlock(), exceptionOnInvalidType, objectDecoder);
                  if (allowOverwrite || data[key] === void 0) {
                    data[key] = val;
                  }
                }
              } else {
                val = this.parseValue(values.value, exceptionOnInvalidType, objectDecoder);
                if (allowOverwrite || data[key] === void 0) {
                  data[key] = val;
                }
              }
            } else {
              lineCount = this.lines.length;
              if (1 === lineCount || 2 === lineCount && Utils2.isEmpty(this.lines[1])) {
                try {
                  value = Inline.parse(this.lines[0], exceptionOnInvalidType, objectDecoder);
                } catch (error) {
                  e = error;
                  e.parsedLine = this.getRealCurrentLineNb() + 1;
                  e.snippet = this.currentLine;
                  throw e;
                }
                if (typeof value === "object") {
                  if (value instanceof Array) {
                    first = value[0];
                  } else {
                    for (key in value) {
                      first = value[key];
                      break;
                    }
                  }
                  if (typeof first === "string" && first.indexOf("*") === 0) {
                    data = [];
                    for (n = 0, len3 = value.length; n < len3; n++) {
                      alias = value[n];
                      data.push(this.refs[alias.slice(1)]);
                    }
                    value = data;
                  }
                }
                return value;
              } else if ((ref2 = Utils2.ltrim(value).charAt(0)) === "[" || ref2 === "{") {
                try {
                  return Inline.parse(value, exceptionOnInvalidType, objectDecoder);
                } catch (error) {
                  e = error;
                  e.parsedLine = this.getRealCurrentLineNb() + 1;
                  e.snippet = this.currentLine;
                  throw e;
                }
              }
              throw new ParseException("Unable to parse.", this.getRealCurrentLineNb() + 1, this.currentLine);
            }
            if (isRef) {
              if (data instanceof Array) {
                this.refs[isRef] = data[data.length - 1];
              } else {
                lastKey = null;
                for (key in data) {
                  lastKey = key;
                }
                this.refs[isRef] = data[lastKey];
              }
            }
          }
          if (Utils2.isEmpty(data)) {
            return null;
          } else {
            return data;
          }
        };
        Parser2.prototype.getRealCurrentLineNb = function() {
          return this.currentLineNb + this.offset;
        };
        Parser2.prototype.getCurrentLineIndentation = function() {
          return this.currentLine.length - Utils2.ltrim(this.currentLine, " ").length;
        };
        Parser2.prototype.getNextEmbedBlock = function(indentation, includeUnindentedCollection) {
          var data, indent, isItUnindentedCollection, newIndent, removeComments, removeCommentsPattern, unindentedEmbedBlock;
          if (indentation == null) {
            indentation = null;
          }
          if (includeUnindentedCollection == null) {
            includeUnindentedCollection = false;
          }
          this.moveToNextLine();
          if (indentation == null) {
            newIndent = this.getCurrentLineIndentation();
            unindentedEmbedBlock = this.isStringUnIndentedCollectionItem(this.currentLine);
            if (!this.isCurrentLineEmpty() && 0 === newIndent && !unindentedEmbedBlock) {
              throw new ParseException("Indentation problem.", this.getRealCurrentLineNb() + 1, this.currentLine);
            }
          } else {
            newIndent = indentation;
          }
          data = [this.currentLine.slice(newIndent)];
          if (!includeUnindentedCollection) {
            isItUnindentedCollection = this.isStringUnIndentedCollectionItem(this.currentLine);
          }
          removeCommentsPattern = this.PATTERN_FOLDED_SCALAR_END;
          removeComments = !removeCommentsPattern.test(this.currentLine);
          while (this.moveToNextLine()) {
            indent = this.getCurrentLineIndentation();
            if (indent === newIndent) {
              removeComments = !removeCommentsPattern.test(this.currentLine);
            }
            if (removeComments && this.isCurrentLineComment()) {
              continue;
            }
            if (this.isCurrentLineBlank()) {
              data.push(this.currentLine.slice(newIndent));
              continue;
            }
            if (isItUnindentedCollection && !this.isStringUnIndentedCollectionItem(this.currentLine) && indent === newIndent) {
              this.moveToPreviousLine();
              break;
            }
            if (indent >= newIndent) {
              data.push(this.currentLine.slice(newIndent));
            } else if (Utils2.ltrim(this.currentLine).charAt(0) === "#") {
            } else if (0 === indent) {
              this.moveToPreviousLine();
              break;
            } else {
              throw new ParseException("Indentation problem.", this.getRealCurrentLineNb() + 1, this.currentLine);
            }
          }
          return data.join("\n");
        };
        Parser2.prototype.moveToNextLine = function() {
          if (this.currentLineNb >= this.lines.length - 1) {
            return false;
          }
          this.currentLine = this.lines[++this.currentLineNb];
          return true;
        };
        Parser2.prototype.moveToPreviousLine = function() {
          this.currentLine = this.lines[--this.currentLineNb];
        };
        Parser2.prototype.parseValue = function(value, exceptionOnInvalidType, objectDecoder) {
          var e, foldedIndent, matches, modifiers, pos, ref, ref1, val;
          if (0 === value.indexOf("*")) {
            pos = value.indexOf("#");
            if (pos !== -1) {
              value = value.substr(1, pos - 2);
            } else {
              value = value.slice(1);
            }
            if (this.refs[value] === void 0) {
              throw new ParseException('Reference "' + value + '" does not exist.', this.currentLine);
            }
            return this.refs[value];
          }
          if (matches = this.PATTERN_FOLDED_SCALAR_ALL.exec(value)) {
            modifiers = (ref = matches.modifiers) != null ? ref : "";
            foldedIndent = Math.abs(parseInt(modifiers));
            if (isNaN(foldedIndent)) {
              foldedIndent = 0;
            }
            val = this.parseFoldedScalar(matches.separator, this.PATTERN_DECIMAL.replace(modifiers, ""), foldedIndent);
            if (matches.type != null) {
              Inline.configure(exceptionOnInvalidType, objectDecoder);
              return Inline.parseScalar(matches.type + " " + val);
            } else {
              return val;
            }
          }
          if ((ref1 = value.charAt(0)) === "[" || ref1 === "{" || ref1 === '"' || ref1 === "'") {
            while (true) {
              try {
                return Inline.parse(value, exceptionOnInvalidType, objectDecoder);
              } catch (error) {
                e = error;
                if (e instanceof ParseMore && this.moveToNextLine()) {
                  value += "\n" + Utils2.trim(this.currentLine, " ");
                } else {
                  e.parsedLine = this.getRealCurrentLineNb() + 1;
                  e.snippet = this.currentLine;
                  throw e;
                }
              }
            }
          } else {
            if (this.isNextLineIndented()) {
              value += "\n" + this.getNextEmbedBlock();
            }
            return Inline.parse(value, exceptionOnInvalidType, objectDecoder);
          }
        };
        Parser2.prototype.parseFoldedScalar = function(separator, indicator, indentation) {
          var isCurrentLineBlank, j, len, line, matches, newText, notEOF, pattern, ref, text;
          if (indicator == null) {
            indicator = "";
          }
          if (indentation == null) {
            indentation = 0;
          }
          notEOF = this.moveToNextLine();
          if (!notEOF) {
            return "";
          }
          isCurrentLineBlank = this.isCurrentLineBlank();
          text = "";
          while (notEOF && isCurrentLineBlank) {
            if (notEOF = this.moveToNextLine()) {
              text += "\n";
              isCurrentLineBlank = this.isCurrentLineBlank();
            }
          }
          if (0 === indentation) {
            if (matches = this.PATTERN_INDENT_SPACES.exec(this.currentLine)) {
              indentation = matches[0].length;
            }
          }
          if (indentation > 0) {
            pattern = this.PATTERN_FOLDED_SCALAR_BY_INDENTATION[indentation];
            if (pattern == null) {
              pattern = new Pattern("^ {" + indentation + "}(.*)$");
              Parser2.prototype.PATTERN_FOLDED_SCALAR_BY_INDENTATION[indentation] = pattern;
            }
            while (notEOF && (isCurrentLineBlank || (matches = pattern.exec(this.currentLine)))) {
              if (isCurrentLineBlank) {
                text += this.currentLine.slice(indentation);
              } else {
                text += matches[1];
              }
              if (notEOF = this.moveToNextLine()) {
                text += "\n";
                isCurrentLineBlank = this.isCurrentLineBlank();
              }
            }
          } else if (notEOF) {
            text += "\n";
          }
          if (notEOF) {
            this.moveToPreviousLine();
          }
          if (">" === separator) {
            newText = "";
            ref = text.split("\n");
            for (j = 0, len = ref.length; j < len; j++) {
              line = ref[j];
              if (line.length === 0 || line.charAt(0) === " ") {
                newText = Utils2.rtrim(newText, " ") + line + "\n";
              } else {
                newText += line + " ";
              }
            }
            text = newText;
          }
          if ("+" !== indicator) {
            text = Utils2.rtrim(text);
          }
          if ("" === indicator) {
            text = this.PATTERN_TRAILING_LINES.replace(text, "\n");
          } else if ("-" === indicator) {
            text = this.PATTERN_TRAILING_LINES.replace(text, "");
          }
          return text;
        };
        Parser2.prototype.isNextLineIndented = function(ignoreComments) {
          var EOF, currentIndentation, ret;
          if (ignoreComments == null) {
            ignoreComments = true;
          }
          currentIndentation = this.getCurrentLineIndentation();
          EOF = !this.moveToNextLine();
          if (ignoreComments) {
            while (!EOF && this.isCurrentLineEmpty()) {
              EOF = !this.moveToNextLine();
            }
          } else {
            while (!EOF && this.isCurrentLineBlank()) {
              EOF = !this.moveToNextLine();
            }
          }
          if (EOF) {
            return false;
          }
          ret = false;
          if (this.getCurrentLineIndentation() > currentIndentation) {
            ret = true;
          }
          this.moveToPreviousLine();
          return ret;
        };
        Parser2.prototype.isCurrentLineEmpty = function() {
          var trimmedLine;
          trimmedLine = Utils2.trim(this.currentLine, " ");
          return trimmedLine.length === 0 || trimmedLine.charAt(0) === "#";
        };
        Parser2.prototype.isCurrentLineBlank = function() {
          return "" === Utils2.trim(this.currentLine, " ");
        };
        Parser2.prototype.isCurrentLineComment = function() {
          var ltrimmedLine;
          ltrimmedLine = Utils2.ltrim(this.currentLine, " ");
          return ltrimmedLine.charAt(0) === "#";
        };
        Parser2.prototype.cleanup = function(value) {
          var count, i, indent, j, l, len, len1, line, lines, ref, ref1, ref2, smallestIndent, trimmedValue;
          if (value.indexOf("\r") !== -1) {
            value = value.split("\r\n").join("\n").split("\r").join("\n");
          }
          count = 0;
          ref = this.PATTERN_YAML_HEADER.replaceAll(value, ""), value = ref[0], count = ref[1];
          this.offset += count;
          ref1 = this.PATTERN_LEADING_COMMENTS.replaceAll(value, "", 1), trimmedValue = ref1[0], count = ref1[1];
          if (count === 1) {
            this.offset += Utils2.subStrCount(value, "\n") - Utils2.subStrCount(trimmedValue, "\n");
            value = trimmedValue;
          }
          ref2 = this.PATTERN_DOCUMENT_MARKER_START.replaceAll(value, "", 1), trimmedValue = ref2[0], count = ref2[1];
          if (count === 1) {
            this.offset += Utils2.subStrCount(value, "\n") - Utils2.subStrCount(trimmedValue, "\n");
            value = trimmedValue;
            value = this.PATTERN_DOCUMENT_MARKER_END.replace(value, "");
          }
          lines = value.split("\n");
          smallestIndent = -1;
          for (j = 0, len = lines.length; j < len; j++) {
            line = lines[j];
            if (Utils2.trim(line, " ").length === 0) {
              continue;
            }
            indent = line.length - Utils2.ltrim(line).length;
            if (smallestIndent === -1 || indent < smallestIndent) {
              smallestIndent = indent;
            }
          }
          if (smallestIndent > 0) {
            for (i = l = 0, len1 = lines.length; l < len1; i = ++l) {
              line = lines[i];
              lines[i] = line.slice(smallestIndent);
            }
            value = lines.join("\n");
          }
          return value;
        };
        Parser2.prototype.isNextLineUnIndentedCollection = function(currentIndentation) {
          var notEOF, ret;
          if (currentIndentation == null) {
            currentIndentation = null;
          }
          if (currentIndentation == null) {
            currentIndentation = this.getCurrentLineIndentation();
          }
          notEOF = this.moveToNextLine();
          while (notEOF && this.isCurrentLineEmpty()) {
            notEOF = this.moveToNextLine();
          }
          if (false === notEOF) {
            return false;
          }
          ret = false;
          if (this.getCurrentLineIndentation() === currentIndentation && this.isStringUnIndentedCollectionItem(this.currentLine)) {
            ret = true;
          }
          this.moveToPreviousLine();
          return ret;
        };
        Parser2.prototype.isStringUnIndentedCollectionItem = function() {
          return this.currentLine === "-" || this.currentLine.slice(0, 2) === "- ";
        };
        return Parser2;
      }();
      module.exports = Parser;
    }
  });

  // ../zotero-style/node_modules/yamljs/lib/Dumper.js
  var require_Dumper = __commonJS({
    "../zotero-style/node_modules/yamljs/lib/Dumper.js"(exports, module) {
      var Dumper;
      var Inline;
      var Utils2;
      Utils2 = require_Utils();
      Inline = require_Inline();
      Dumper = function() {
        function Dumper2() {
        }
        Dumper2.indentation = 4;
        Dumper2.prototype.dump = function(input, inline, indent, exceptionOnInvalidType, objectEncoder) {
          var i, key, len, output, prefix, value, willBeInlined;
          if (inline == null) {
            inline = 0;
          }
          if (indent == null) {
            indent = 0;
          }
          if (exceptionOnInvalidType == null) {
            exceptionOnInvalidType = false;
          }
          if (objectEncoder == null) {
            objectEncoder = null;
          }
          output = "";
          prefix = indent ? Utils2.strRepeat(" ", indent) : "";
          if (inline <= 0 || typeof input !== "object" || input instanceof Date || Utils2.isEmpty(input)) {
            output += prefix + Inline.dump(input, exceptionOnInvalidType, objectEncoder);
          } else {
            if (input instanceof Array) {
              for (i = 0, len = input.length; i < len; i++) {
                value = input[i];
                willBeInlined = inline - 1 <= 0 || typeof value !== "object" || Utils2.isEmpty(value);
                output += prefix + "-" + (willBeInlined ? " " : "\n") + this.dump(value, inline - 1, willBeInlined ? 0 : indent + this.indentation, exceptionOnInvalidType, objectEncoder) + (willBeInlined ? "\n" : "");
              }
            } else {
              for (key in input) {
                value = input[key];
                willBeInlined = inline - 1 <= 0 || typeof value !== "object" || Utils2.isEmpty(value);
                output += prefix + Inline.dump(key, exceptionOnInvalidType, objectEncoder) + ":" + (willBeInlined ? " " : "\n") + this.dump(value, inline - 1, willBeInlined ? 0 : indent + this.indentation, exceptionOnInvalidType, objectEncoder) + (willBeInlined ? "\n" : "");
              }
            }
          }
          return output;
        };
        return Dumper2;
      }();
      module.exports = Dumper;
    }
  });

  // ../zotero-style/node_modules/yamljs/lib/Yaml.js
  var require_Yaml = __commonJS({
    "../zotero-style/node_modules/yamljs/lib/Yaml.js"(exports, module) {
      var Dumper;
      var Parser;
      var Utils2;
      var Yaml;
      Parser = require_Parser();
      Dumper = require_Dumper();
      Utils2 = require_Utils();
      Yaml = function() {
        function Yaml2() {
        }
        Yaml2.parse = function(input, exceptionOnInvalidType, objectDecoder) {
          if (exceptionOnInvalidType == null) {
            exceptionOnInvalidType = false;
          }
          if (objectDecoder == null) {
            objectDecoder = null;
          }
          return new Parser().parse(input, exceptionOnInvalidType, objectDecoder);
        };
        Yaml2.parseFile = function(path, callback, exceptionOnInvalidType, objectDecoder) {
          var input;
          if (callback == null) {
            callback = null;
          }
          if (exceptionOnInvalidType == null) {
            exceptionOnInvalidType = false;
          }
          if (objectDecoder == null) {
            objectDecoder = null;
          }
          if (callback != null) {
            return Utils2.getStringFromFile(path, function(_this) {
              return function(input2) {
                var result;
                result = null;
                if (input2 != null) {
                  result = _this.parse(input2, exceptionOnInvalidType, objectDecoder);
                }
                callback(result);
              };
            }(this));
          } else {
            input = Utils2.getStringFromFile(path);
            if (input != null) {
              return this.parse(input, exceptionOnInvalidType, objectDecoder);
            }
            return null;
          }
        };
        Yaml2.dump = function(input, inline, indent, exceptionOnInvalidType, objectEncoder) {
          var yaml;
          if (inline == null) {
            inline = 2;
          }
          if (indent == null) {
            indent = 4;
          }
          if (exceptionOnInvalidType == null) {
            exceptionOnInvalidType = false;
          }
          if (objectEncoder == null) {
            objectEncoder = null;
          }
          yaml = new Dumper();
          yaml.indentation = indent;
          return yaml.dump(input, inline, 0, exceptionOnInvalidType, objectEncoder);
        };
        Yaml2.stringify = function(input, inline, indent, exceptionOnInvalidType, objectEncoder) {
          return this.dump(input, inline, indent, exceptionOnInvalidType, objectEncoder);
        };
        Yaml2.load = function(path, callback, exceptionOnInvalidType, objectDecoder) {
          return this.parseFile(path, callback, exceptionOnInvalidType, objectDecoder);
        };
        return Yaml2;
      }();
      if (typeof window !== "undefined" && window !== null) {
        window.YAML = Yaml;
      }
      if (typeof window === "undefined" || window === null) {
        exports.YAML = Yaml;
      }
      module.exports = Yaml;
    }
  });

  // node_modules/pako/lib/zlib/trees.js
  var require_trees = __commonJS({
    "node_modules/pako/lib/zlib/trees.js"(exports, module) {
      "use strict";
      var Z_FIXED = 4;
      var Z_BINARY = 0;
      var Z_TEXT = 1;
      var Z_UNKNOWN = 2;
      function zero(buf) {
        let len = buf.length;
        while (--len >= 0) {
          buf[len] = 0;
        }
      }
      var STORED_BLOCK = 0;
      var STATIC_TREES = 1;
      var DYN_TREES = 2;
      var MIN_MATCH = 3;
      var MAX_MATCH = 258;
      var LENGTH_CODES = 29;
      var LITERALS = 256;
      var L_CODES = LITERALS + 1 + LENGTH_CODES;
      var D_CODES = 30;
      var BL_CODES = 19;
      var HEAP_SIZE = 2 * L_CODES + 1;
      var MAX_BITS = 15;
      var Buf_size = 16;
      var MAX_BL_BITS = 7;
      var END_BLOCK = 256;
      var REP_3_6 = 16;
      var REPZ_3_10 = 17;
      var REPZ_11_138 = 18;
      var extra_lbits = (
        /* extra bits for each length code */
        new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
      );
      var extra_dbits = (
        /* extra bits for each distance code */
        new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
      );
      var extra_blbits = (
        /* extra bits for each bit length code */
        new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
      );
      var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
      var DIST_CODE_LEN = 512;
      var static_ltree = new Array((L_CODES + 2) * 2);
      zero(static_ltree);
      var static_dtree = new Array(D_CODES * 2);
      zero(static_dtree);
      var _dist_code = new Array(DIST_CODE_LEN);
      zero(_dist_code);
      var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
      zero(_length_code);
      var base_length = new Array(LENGTH_CODES);
      zero(base_length);
      var base_dist = new Array(D_CODES);
      zero(base_dist);
      function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
        this.static_tree = static_tree;
        this.extra_bits = extra_bits;
        this.extra_base = extra_base;
        this.elems = elems;
        this.max_length = max_length;
        this.has_stree = static_tree && static_tree.length;
      }
      var static_l_desc;
      var static_d_desc;
      var static_bl_desc;
      function TreeDesc(dyn_tree, stat_desc) {
        this.dyn_tree = dyn_tree;
        this.max_code = 0;
        this.stat_desc = stat_desc;
      }
      var d_code = (dist) => {
        return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
      };
      var put_short = (s, w) => {
        s.pending_buf[s.pending++] = w & 255;
        s.pending_buf[s.pending++] = w >>> 8 & 255;
      };
      var send_bits = (s, value, length) => {
        if (s.bi_valid > Buf_size - length) {
          s.bi_buf |= value << s.bi_valid & 65535;
          put_short(s, s.bi_buf);
          s.bi_buf = value >> Buf_size - s.bi_valid;
          s.bi_valid += length - Buf_size;
        } else {
          s.bi_buf |= value << s.bi_valid & 65535;
          s.bi_valid += length;
        }
      };
      var send_code = (s, c, tree) => {
        send_bits(
          s,
          tree[c * 2],
          tree[c * 2 + 1]
          /*.Len*/
        );
      };
      var bi_reverse = (code, len) => {
        let res = 0;
        do {
          res |= code & 1;
          code >>>= 1;
          res <<= 1;
        } while (--len > 0);
        return res >>> 1;
      };
      var bi_flush = (s) => {
        if (s.bi_valid === 16) {
          put_short(s, s.bi_buf);
          s.bi_buf = 0;
          s.bi_valid = 0;
        } else if (s.bi_valid >= 8) {
          s.pending_buf[s.pending++] = s.bi_buf & 255;
          s.bi_buf >>= 8;
          s.bi_valid -= 8;
        }
      };
      var gen_bitlen = (s, desc) => {
        const tree = desc.dyn_tree;
        const max_code = desc.max_code;
        const stree = desc.stat_desc.static_tree;
        const has_stree = desc.stat_desc.has_stree;
        const extra = desc.stat_desc.extra_bits;
        const base = desc.stat_desc.extra_base;
        const max_length = desc.stat_desc.max_length;
        let h;
        let n, m;
        let bits;
        let xbits;
        let f;
        let overflow = 0;
        for (bits = 0; bits <= MAX_BITS; bits++) {
          s.bl_count[bits] = 0;
        }
        tree[s.heap[s.heap_max] * 2 + 1] = 0;
        for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
          n = s.heap[h];
          bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
          if (bits > max_length) {
            bits = max_length;
            overflow++;
          }
          tree[n * 2 + 1] = bits;
          if (n > max_code) {
            continue;
          }
          s.bl_count[bits]++;
          xbits = 0;
          if (n >= base) {
            xbits = extra[n - base];
          }
          f = tree[n * 2];
          s.opt_len += f * (bits + xbits);
          if (has_stree) {
            s.static_len += f * (stree[n * 2 + 1] + xbits);
          }
        }
        if (overflow === 0) {
          return;
        }
        do {
          bits = max_length - 1;
          while (s.bl_count[bits] === 0) {
            bits--;
          }
          s.bl_count[bits]--;
          s.bl_count[bits + 1] += 2;
          s.bl_count[max_length]--;
          overflow -= 2;
        } while (overflow > 0);
        for (bits = max_length; bits !== 0; bits--) {
          n = s.bl_count[bits];
          while (n !== 0) {
            m = s.heap[--h];
            if (m > max_code) {
              continue;
            }
            if (tree[m * 2 + 1] !== bits) {
              s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
              tree[m * 2 + 1] = bits;
            }
            n--;
          }
        }
      };
      var gen_codes = (tree, max_code, bl_count) => {
        const next_code = new Array(MAX_BITS + 1);
        let code = 0;
        let bits;
        let n;
        for (bits = 1; bits <= MAX_BITS; bits++) {
          code = code + bl_count[bits - 1] << 1;
          next_code[bits] = code;
        }
        for (n = 0; n <= max_code; n++) {
          let len = tree[n * 2 + 1];
          if (len === 0) {
            continue;
          }
          tree[n * 2] = bi_reverse(next_code[len]++, len);
        }
      };
      var tr_static_init = () => {
        let n;
        let bits;
        let length;
        let code;
        let dist;
        const bl_count = new Array(MAX_BITS + 1);
        length = 0;
        for (code = 0; code < LENGTH_CODES - 1; code++) {
          base_length[code] = length;
          for (n = 0; n < 1 << extra_lbits[code]; n++) {
            _length_code[length++] = code;
          }
        }
        _length_code[length - 1] = code;
        dist = 0;
        for (code = 0; code < 16; code++) {
          base_dist[code] = dist;
          for (n = 0; n < 1 << extra_dbits[code]; n++) {
            _dist_code[dist++] = code;
          }
        }
        dist >>= 7;
        for (; code < D_CODES; code++) {
          base_dist[code] = dist << 7;
          for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
            _dist_code[256 + dist++] = code;
          }
        }
        for (bits = 0; bits <= MAX_BITS; bits++) {
          bl_count[bits] = 0;
        }
        n = 0;
        while (n <= 143) {
          static_ltree[n * 2 + 1] = 8;
          n++;
          bl_count[8]++;
        }
        while (n <= 255) {
          static_ltree[n * 2 + 1] = 9;
          n++;
          bl_count[9]++;
        }
        while (n <= 279) {
          static_ltree[n * 2 + 1] = 7;
          n++;
          bl_count[7]++;
        }
        while (n <= 287) {
          static_ltree[n * 2 + 1] = 8;
          n++;
          bl_count[8]++;
        }
        gen_codes(static_ltree, L_CODES + 1, bl_count);
        for (n = 0; n < D_CODES; n++) {
          static_dtree[n * 2 + 1] = 5;
          static_dtree[n * 2] = bi_reverse(n, 5);
        }
        static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
        static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
        static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
      };
      var init_block = (s) => {
        let n;
        for (n = 0; n < L_CODES; n++) {
          s.dyn_ltree[n * 2] = 0;
        }
        for (n = 0; n < D_CODES; n++) {
          s.dyn_dtree[n * 2] = 0;
        }
        for (n = 0; n < BL_CODES; n++) {
          s.bl_tree[n * 2] = 0;
        }
        s.dyn_ltree[END_BLOCK * 2] = 1;
        s.opt_len = s.static_len = 0;
        s.sym_next = s.matches = 0;
      };
      var bi_windup = (s) => {
        if (s.bi_valid > 8) {
          put_short(s, s.bi_buf);
        } else if (s.bi_valid > 0) {
          s.pending_buf[s.pending++] = s.bi_buf;
        }
        s.bi_buf = 0;
        s.bi_valid = 0;
      };
      var smaller = (tree, n, m, depth) => {
        const _n2 = n * 2;
        const _m2 = m * 2;
        return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
      };
      var pqdownheap = (s, tree, k) => {
        const v = s.heap[k];
        let j = k << 1;
        while (j <= s.heap_len) {
          if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
            j++;
          }
          if (smaller(tree, v, s.heap[j], s.depth)) {
            break;
          }
          s.heap[k] = s.heap[j];
          k = j;
          j <<= 1;
        }
        s.heap[k] = v;
      };
      var compress_block = (s, ltree, dtree) => {
        let dist;
        let lc;
        let sx = 0;
        let code;
        let extra;
        if (s.sym_next !== 0) {
          do {
            dist = s.pending_buf[s.sym_buf + sx++] & 255;
            dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
            lc = s.pending_buf[s.sym_buf + sx++];
            if (dist === 0) {
              send_code(s, lc, ltree);
            } else {
              code = _length_code[lc];
              send_code(s, code + LITERALS + 1, ltree);
              extra = extra_lbits[code];
              if (extra !== 0) {
                lc -= base_length[code];
                send_bits(s, lc, extra);
              }
              dist--;
              code = d_code(dist);
              send_code(s, code, dtree);
              extra = extra_dbits[code];
              if (extra !== 0) {
                dist -= base_dist[code];
                send_bits(s, dist, extra);
              }
            }
          } while (sx < s.sym_next);
        }
        send_code(s, END_BLOCK, ltree);
      };
      var build_tree = (s, desc) => {
        const tree = desc.dyn_tree;
        const stree = desc.stat_desc.static_tree;
        const has_stree = desc.stat_desc.has_stree;
        const elems = desc.stat_desc.elems;
        let n, m;
        let max_code = -1;
        let node;
        s.heap_len = 0;
        s.heap_max = HEAP_SIZE;
        for (n = 0; n < elems; n++) {
          if (tree[n * 2] !== 0) {
            s.heap[++s.heap_len] = max_code = n;
            s.depth[n] = 0;
          } else {
            tree[n * 2 + 1] = 0;
          }
        }
        while (s.heap_len < 2) {
          node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
          tree[node * 2] = 1;
          s.depth[node] = 0;
          s.opt_len--;
          if (has_stree) {
            s.static_len -= stree[node * 2 + 1];
          }
        }
        desc.max_code = max_code;
        for (n = s.heap_len >> 1; n >= 1; n--) {
          pqdownheap(s, tree, n);
        }
        node = elems;
        do {
          n = s.heap[
            1
            /*SMALLEST*/
          ];
          s.heap[
            1
            /*SMALLEST*/
          ] = s.heap[s.heap_len--];
          pqdownheap(
            s,
            tree,
            1
            /*SMALLEST*/
          );
          m = s.heap[
            1
            /*SMALLEST*/
          ];
          s.heap[--s.heap_max] = n;
          s.heap[--s.heap_max] = m;
          tree[node * 2] = tree[n * 2] + tree[m * 2];
          s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
          tree[n * 2 + 1] = tree[m * 2 + 1] = node;
          s.heap[
            1
            /*SMALLEST*/
          ] = node++;
          pqdownheap(
            s,
            tree,
            1
            /*SMALLEST*/
          );
        } while (s.heap_len >= 2);
        s.heap[--s.heap_max] = s.heap[
          1
          /*SMALLEST*/
        ];
        gen_bitlen(s, desc);
        gen_codes(tree, max_code, s.bl_count);
      };
      var scan_tree = (s, tree, max_code) => {
        let n;
        let prevlen = -1;
        let curlen;
        let nextlen = tree[0 * 2 + 1];
        let count = 0;
        let max_count = 7;
        let min_count = 4;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        }
        tree[(max_code + 1) * 2 + 1] = 65535;
        for (n = 0; n <= max_code; n++) {
          curlen = nextlen;
          nextlen = tree[(n + 1) * 2 + 1];
          if (++count < max_count && curlen === nextlen) {
            continue;
          } else if (count < min_count) {
            s.bl_tree[curlen * 2] += count;
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              s.bl_tree[curlen * 2]++;
            }
            s.bl_tree[REP_3_6 * 2]++;
          } else if (count <= 10) {
            s.bl_tree[REPZ_3_10 * 2]++;
          } else {
            s.bl_tree[REPZ_11_138 * 2]++;
          }
          count = 0;
          prevlen = curlen;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
          } else {
            max_count = 7;
            min_count = 4;
          }
        }
      };
      var send_tree = (s, tree, max_code) => {
        let n;
        let prevlen = -1;
        let curlen;
        let nextlen = tree[0 * 2 + 1];
        let count = 0;
        let max_count = 7;
        let min_count = 4;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        }
        for (n = 0; n <= max_code; n++) {
          curlen = nextlen;
          nextlen = tree[(n + 1) * 2 + 1];
          if (++count < max_count && curlen === nextlen) {
            continue;
          } else if (count < min_count) {
            do {
              send_code(s, curlen, s.bl_tree);
            } while (--count !== 0);
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              send_code(s, curlen, s.bl_tree);
              count--;
            }
            send_code(s, REP_3_6, s.bl_tree);
            send_bits(s, count - 3, 2);
          } else if (count <= 10) {
            send_code(s, REPZ_3_10, s.bl_tree);
            send_bits(s, count - 3, 3);
          } else {
            send_code(s, REPZ_11_138, s.bl_tree);
            send_bits(s, count - 11, 7);
          }
          count = 0;
          prevlen = curlen;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
          } else {
            max_count = 7;
            min_count = 4;
          }
        }
      };
      var build_bl_tree = (s) => {
        let max_blindex;
        scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
        scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
        build_tree(s, s.bl_desc);
        for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
          if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
            break;
          }
        }
        s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
        return max_blindex;
      };
      var send_all_trees = (s, lcodes, dcodes, blcodes) => {
        let rank;
        send_bits(s, lcodes - 257, 5);
        send_bits(s, dcodes - 1, 5);
        send_bits(s, blcodes - 4, 4);
        for (rank = 0; rank < blcodes; rank++) {
          send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
        }
        send_tree(s, s.dyn_ltree, lcodes - 1);
        send_tree(s, s.dyn_dtree, dcodes - 1);
      };
      var detect_data_type = (s) => {
        let block_mask = 4093624447;
        let n;
        for (n = 0; n <= 31; n++, block_mask >>>= 1) {
          if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
            return Z_BINARY;
          }
        }
        if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
          return Z_TEXT;
        }
        for (n = 32; n < LITERALS; n++) {
          if (s.dyn_ltree[n * 2] !== 0) {
            return Z_TEXT;
          }
        }
        return Z_BINARY;
      };
      var static_init_done = false;
      var _tr_init = (s) => {
        if (!static_init_done) {
          tr_static_init();
          static_init_done = true;
        }
        s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
        s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
        s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
        s.bi_buf = 0;
        s.bi_valid = 0;
        init_block(s);
      };
      var _tr_stored_block = (s, buf, stored_len, last) => {
        send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
        bi_windup(s);
        put_short(s, stored_len);
        put_short(s, ~stored_len);
        if (stored_len) {
          s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
        }
        s.pending += stored_len;
      };
      var _tr_align = (s) => {
        send_bits(s, STATIC_TREES << 1, 3);
        send_code(s, END_BLOCK, static_ltree);
        bi_flush(s);
      };
      var _tr_flush_block = (s, buf, stored_len, last) => {
        let opt_lenb, static_lenb;
        let max_blindex = 0;
        if (s.level > 0) {
          if (s.strm.data_type === Z_UNKNOWN) {
            s.strm.data_type = detect_data_type(s);
          }
          build_tree(s, s.l_desc);
          build_tree(s, s.d_desc);
          max_blindex = build_bl_tree(s);
          opt_lenb = s.opt_len + 3 + 7 >>> 3;
          static_lenb = s.static_len + 3 + 7 >>> 3;
          if (static_lenb <= opt_lenb) {
            opt_lenb = static_lenb;
          }
        } else {
          opt_lenb = static_lenb = stored_len + 5;
        }
        if (stored_len + 4 <= opt_lenb && buf !== -1) {
          _tr_stored_block(s, buf, stored_len, last);
        } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
          send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
          compress_block(s, static_ltree, static_dtree);
        } else {
          send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
          send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
          compress_block(s, s.dyn_ltree, s.dyn_dtree);
        }
        init_block(s);
        if (last) {
          bi_windup(s);
        }
      };
      var _tr_tally = (s, dist, lc) => {
        s.pending_buf[s.sym_buf + s.sym_next++] = dist;
        s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
        s.pending_buf[s.sym_buf + s.sym_next++] = lc;
        if (dist === 0) {
          s.dyn_ltree[lc * 2]++;
        } else {
          s.matches++;
          dist--;
          s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
          s.dyn_dtree[d_code(dist) * 2]++;
        }
        return s.sym_next === s.sym_end;
      };
      module.exports._tr_init = _tr_init;
      module.exports._tr_stored_block = _tr_stored_block;
      module.exports._tr_flush_block = _tr_flush_block;
      module.exports._tr_tally = _tr_tally;
      module.exports._tr_align = _tr_align;
    }
  });

  // node_modules/pako/lib/zlib/adler32.js
  var require_adler32 = __commonJS({
    "node_modules/pako/lib/zlib/adler32.js"(exports, module) {
      "use strict";
      var adler32 = (adler, buf, len, pos) => {
        let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
        while (len !== 0) {
          n = len > 2e3 ? 2e3 : len;
          len -= n;
          do {
            s1 = s1 + buf[pos++] | 0;
            s2 = s2 + s1 | 0;
          } while (--n);
          s1 %= 65521;
          s2 %= 65521;
        }
        return s1 | s2 << 16 | 0;
      };
      module.exports = adler32;
    }
  });

  // node_modules/pako/lib/zlib/crc32.js
  var require_crc32 = __commonJS({
    "node_modules/pako/lib/zlib/crc32.js"(exports, module) {
      "use strict";
      var makeTable = () => {
        let c, table = [];
        for (var n = 0; n < 256; n++) {
          c = n;
          for (var k = 0; k < 8; k++) {
            c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
          }
          table[n] = c;
        }
        return table;
      };
      var crcTable = new Uint32Array(makeTable());
      var crc32 = (crc, buf, len, pos) => {
        const t = crcTable;
        const end = pos + len;
        crc ^= -1;
        for (let i = pos; i < end; i++) {
          crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
        }
        return crc ^ -1;
      };
      module.exports = crc32;
    }
  });

  // node_modules/pako/lib/zlib/messages.js
  var require_messages = __commonJS({
    "node_modules/pako/lib/zlib/messages.js"(exports, module) {
      "use strict";
      module.exports = {
        2: "need dictionary",
        /* Z_NEED_DICT       2  */
        1: "stream end",
        /* Z_STREAM_END      1  */
        0: "",
        /* Z_OK              0  */
        "-1": "file error",
        /* Z_ERRNO         (-1) */
        "-2": "stream error",
        /* Z_STREAM_ERROR  (-2) */
        "-3": "data error",
        /* Z_DATA_ERROR    (-3) */
        "-4": "insufficient memory",
        /* Z_MEM_ERROR     (-4) */
        "-5": "buffer error",
        /* Z_BUF_ERROR     (-5) */
        "-6": "incompatible version"
        /* Z_VERSION_ERROR (-6) */
      };
    }
  });

  // node_modules/pako/lib/zlib/constants.js
  var require_constants = __commonJS({
    "node_modules/pako/lib/zlib/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        /* Allowed flush values; see deflate() and inflate() below for details */
        Z_NO_FLUSH: 0,
        Z_PARTIAL_FLUSH: 1,
        Z_SYNC_FLUSH: 2,
        Z_FULL_FLUSH: 3,
        Z_FINISH: 4,
        Z_BLOCK: 5,
        Z_TREES: 6,
        /* Return codes for the compression/decompression functions. Negative values
        * are errors, positive values are used for special but normal events.
        */
        Z_OK: 0,
        Z_STREAM_END: 1,
        Z_NEED_DICT: 2,
        Z_ERRNO: -1,
        Z_STREAM_ERROR: -2,
        Z_DATA_ERROR: -3,
        Z_MEM_ERROR: -4,
        Z_BUF_ERROR: -5,
        //Z_VERSION_ERROR: -6,
        /* compression levels */
        Z_NO_COMPRESSION: 0,
        Z_BEST_SPEED: 1,
        Z_BEST_COMPRESSION: 9,
        Z_DEFAULT_COMPRESSION: -1,
        Z_FILTERED: 1,
        Z_HUFFMAN_ONLY: 2,
        Z_RLE: 3,
        Z_FIXED: 4,
        Z_DEFAULT_STRATEGY: 0,
        /* Possible values of the data_type field (though see inflate()) */
        Z_BINARY: 0,
        Z_TEXT: 1,
        //Z_ASCII:                1, // = Z_TEXT (deprecated)
        Z_UNKNOWN: 2,
        /* The deflate compression method */
        Z_DEFLATED: 8
        //Z_NULL:                 null // Use -1 or null inline, depending on var type
      };
    }
  });

  // node_modules/pako/lib/zlib/deflate.js
  var require_deflate = __commonJS({
    "node_modules/pako/lib/zlib/deflate.js"(exports, module) {
      "use strict";
      var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = require_trees();
      var adler32 = require_adler32();
      var crc32 = require_crc32();
      var msg = require_messages();
      var {
        Z_NO_FLUSH,
        Z_PARTIAL_FLUSH,
        Z_FULL_FLUSH,
        Z_FINISH,
        Z_BLOCK,
        Z_OK,
        Z_STREAM_END,
        Z_STREAM_ERROR,
        Z_DATA_ERROR,
        Z_BUF_ERROR,
        Z_DEFAULT_COMPRESSION,
        Z_FILTERED,
        Z_HUFFMAN_ONLY,
        Z_RLE,
        Z_FIXED,
        Z_DEFAULT_STRATEGY,
        Z_UNKNOWN,
        Z_DEFLATED
      } = require_constants();
      var MAX_MEM_LEVEL = 9;
      var MAX_WBITS = 15;
      var DEF_MEM_LEVEL = 8;
      var LENGTH_CODES = 29;
      var LITERALS = 256;
      var L_CODES = LITERALS + 1 + LENGTH_CODES;
      var D_CODES = 30;
      var BL_CODES = 19;
      var HEAP_SIZE = 2 * L_CODES + 1;
      var MAX_BITS = 15;
      var MIN_MATCH = 3;
      var MAX_MATCH = 258;
      var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
      var PRESET_DICT = 32;
      var INIT_STATE = 42;
      var GZIP_STATE = 57;
      var EXTRA_STATE = 69;
      var NAME_STATE = 73;
      var COMMENT_STATE = 91;
      var HCRC_STATE = 103;
      var BUSY_STATE = 113;
      var FINISH_STATE = 666;
      var BS_NEED_MORE = 1;
      var BS_BLOCK_DONE = 2;
      var BS_FINISH_STARTED = 3;
      var BS_FINISH_DONE = 4;
      var OS_CODE = 3;
      var err = (strm, errorCode) => {
        strm.msg = msg[errorCode];
        return errorCode;
      };
      var rank = (f) => {
        return f * 2 - (f > 4 ? 9 : 0);
      };
      var zero = (buf) => {
        let len = buf.length;
        while (--len >= 0) {
          buf[len] = 0;
        }
      };
      var slide_hash = (s) => {
        let n, m;
        let p;
        let wsize = s.w_size;
        n = s.hash_size;
        p = n;
        do {
          m = s.head[--p];
          s.head[p] = m >= wsize ? m - wsize : 0;
        } while (--n);
        n = wsize;
        p = n;
        do {
          m = s.prev[--p];
          s.prev[p] = m >= wsize ? m - wsize : 0;
        } while (--n);
      };
      var HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
      var HASH = HASH_ZLIB;
      var flush_pending = (strm) => {
        const s = strm.state;
        let len = s.pending;
        if (len > strm.avail_out) {
          len = strm.avail_out;
        }
        if (len === 0) {
          return;
        }
        strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
        strm.next_out += len;
        s.pending_out += len;
        strm.total_out += len;
        strm.avail_out -= len;
        s.pending -= len;
        if (s.pending === 0) {
          s.pending_out = 0;
        }
      };
      var flush_block_only = (s, last) => {
        _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
        s.block_start = s.strstart;
        flush_pending(s.strm);
      };
      var put_byte = (s, b) => {
        s.pending_buf[s.pending++] = b;
      };
      var putShortMSB = (s, b) => {
        s.pending_buf[s.pending++] = b >>> 8 & 255;
        s.pending_buf[s.pending++] = b & 255;
      };
      var read_buf = (strm, buf, start, size) => {
        let len = strm.avail_in;
        if (len > size) {
          len = size;
        }
        if (len === 0) {
          return 0;
        }
        strm.avail_in -= len;
        buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
        if (strm.state.wrap === 1) {
          strm.adler = adler32(strm.adler, buf, len, start);
        } else if (strm.state.wrap === 2) {
          strm.adler = crc32(strm.adler, buf, len, start);
        }
        strm.next_in += len;
        strm.total_in += len;
        return len;
      };
      var longest_match = (s, cur_match) => {
        let chain_length = s.max_chain_length;
        let scan = s.strstart;
        let match;
        let len;
        let best_len = s.prev_length;
        let nice_match = s.nice_match;
        const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
        const _win = s.window;
        const wmask = s.w_mask;
        const prev = s.prev;
        const strend = s.strstart + MAX_MATCH;
        let scan_end1 = _win[scan + best_len - 1];
        let scan_end = _win[scan + best_len];
        if (s.prev_length >= s.good_match) {
          chain_length >>= 2;
        }
        if (nice_match > s.lookahead) {
          nice_match = s.lookahead;
        }
        do {
          match = cur_match;
          if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
            continue;
          }
          scan += 2;
          match++;
          do {
          } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
          len = MAX_MATCH - (strend - scan);
          scan = strend - MAX_MATCH;
          if (len > best_len) {
            s.match_start = cur_match;
            best_len = len;
            if (len >= nice_match) {
              break;
            }
            scan_end1 = _win[scan + best_len - 1];
            scan_end = _win[scan + best_len];
          }
        } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
        if (best_len <= s.lookahead) {
          return best_len;
        }
        return s.lookahead;
      };
      var fill_window = (s) => {
        const _w_size = s.w_size;
        let n, more, str;
        do {
          more = s.window_size - s.lookahead - s.strstart;
          if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
            s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
            s.match_start -= _w_size;
            s.strstart -= _w_size;
            s.block_start -= _w_size;
            if (s.insert > s.strstart) {
              s.insert = s.strstart;
            }
            slide_hash(s);
            more += _w_size;
          }
          if (s.strm.avail_in === 0) {
            break;
          }
          n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
          s.lookahead += n;
          if (s.lookahead + s.insert >= MIN_MATCH) {
            str = s.strstart - s.insert;
            s.ins_h = s.window[str];
            s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
            while (s.insert) {
              s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
              s.prev[str & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = str;
              str++;
              s.insert--;
              if (s.lookahead + s.insert < MIN_MATCH) {
                break;
              }
            }
          }
        } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
      };
      var deflate_stored = (s, flush) => {
        let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
        let len, left, have, last = 0;
        let used = s.strm.avail_in;
        do {
          len = 65535;
          have = s.bi_valid + 42 >> 3;
          if (s.strm.avail_out < have) {
            break;
          }
          have = s.strm.avail_out - have;
          left = s.strstart - s.block_start;
          if (len > left + s.strm.avail_in) {
            len = left + s.strm.avail_in;
          }
          if (len > have) {
            len = have;
          }
          if (len < min_block && (len === 0 && flush !== Z_FINISH || flush === Z_NO_FLUSH || len !== left + s.strm.avail_in)) {
            break;
          }
          last = flush === Z_FINISH && len === left + s.strm.avail_in ? 1 : 0;
          _tr_stored_block(s, 0, 0, last);
          s.pending_buf[s.pending - 4] = len;
          s.pending_buf[s.pending - 3] = len >> 8;
          s.pending_buf[s.pending - 2] = ~len;
          s.pending_buf[s.pending - 1] = ~len >> 8;
          flush_pending(s.strm);
          if (left) {
            if (left > len) {
              left = len;
            }
            s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
            s.strm.next_out += left;
            s.strm.avail_out -= left;
            s.strm.total_out += left;
            s.block_start += left;
            len -= left;
          }
          if (len) {
            read_buf(s.strm, s.strm.output, s.strm.next_out, len);
            s.strm.next_out += len;
            s.strm.avail_out -= len;
            s.strm.total_out += len;
          }
        } while (last === 0);
        used -= s.strm.avail_in;
        if (used) {
          if (used >= s.w_size) {
            s.matches = 2;
            s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
            s.strstart = s.w_size;
            s.insert = s.strstart;
          } else {
            if (s.window_size - s.strstart <= used) {
              s.strstart -= s.w_size;
              s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
              if (s.matches < 2) {
                s.matches++;
              }
              if (s.insert > s.strstart) {
                s.insert = s.strstart;
              }
            }
            s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
            s.strstart += used;
            s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
          }
          s.block_start = s.strstart;
        }
        if (s.high_water < s.strstart) {
          s.high_water = s.strstart;
        }
        if (last) {
          return BS_FINISH_DONE;
        }
        if (flush !== Z_NO_FLUSH && flush !== Z_FINISH && s.strm.avail_in === 0 && s.strstart === s.block_start) {
          return BS_BLOCK_DONE;
        }
        have = s.window_size - s.strstart;
        if (s.strm.avail_in > have && s.block_start >= s.w_size) {
          s.block_start -= s.w_size;
          s.strstart -= s.w_size;
          s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
          if (s.matches < 2) {
            s.matches++;
          }
          have += s.w_size;
          if (s.insert > s.strstart) {
            s.insert = s.strstart;
          }
        }
        if (have > s.strm.avail_in) {
          have = s.strm.avail_in;
        }
        if (have) {
          read_buf(s.strm, s.window, s.strstart, have);
          s.strstart += have;
          s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
        }
        if (s.high_water < s.strstart) {
          s.high_water = s.strstart;
        }
        have = s.bi_valid + 42 >> 3;
        have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
        min_block = have > s.w_size ? s.w_size : have;
        left = s.strstart - s.block_start;
        if (left >= min_block || (left || flush === Z_FINISH) && flush !== Z_NO_FLUSH && s.strm.avail_in === 0 && left <= have) {
          len = left > have ? have : left;
          last = flush === Z_FINISH && s.strm.avail_in === 0 && len === left ? 1 : 0;
          _tr_stored_block(s, s.block_start, len, last);
          s.block_start += len;
          flush_pending(s.strm);
        }
        return last ? BS_FINISH_STARTED : BS_NEED_MORE;
      };
      var deflate_fast = (s, flush) => {
        let hash_head;
        let bflush;
        for (; ; ) {
          if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          hash_head = 0;
          if (s.lookahead >= MIN_MATCH) {
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
          if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
            s.match_length = longest_match(s, hash_head);
          }
          if (s.match_length >= MIN_MATCH) {
            bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
            s.lookahead -= s.match_length;
            if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
              s.match_length--;
              do {
                s.strstart++;
                s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
              } while (--s.match_length !== 0);
              s.strstart++;
            } else {
              s.strstart += s.match_length;
              s.match_length = 0;
              s.ins_h = s.window[s.strstart];
              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
            }
          } else {
            bflush = _tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
          }
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.sym_next) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      };
      var deflate_slow = (s, flush) => {
        let hash_head;
        let bflush;
        let max_insert;
        for (; ; ) {
          if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          hash_head = 0;
          if (s.lookahead >= MIN_MATCH) {
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
          s.prev_length = s.match_length;
          s.prev_match = s.match_start;
          s.match_length = MIN_MATCH - 1;
          if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
            s.match_length = longest_match(s, hash_head);
            if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
              s.match_length = MIN_MATCH - 1;
            }
          }
          if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
            max_insert = s.strstart + s.lookahead - MIN_MATCH;
            bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
            s.lookahead -= s.prev_length - 1;
            s.prev_length -= 2;
            do {
              if (++s.strstart <= max_insert) {
                s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
              }
            } while (--s.prev_length !== 0);
            s.match_available = 0;
            s.match_length = MIN_MATCH - 1;
            s.strstart++;
            if (bflush) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          } else if (s.match_available) {
            bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
            if (bflush) {
              flush_block_only(s, false);
            }
            s.strstart++;
            s.lookahead--;
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          } else {
            s.match_available = 1;
            s.strstart++;
            s.lookahead--;
          }
        }
        if (s.match_available) {
          bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
          s.match_available = 0;
        }
        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.sym_next) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      };
      var deflate_rle = (s, flush) => {
        let bflush;
        let prev;
        let scan, strend;
        const _win = s.window;
        for (; ; ) {
          if (s.lookahead <= MAX_MATCH) {
            fill_window(s);
            if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          s.match_length = 0;
          if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
            scan = s.strstart - 1;
            prev = _win[scan];
            if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
              strend = s.strstart + MAX_MATCH;
              do {
              } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
              s.match_length = MAX_MATCH - (strend - scan);
              if (s.match_length > s.lookahead) {
                s.match_length = s.lookahead;
              }
            }
          }
          if (s.match_length >= MIN_MATCH) {
            bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
            s.lookahead -= s.match_length;
            s.strstart += s.match_length;
            s.match_length = 0;
          } else {
            bflush = _tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
          }
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.sym_next) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      };
      var deflate_huff = (s, flush) => {
        let bflush;
        for (; ; ) {
          if (s.lookahead === 0) {
            fill_window(s);
            if (s.lookahead === 0) {
              if (flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }
              break;
            }
          }
          s.match_length = 0;
          bflush = _tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.sym_next) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      };
      function Config(good_length, max_lazy, nice_length, max_chain, func) {
        this.good_length = good_length;
        this.max_lazy = max_lazy;
        this.nice_length = nice_length;
        this.max_chain = max_chain;
        this.func = func;
      }
      var configuration_table = [
        /*      good lazy nice chain */
        new Config(0, 0, 0, 0, deflate_stored),
        /* 0 store only */
        new Config(4, 4, 8, 4, deflate_fast),
        /* 1 max speed, no lazy matches */
        new Config(4, 5, 16, 8, deflate_fast),
        /* 2 */
        new Config(4, 6, 32, 32, deflate_fast),
        /* 3 */
        new Config(4, 4, 16, 16, deflate_slow),
        /* 4 lazy matches */
        new Config(8, 16, 32, 32, deflate_slow),
        /* 5 */
        new Config(8, 16, 128, 128, deflate_slow),
        /* 6 */
        new Config(8, 32, 128, 256, deflate_slow),
        /* 7 */
        new Config(32, 128, 258, 1024, deflate_slow),
        /* 8 */
        new Config(32, 258, 258, 4096, deflate_slow)
        /* 9 max compression */
      ];
      var lm_init = (s) => {
        s.window_size = 2 * s.w_size;
        zero(s.head);
        s.max_lazy_match = configuration_table[s.level].max_lazy;
        s.good_match = configuration_table[s.level].good_length;
        s.nice_match = configuration_table[s.level].nice_length;
        s.max_chain_length = configuration_table[s.level].max_chain;
        s.strstart = 0;
        s.block_start = 0;
        s.lookahead = 0;
        s.insert = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        s.ins_h = 0;
      };
      function DeflateState() {
        this.strm = null;
        this.status = 0;
        this.pending_buf = null;
        this.pending_buf_size = 0;
        this.pending_out = 0;
        this.pending = 0;
        this.wrap = 0;
        this.gzhead = null;
        this.gzindex = 0;
        this.method = Z_DEFLATED;
        this.last_flush = -1;
        this.w_size = 0;
        this.w_bits = 0;
        this.w_mask = 0;
        this.window = null;
        this.window_size = 0;
        this.prev = null;
        this.head = null;
        this.ins_h = 0;
        this.hash_size = 0;
        this.hash_bits = 0;
        this.hash_mask = 0;
        this.hash_shift = 0;
        this.block_start = 0;
        this.match_length = 0;
        this.prev_match = 0;
        this.match_available = 0;
        this.strstart = 0;
        this.match_start = 0;
        this.lookahead = 0;
        this.prev_length = 0;
        this.max_chain_length = 0;
        this.max_lazy_match = 0;
        this.level = 0;
        this.strategy = 0;
        this.good_match = 0;
        this.nice_match = 0;
        this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
        this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
        this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
        zero(this.dyn_ltree);
        zero(this.dyn_dtree);
        zero(this.bl_tree);
        this.l_desc = null;
        this.d_desc = null;
        this.bl_desc = null;
        this.bl_count = new Uint16Array(MAX_BITS + 1);
        this.heap = new Uint16Array(2 * L_CODES + 1);
        zero(this.heap);
        this.heap_len = 0;
        this.heap_max = 0;
        this.depth = new Uint16Array(2 * L_CODES + 1);
        zero(this.depth);
        this.sym_buf = 0;
        this.lit_bufsize = 0;
        this.sym_next = 0;
        this.sym_end = 0;
        this.opt_len = 0;
        this.static_len = 0;
        this.matches = 0;
        this.insert = 0;
        this.bi_buf = 0;
        this.bi_valid = 0;
      }
      var deflateStateCheck = (strm) => {
        if (!strm) {
          return 1;
        }
        const s = strm.state;
        if (!s || s.strm !== strm || s.status !== INIT_STATE && //#ifdef GZIP
        s.status !== GZIP_STATE && //#endif
        s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
          return 1;
        }
        return 0;
      };
      var deflateResetKeep = (strm) => {
        if (deflateStateCheck(strm)) {
          return err(strm, Z_STREAM_ERROR);
        }
        strm.total_in = strm.total_out = 0;
        strm.data_type = Z_UNKNOWN;
        const s = strm.state;
        s.pending = 0;
        s.pending_out = 0;
        if (s.wrap < 0) {
          s.wrap = -s.wrap;
        }
        s.status = //#ifdef GZIP
        s.wrap === 2 ? GZIP_STATE : (
          //#endif
          s.wrap ? INIT_STATE : BUSY_STATE
        );
        strm.adler = s.wrap === 2 ? 0 : 1;
        s.last_flush = -2;
        _tr_init(s);
        return Z_OK;
      };
      var deflateReset = (strm) => {
        const ret = deflateResetKeep(strm);
        if (ret === Z_OK) {
          lm_init(strm.state);
        }
        return ret;
      };
      var deflateSetHeader = (strm, head) => {
        if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
          return Z_STREAM_ERROR;
        }
        strm.state.gzhead = head;
        return Z_OK;
      };
      var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
        if (!strm) {
          return Z_STREAM_ERROR;
        }
        let wrap = 1;
        if (level === Z_DEFAULT_COMPRESSION) {
          level = 6;
        }
        if (windowBits < 0) {
          wrap = 0;
          windowBits = -windowBits;
        } else if (windowBits > 15) {
          wrap = 2;
          windowBits -= 16;
        }
        if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
          return err(strm, Z_STREAM_ERROR);
        }
        if (windowBits === 8) {
          windowBits = 9;
        }
        const s = new DeflateState();
        strm.state = s;
        s.strm = strm;
        s.status = INIT_STATE;
        s.wrap = wrap;
        s.gzhead = null;
        s.w_bits = windowBits;
        s.w_size = 1 << s.w_bits;
        s.w_mask = s.w_size - 1;
        s.hash_bits = memLevel + 7;
        s.hash_size = 1 << s.hash_bits;
        s.hash_mask = s.hash_size - 1;
        s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
        s.window = new Uint8Array(s.w_size * 2);
        s.head = new Uint16Array(s.hash_size);
        s.prev = new Uint16Array(s.w_size);
        s.lit_bufsize = 1 << memLevel + 6;
        s.pending_buf_size = s.lit_bufsize * 4;
        s.pending_buf = new Uint8Array(s.pending_buf_size);
        s.sym_buf = s.lit_bufsize;
        s.sym_end = (s.lit_bufsize - 1) * 3;
        s.level = level;
        s.strategy = strategy;
        s.method = method;
        return deflateReset(strm);
      };
      var deflateInit = (strm, level) => {
        return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
      };
      var deflate = (strm, flush) => {
        if (deflateStateCheck(strm) || flush > Z_BLOCK || flush < 0) {
          return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
        }
        const s = strm.state;
        if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH) {
          return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
        }
        const old_flush = s.last_flush;
        s.last_flush = flush;
        if (s.pending !== 0) {
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
          return err(strm, Z_BUF_ERROR);
        }
        if (s.status === FINISH_STATE && strm.avail_in !== 0) {
          return err(strm, Z_BUF_ERROR);
        }
        if (s.status === INIT_STATE && s.wrap === 0) {
          s.status = BUSY_STATE;
        }
        if (s.status === INIT_STATE) {
          let header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
          let level_flags = -1;
          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          putShortMSB(s, header);
          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 65535);
          }
          strm.adler = 1;
          s.status = BUSY_STATE;
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
        if (s.status === GZIP_STATE) {
          strm.adler = 0;
          put_byte(s, 31);
          put_byte(s, 139);
          put_byte(s, 8);
          if (!s.gzhead) {
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, OS_CODE);
            s.status = BUSY_STATE;
            flush_pending(strm);
            if (s.pending !== 0) {
              s.last_flush = -1;
              return Z_OK;
            }
          } else {
            put_byte(
              s,
              (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
            );
            put_byte(s, s.gzhead.time & 255);
            put_byte(s, s.gzhead.time >> 8 & 255);
            put_byte(s, s.gzhead.time >> 16 & 255);
            put_byte(s, s.gzhead.time >> 24 & 255);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, s.gzhead.os & 255);
            if (s.gzhead.extra && s.gzhead.extra.length) {
              put_byte(s, s.gzhead.extra.length & 255);
              put_byte(s, s.gzhead.extra.length >> 8 & 255);
            }
            if (s.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
            }
            s.gzindex = 0;
            s.status = EXTRA_STATE;
          }
        }
        if (s.status === EXTRA_STATE) {
          if (s.gzhead.extra) {
            let beg = s.pending;
            let left = (s.gzhead.extra.length & 65535) - s.gzindex;
            while (s.pending + left > s.pending_buf_size) {
              let copy = s.pending_buf_size - s.pending;
              s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
              s.pending = s.pending_buf_size;
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              s.gzindex += copy;
              flush_pending(strm);
              if (s.pending !== 0) {
                s.last_flush = -1;
                return Z_OK;
              }
              beg = 0;
              left -= copy;
            }
            let gzhead_extra = new Uint8Array(s.gzhead.extra);
            s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
            s.pending += left;
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            s.gzindex = 0;
          }
          s.status = NAME_STATE;
        }
        if (s.status === NAME_STATE) {
          if (s.gzhead.name) {
            let beg = s.pending;
            let val;
            do {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                flush_pending(strm);
                if (s.pending !== 0) {
                  s.last_flush = -1;
                  return Z_OK;
                }
                beg = 0;
              }
              if (s.gzindex < s.gzhead.name.length) {
                val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
              } else {
                val = 0;
              }
              put_byte(s, val);
            } while (val !== 0);
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            s.gzindex = 0;
          }
          s.status = COMMENT_STATE;
        }
        if (s.status === COMMENT_STATE) {
          if (s.gzhead.comment) {
            let beg = s.pending;
            let val;
            do {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                flush_pending(strm);
                if (s.pending !== 0) {
                  s.last_flush = -1;
                  return Z_OK;
                }
                beg = 0;
              }
              if (s.gzindex < s.gzhead.comment.length) {
                val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
              } else {
                val = 0;
              }
              put_byte(s, val);
            } while (val !== 0);
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
          }
          s.status = HCRC_STATE;
        }
        if (s.status === HCRC_STATE) {
          if (s.gzhead.hcrc) {
            if (s.pending + 2 > s.pending_buf_size) {
              flush_pending(strm);
              if (s.pending !== 0) {
                s.last_flush = -1;
                return Z_OK;
              }
            }
            put_byte(s, strm.adler & 255);
            put_byte(s, strm.adler >> 8 & 255);
            strm.adler = 0;
          }
          s.status = BUSY_STATE;
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
        if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
          let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
          if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
            s.status = FINISH_STATE;
          }
          if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
            if (strm.avail_out === 0) {
              s.last_flush = -1;
            }
            return Z_OK;
          }
          if (bstate === BS_BLOCK_DONE) {
            if (flush === Z_PARTIAL_FLUSH) {
              _tr_align(s);
            } else if (flush !== Z_BLOCK) {
              _tr_stored_block(s, 0, 0, false);
              if (flush === Z_FULL_FLUSH) {
                zero(s.head);
                if (s.lookahead === 0) {
                  s.strstart = 0;
                  s.block_start = 0;
                  s.insert = 0;
                }
              }
            }
            flush_pending(strm);
            if (strm.avail_out === 0) {
              s.last_flush = -1;
              return Z_OK;
            }
          }
        }
        if (flush !== Z_FINISH) {
          return Z_OK;
        }
        if (s.wrap <= 0) {
          return Z_STREAM_END;
        }
        if (s.wrap === 2) {
          put_byte(s, strm.adler & 255);
          put_byte(s, strm.adler >> 8 & 255);
          put_byte(s, strm.adler >> 16 & 255);
          put_byte(s, strm.adler >> 24 & 255);
          put_byte(s, strm.total_in & 255);
          put_byte(s, strm.total_in >> 8 & 255);
          put_byte(s, strm.total_in >> 16 & 255);
          put_byte(s, strm.total_in >> 24 & 255);
        } else {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 65535);
        }
        flush_pending(strm);
        if (s.wrap > 0) {
          s.wrap = -s.wrap;
        }
        return s.pending !== 0 ? Z_OK : Z_STREAM_END;
      };
      var deflateEnd = (strm) => {
        if (deflateStateCheck(strm)) {
          return Z_STREAM_ERROR;
        }
        const status = strm.state.status;
        strm.state = null;
        return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
      };
      var deflateSetDictionary = (strm, dictionary) => {
        let dictLength = dictionary.length;
        if (deflateStateCheck(strm)) {
          return Z_STREAM_ERROR;
        }
        const s = strm.state;
        const wrap = s.wrap;
        if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
          return Z_STREAM_ERROR;
        }
        if (wrap === 1) {
          strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
        }
        s.wrap = 0;
        if (dictLength >= s.w_size) {
          if (wrap === 0) {
            zero(s.head);
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
          let tmpDict = new Uint8Array(s.w_size);
          tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
          dictionary = tmpDict;
          dictLength = s.w_size;
        }
        const avail = strm.avail_in;
        const next = strm.next_in;
        const input = strm.input;
        strm.avail_in = dictLength;
        strm.next_in = 0;
        strm.input = dictionary;
        fill_window(s);
        while (s.lookahead >= MIN_MATCH) {
          let str = s.strstart;
          let n = s.lookahead - (MIN_MATCH - 1);
          do {
            s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
          } while (--n);
          s.strstart = str;
          s.lookahead = MIN_MATCH - 1;
          fill_window(s);
        }
        s.strstart += s.lookahead;
        s.block_start = s.strstart;
        s.insert = s.lookahead;
        s.lookahead = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        strm.next_in = next;
        strm.input = input;
        strm.avail_in = avail;
        s.wrap = wrap;
        return Z_OK;
      };
      module.exports.deflateInit = deflateInit;
      module.exports.deflateInit2 = deflateInit2;
      module.exports.deflateReset = deflateReset;
      module.exports.deflateResetKeep = deflateResetKeep;
      module.exports.deflateSetHeader = deflateSetHeader;
      module.exports.deflate = deflate;
      module.exports.deflateEnd = deflateEnd;
      module.exports.deflateSetDictionary = deflateSetDictionary;
      module.exports.deflateInfo = "pako deflate (from Nodeca project)";
    }
  });

  // node_modules/pako/lib/utils/common.js
  var require_common = __commonJS({
    "node_modules/pako/lib/utils/common.js"(exports, module) {
      "use strict";
      var _has = (obj, key) => {
        return Object.prototype.hasOwnProperty.call(obj, key);
      };
      module.exports.assign = function(obj) {
        const sources = Array.prototype.slice.call(arguments, 1);
        while (sources.length) {
          const source = sources.shift();
          if (!source) {
            continue;
          }
          if (typeof source !== "object") {
            throw new TypeError(source + "must be non-object");
          }
          for (const p in source) {
            if (_has(source, p)) {
              obj[p] = source[p];
            }
          }
        }
        return obj;
      };
      module.exports.flattenChunks = (chunks) => {
        let len = 0;
        for (let i = 0, l = chunks.length; i < l; i++) {
          len += chunks[i].length;
        }
        const result = new Uint8Array(len);
        for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
          let chunk = chunks[i];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      };
    }
  });

  // node_modules/pako/lib/utils/strings.js
  var require_strings = __commonJS({
    "node_modules/pako/lib/utils/strings.js"(exports, module) {
      "use strict";
      var STR_APPLY_UIA_OK = true;
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch (__) {
        STR_APPLY_UIA_OK = false;
      }
      var _utf8len = new Uint8Array(256);
      for (let q = 0; q < 256; q++) {
        _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
      }
      _utf8len[254] = _utf8len[254] = 1;
      module.exports.string2buf = (str) => {
        if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
          return new TextEncoder().encode(str);
        }
        let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
        for (m_pos = 0; m_pos < str_len; m_pos++) {
          c = str.charCodeAt(m_pos);
          if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 64512) === 56320) {
              c = 65536 + (c - 55296 << 10) + (c2 - 56320);
              m_pos++;
            }
          }
          buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
        }
        buf = new Uint8Array(buf_len);
        for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
          c = str.charCodeAt(m_pos);
          if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 64512) === 56320) {
              c = 65536 + (c - 55296 << 10) + (c2 - 56320);
              m_pos++;
            }
          }
          if (c < 128) {
            buf[i++] = c;
          } else if (c < 2048) {
            buf[i++] = 192 | c >>> 6;
            buf[i++] = 128 | c & 63;
          } else if (c < 65536) {
            buf[i++] = 224 | c >>> 12;
            buf[i++] = 128 | c >>> 6 & 63;
            buf[i++] = 128 | c & 63;
          } else {
            buf[i++] = 240 | c >>> 18;
            buf[i++] = 128 | c >>> 12 & 63;
            buf[i++] = 128 | c >>> 6 & 63;
            buf[i++] = 128 | c & 63;
          }
        }
        return buf;
      };
      var buf2binstring = (buf, len) => {
        if (len < 65534) {
          if (buf.subarray && STR_APPLY_UIA_OK) {
            return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
          }
        }
        let result = "";
        for (let i = 0; i < len; i++) {
          result += String.fromCharCode(buf[i]);
        }
        return result;
      };
      module.exports.buf2string = (buf, max) => {
        const len = max || buf.length;
        if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
          return new TextDecoder().decode(buf.subarray(0, max));
        }
        let i, out;
        const utf16buf = new Array(len * 2);
        for (out = 0, i = 0; i < len; ) {
          let c = buf[i++];
          if (c < 128) {
            utf16buf[out++] = c;
            continue;
          }
          let c_len = _utf8len[c];
          if (c_len > 4) {
            utf16buf[out++] = 65533;
            i += c_len - 1;
            continue;
          }
          c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
          while (c_len > 1 && i < len) {
            c = c << 6 | buf[i++] & 63;
            c_len--;
          }
          if (c_len > 1) {
            utf16buf[out++] = 65533;
            continue;
          }
          if (c < 65536) {
            utf16buf[out++] = c;
          } else {
            c -= 65536;
            utf16buf[out++] = 55296 | c >> 10 & 1023;
            utf16buf[out++] = 56320 | c & 1023;
          }
        }
        return buf2binstring(utf16buf, out);
      };
      module.exports.utf8border = (buf, max) => {
        max = max || buf.length;
        if (max > buf.length) {
          max = buf.length;
        }
        let pos = max - 1;
        while (pos >= 0 && (buf[pos] & 192) === 128) {
          pos--;
        }
        if (pos < 0) {
          return max;
        }
        if (pos === 0) {
          return max;
        }
        return pos + _utf8len[buf[pos]] > max ? pos : max;
      };
    }
  });

  // node_modules/pako/lib/zlib/zstream.js
  var require_zstream = __commonJS({
    "node_modules/pako/lib/zlib/zstream.js"(exports, module) {
      "use strict";
      function ZStream() {
        this.input = null;
        this.next_in = 0;
        this.avail_in = 0;
        this.total_in = 0;
        this.output = null;
        this.next_out = 0;
        this.avail_out = 0;
        this.total_out = 0;
        this.msg = "";
        this.state = null;
        this.data_type = 2;
        this.adler = 0;
      }
      module.exports = ZStream;
    }
  });

  // node_modules/pako/lib/deflate.js
  var require_deflate2 = __commonJS({
    "node_modules/pako/lib/deflate.js"(exports, module) {
      "use strict";
      var zlib_deflate = require_deflate();
      var utils = require_common();
      var strings = require_strings();
      var msg = require_messages();
      var ZStream = require_zstream();
      var toString = Object.prototype.toString;
      var {
        Z_NO_FLUSH,
        Z_SYNC_FLUSH,
        Z_FULL_FLUSH,
        Z_FINISH,
        Z_OK,
        Z_STREAM_END,
        Z_DEFAULT_COMPRESSION,
        Z_DEFAULT_STRATEGY,
        Z_DEFLATED
      } = require_constants();
      function Deflate(options) {
        this.options = utils.assign({
          level: Z_DEFAULT_COMPRESSION,
          method: Z_DEFLATED,
          chunkSize: 16384,
          windowBits: 15,
          memLevel: 8,
          strategy: Z_DEFAULT_STRATEGY
        }, options || {});
        let opt = this.options;
        if (opt.raw && opt.windowBits > 0) {
          opt.windowBits = -opt.windowBits;
        } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
          opt.windowBits += 16;
        }
        this.err = 0;
        this.msg = "";
        this.ended = false;
        this.chunks = [];
        this.strm = new ZStream();
        this.strm.avail_out = 0;
        let status = zlib_deflate.deflateInit2(
          this.strm,
          opt.level,
          opt.method,
          opt.windowBits,
          opt.memLevel,
          opt.strategy
        );
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        if (opt.header) {
          zlib_deflate.deflateSetHeader(this.strm, opt.header);
        }
        if (opt.dictionary) {
          let dict;
          if (typeof opt.dictionary === "string") {
            dict = strings.string2buf(opt.dictionary);
          } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
            dict = new Uint8Array(opt.dictionary);
          } else {
            dict = opt.dictionary;
          }
          status = zlib_deflate.deflateSetDictionary(this.strm, dict);
          if (status !== Z_OK) {
            throw new Error(msg[status]);
          }
          this._dict_set = true;
        }
      }
      Deflate.prototype.push = function(data, flush_mode) {
        const strm = this.strm;
        const chunkSize = this.options.chunkSize;
        let status, _flush_mode;
        if (this.ended) {
          return false;
        }
        if (flush_mode === ~~flush_mode)
          _flush_mode = flush_mode;
        else
          _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
        if (typeof data === "string") {
          strm.input = strings.string2buf(data);
        } else if (toString.call(data) === "[object ArrayBuffer]") {
          strm.input = new Uint8Array(data);
        } else {
          strm.input = data;
        }
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        for (; ; ) {
          if (strm.avail_out === 0) {
            strm.output = new Uint8Array(chunkSize);
            strm.next_out = 0;
            strm.avail_out = chunkSize;
          }
          if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
            this.onData(strm.output.subarray(0, strm.next_out));
            strm.avail_out = 0;
            continue;
          }
          status = zlib_deflate.deflate(strm, _flush_mode);
          if (status === Z_STREAM_END) {
            if (strm.next_out > 0) {
              this.onData(strm.output.subarray(0, strm.next_out));
            }
            status = zlib_deflate.deflateEnd(this.strm);
            this.onEnd(status);
            this.ended = true;
            return status === Z_OK;
          }
          if (strm.avail_out === 0) {
            this.onData(strm.output);
            continue;
          }
          if (_flush_mode > 0 && strm.next_out > 0) {
            this.onData(strm.output.subarray(0, strm.next_out));
            strm.avail_out = 0;
            continue;
          }
          if (strm.avail_in === 0)
            break;
        }
        return true;
      };
      Deflate.prototype.onData = function(chunk) {
        this.chunks.push(chunk);
      };
      Deflate.prototype.onEnd = function(status) {
        if (status === Z_OK) {
          this.result = utils.flattenChunks(this.chunks);
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg;
      };
      function deflate(input, options) {
        const deflator = new Deflate(options);
        deflator.push(input, true);
        if (deflator.err) {
          throw deflator.msg || msg[deflator.err];
        }
        return deflator.result;
      }
      function deflateRaw(input, options) {
        options = options || {};
        options.raw = true;
        return deflate(input, options);
      }
      function gzip(input, options) {
        options = options || {};
        options.gzip = true;
        return deflate(input, options);
      }
      module.exports.Deflate = Deflate;
      module.exports.deflate = deflate;
      module.exports.deflateRaw = deflateRaw;
      module.exports.gzip = gzip;
      module.exports.constants = require_constants();
    }
  });

  // node_modules/pako/lib/zlib/inffast.js
  var require_inffast = __commonJS({
    "node_modules/pako/lib/zlib/inffast.js"(exports, module) {
      "use strict";
      var BAD = 16209;
      var TYPE = 16191;
      module.exports = function inflate_fast(strm, start) {
        let _in;
        let last;
        let _out;
        let beg;
        let end;
        let dmax;
        let wsize;
        let whave;
        let wnext;
        let s_window;
        let hold;
        let bits;
        let lcode;
        let dcode;
        let lmask;
        let dmask;
        let here;
        let op;
        let len;
        let dist;
        let from;
        let from_source;
        let input, output;
        const state = strm.state;
        _in = strm.next_in;
        input = strm.input;
        last = _in + (strm.avail_in - 5);
        _out = strm.next_out;
        output = strm.output;
        beg = _out - (start - strm.avail_out);
        end = _out + (strm.avail_out - 257);
        dmax = state.dmax;
        wsize = state.wsize;
        whave = state.whave;
        wnext = state.wnext;
        s_window = state.window;
        hold = state.hold;
        bits = state.bits;
        lcode = state.lencode;
        dcode = state.distcode;
        lmask = (1 << state.lenbits) - 1;
        dmask = (1 << state.distbits) - 1;
        top:
          do {
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = lcode[hold & lmask];
            dolen:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op === 0) {
                  output[_out++] = here & 65535;
                } else if (op & 16) {
                  len = here & 65535;
                  op &= 15;
                  if (op) {
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                    len += hold & (1 << op) - 1;
                    hold >>>= op;
                    bits -= op;
                  }
                  if (bits < 15) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  here = dcode[hold & dmask];
                  dodist:
                    for (; ; ) {
                      op = here >>> 24;
                      hold >>>= op;
                      bits -= op;
                      op = here >>> 16 & 255;
                      if (op & 16) {
                        dist = here & 65535;
                        op &= 15;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                          if (bits < op) {
                            hold += input[_in++] << bits;
                            bits += 8;
                          }
                        }
                        dist += hold & (1 << op) - 1;
                        if (dist > dmax) {
                          strm.msg = "invalid distance too far back";
                          state.mode = BAD;
                          break top;
                        }
                        hold >>>= op;
                        bits -= op;
                        op = _out - beg;
                        if (dist > op) {
                          op = dist - op;
                          if (op > whave) {
                            if (state.sane) {
                              strm.msg = "invalid distance too far back";
                              state.mode = BAD;
                              break top;
                            }
                          }
                          from = 0;
                          from_source = s_window;
                          if (wnext === 0) {
                            from += wsize - op;
                            if (op < len) {
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          } else if (wnext < op) {
                            from += wsize + wnext - op;
                            op -= wnext;
                            if (op < len) {
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = 0;
                              if (wnext < len) {
                                op = wnext;
                                len -= op;
                                do {
                                  output[_out++] = s_window[from++];
                                } while (--op);
                                from = _out - dist;
                                from_source = output;
                              }
                            }
                          } else {
                            from += wnext - op;
                            if (op < len) {
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                          while (len > 2) {
                            output[_out++] = from_source[from++];
                            output[_out++] = from_source[from++];
                            output[_out++] = from_source[from++];
                            len -= 3;
                          }
                          if (len) {
                            output[_out++] = from_source[from++];
                            if (len > 1) {
                              output[_out++] = from_source[from++];
                            }
                          }
                        } else {
                          from = _out - dist;
                          do {
                            output[_out++] = output[from++];
                            output[_out++] = output[from++];
                            output[_out++] = output[from++];
                            len -= 3;
                          } while (len > 2);
                          if (len) {
                            output[_out++] = output[from++];
                            if (len > 1) {
                              output[_out++] = output[from++];
                            }
                          }
                        }
                      } else if ((op & 64) === 0) {
                        here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                        continue dodist;
                      } else {
                        strm.msg = "invalid distance code";
                        state.mode = BAD;
                        break top;
                      }
                      break;
                    }
                } else if ((op & 64) === 0) {
                  here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dolen;
                } else if (op & 32) {
                  state.mode = TYPE;
                  break top;
                } else {
                  strm.msg = "invalid literal/length code";
                  state.mode = BAD;
                  break top;
                }
                break;
              }
          } while (_in < last && _out < end);
        len = bits >> 3;
        _in -= len;
        bits -= len << 3;
        hold &= (1 << bits) - 1;
        strm.next_in = _in;
        strm.next_out = _out;
        strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
        strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
        state.hold = hold;
        state.bits = bits;
        return;
      };
    }
  });

  // node_modules/pako/lib/zlib/inftrees.js
  var require_inftrees = __commonJS({
    "node_modules/pako/lib/zlib/inftrees.js"(exports, module) {
      "use strict";
      var MAXBITS = 15;
      var ENOUGH_LENS = 852;
      var ENOUGH_DISTS = 592;
      var CODES = 0;
      var LENS = 1;
      var DISTS = 2;
      var lbase = new Uint16Array([
        /* Length codes 257..285 base */
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        13,
        15,
        17,
        19,
        23,
        27,
        31,
        35,
        43,
        51,
        59,
        67,
        83,
        99,
        115,
        131,
        163,
        195,
        227,
        258,
        0,
        0
      ]);
      var lext = new Uint8Array([
        /* Length codes 257..285 extra */
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        17,
        17,
        17,
        17,
        18,
        18,
        18,
        18,
        19,
        19,
        19,
        19,
        20,
        20,
        20,
        20,
        21,
        21,
        21,
        21,
        16,
        72,
        78
      ]);
      var dbase = new Uint16Array([
        /* Distance codes 0..29 base */
        1,
        2,
        3,
        4,
        5,
        7,
        9,
        13,
        17,
        25,
        33,
        49,
        65,
        97,
        129,
        193,
        257,
        385,
        513,
        769,
        1025,
        1537,
        2049,
        3073,
        4097,
        6145,
        8193,
        12289,
        16385,
        24577,
        0,
        0
      ]);
      var dext = new Uint8Array([
        /* Distance codes 0..29 extra */
        16,
        16,
        16,
        16,
        17,
        17,
        18,
        18,
        19,
        19,
        20,
        20,
        21,
        21,
        22,
        22,
        23,
        23,
        24,
        24,
        25,
        25,
        26,
        26,
        27,
        27,
        28,
        28,
        29,
        29,
        64,
        64
      ]);
      var inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
        const bits = opts.bits;
        let len = 0;
        let sym = 0;
        let min = 0, max = 0;
        let root = 0;
        let curr = 0;
        let drop = 0;
        let left = 0;
        let used = 0;
        let huff = 0;
        let incr;
        let fill;
        let low;
        let mask;
        let next;
        let base = null;
        let match;
        const count = new Uint16Array(MAXBITS + 1);
        const offs = new Uint16Array(MAXBITS + 1);
        let extra = null;
        let here_bits, here_op, here_val;
        for (len = 0; len <= MAXBITS; len++) {
          count[len] = 0;
        }
        for (sym = 0; sym < codes; sym++) {
          count[lens[lens_index + sym]]++;
        }
        root = bits;
        for (max = MAXBITS; max >= 1; max--) {
          if (count[max] !== 0) {
            break;
          }
        }
        if (root > max) {
          root = max;
        }
        if (max === 0) {
          table[table_index++] = 1 << 24 | 64 << 16 | 0;
          table[table_index++] = 1 << 24 | 64 << 16 | 0;
          opts.bits = 1;
          return 0;
        }
        for (min = 1; min < max; min++) {
          if (count[min] !== 0) {
            break;
          }
        }
        if (root < min) {
          root = min;
        }
        left = 1;
        for (len = 1; len <= MAXBITS; len++) {
          left <<= 1;
          left -= count[len];
          if (left < 0) {
            return -1;
          }
        }
        if (left > 0 && (type === CODES || max !== 1)) {
          return -1;
        }
        offs[1] = 0;
        for (len = 1; len < MAXBITS; len++) {
          offs[len + 1] = offs[len] + count[len];
        }
        for (sym = 0; sym < codes; sym++) {
          if (lens[lens_index + sym] !== 0) {
            work[offs[lens[lens_index + sym]]++] = sym;
          }
        }
        if (type === CODES) {
          base = extra = work;
          match = 20;
        } else if (type === LENS) {
          base = lbase;
          extra = lext;
          match = 257;
        } else {
          base = dbase;
          extra = dext;
          match = 0;
        }
        huff = 0;
        sym = 0;
        len = min;
        next = table_index;
        curr = root;
        drop = 0;
        low = -1;
        used = 1 << root;
        mask = used - 1;
        if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
          return 1;
        }
        for (; ; ) {
          here_bits = len - drop;
          if (work[sym] + 1 < match) {
            here_op = 0;
            here_val = work[sym];
          } else if (work[sym] >= match) {
            here_op = extra[work[sym] - match];
            here_val = base[work[sym] - match];
          } else {
            here_op = 32 + 64;
            here_val = 0;
          }
          incr = 1 << len - drop;
          fill = 1 << curr;
          min = fill;
          do {
            fill -= incr;
            table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
          } while (fill !== 0);
          incr = 1 << len - 1;
          while (huff & incr) {
            incr >>= 1;
          }
          if (incr !== 0) {
            huff &= incr - 1;
            huff += incr;
          } else {
            huff = 0;
          }
          sym++;
          if (--count[len] === 0) {
            if (len === max) {
              break;
            }
            len = lens[lens_index + work[sym]];
          }
          if (len > root && (huff & mask) !== low) {
            if (drop === 0) {
              drop = root;
            }
            next += min;
            curr = len - drop;
            left = 1 << curr;
            while (curr + drop < max) {
              left -= count[curr + drop];
              if (left <= 0) {
                break;
              }
              curr++;
              left <<= 1;
            }
            used += 1 << curr;
            if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
              return 1;
            }
            low = huff & mask;
            table[low] = root << 24 | curr << 16 | next - table_index | 0;
          }
        }
        if (huff !== 0) {
          table[next + huff] = len - drop << 24 | 64 << 16 | 0;
        }
        opts.bits = root;
        return 0;
      };
      module.exports = inflate_table;
    }
  });

  // node_modules/pako/lib/zlib/inflate.js
  var require_inflate = __commonJS({
    "node_modules/pako/lib/zlib/inflate.js"(exports, module) {
      "use strict";
      var adler32 = require_adler32();
      var crc32 = require_crc32();
      var inflate_fast = require_inffast();
      var inflate_table = require_inftrees();
      var CODES = 0;
      var LENS = 1;
      var DISTS = 2;
      var {
        Z_FINISH,
        Z_BLOCK,
        Z_TREES,
        Z_OK,
        Z_STREAM_END,
        Z_NEED_DICT,
        Z_STREAM_ERROR,
        Z_DATA_ERROR,
        Z_MEM_ERROR,
        Z_BUF_ERROR,
        Z_DEFLATED
      } = require_constants();
      var HEAD = 16180;
      var FLAGS = 16181;
      var TIME = 16182;
      var OS = 16183;
      var EXLEN = 16184;
      var EXTRA = 16185;
      var NAME = 16186;
      var COMMENT = 16187;
      var HCRC = 16188;
      var DICTID = 16189;
      var DICT = 16190;
      var TYPE = 16191;
      var TYPEDO = 16192;
      var STORED = 16193;
      var COPY_ = 16194;
      var COPY = 16195;
      var TABLE = 16196;
      var LENLENS = 16197;
      var CODELENS = 16198;
      var LEN_ = 16199;
      var LEN = 16200;
      var LENEXT = 16201;
      var DIST = 16202;
      var DISTEXT = 16203;
      var MATCH = 16204;
      var LIT = 16205;
      var CHECK = 16206;
      var LENGTH = 16207;
      var DONE = 16208;
      var BAD = 16209;
      var MEM = 16210;
      var SYNC = 16211;
      var ENOUGH_LENS = 852;
      var ENOUGH_DISTS = 592;
      var MAX_WBITS = 15;
      var DEF_WBITS = MAX_WBITS;
      var zswap32 = (q) => {
        return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
      };
      function InflateState() {
        this.strm = null;
        this.mode = 0;
        this.last = false;
        this.wrap = 0;
        this.havedict = false;
        this.flags = 0;
        this.dmax = 0;
        this.check = 0;
        this.total = 0;
        this.head = null;
        this.wbits = 0;
        this.wsize = 0;
        this.whave = 0;
        this.wnext = 0;
        this.window = null;
        this.hold = 0;
        this.bits = 0;
        this.length = 0;
        this.offset = 0;
        this.extra = 0;
        this.lencode = null;
        this.distcode = null;
        this.lenbits = 0;
        this.distbits = 0;
        this.ncode = 0;
        this.nlen = 0;
        this.ndist = 0;
        this.have = 0;
        this.next = null;
        this.lens = new Uint16Array(320);
        this.work = new Uint16Array(288);
        this.lendyn = null;
        this.distdyn = null;
        this.sane = 0;
        this.back = 0;
        this.was = 0;
      }
      var inflateStateCheck = (strm) => {
        if (!strm) {
          return 1;
        }
        const state = strm.state;
        if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
          return 1;
        }
        return 0;
      };
      var inflateResetKeep = (strm) => {
        if (inflateStateCheck(strm)) {
          return Z_STREAM_ERROR;
        }
        const state = strm.state;
        strm.total_in = strm.total_out = state.total = 0;
        strm.msg = "";
        if (state.wrap) {
          strm.adler = state.wrap & 1;
        }
        state.mode = HEAD;
        state.last = 0;
        state.havedict = 0;
        state.flags = -1;
        state.dmax = 32768;
        state.head = null;
        state.hold = 0;
        state.bits = 0;
        state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
        state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
        state.sane = 1;
        state.back = -1;
        return Z_OK;
      };
      var inflateReset = (strm) => {
        if (inflateStateCheck(strm)) {
          return Z_STREAM_ERROR;
        }
        const state = strm.state;
        state.wsize = 0;
        state.whave = 0;
        state.wnext = 0;
        return inflateResetKeep(strm);
      };
      var inflateReset2 = (strm, windowBits) => {
        let wrap;
        if (inflateStateCheck(strm)) {
          return Z_STREAM_ERROR;
        }
        const state = strm.state;
        if (windowBits < 0) {
          wrap = 0;
          windowBits = -windowBits;
        } else {
          wrap = (windowBits >> 4) + 5;
          if (windowBits < 48) {
            windowBits &= 15;
          }
        }
        if (windowBits && (windowBits < 8 || windowBits > 15)) {
          return Z_STREAM_ERROR;
        }
        if (state.window !== null && state.wbits !== windowBits) {
          state.window = null;
        }
        state.wrap = wrap;
        state.wbits = windowBits;
        return inflateReset(strm);
      };
      var inflateInit2 = (strm, windowBits) => {
        if (!strm) {
          return Z_STREAM_ERROR;
        }
        const state = new InflateState();
        strm.state = state;
        state.strm = strm;
        state.window = null;
        state.mode = HEAD;
        const ret = inflateReset2(strm, windowBits);
        if (ret !== Z_OK) {
          strm.state = null;
        }
        return ret;
      };
      var inflateInit = (strm) => {
        return inflateInit2(strm, DEF_WBITS);
      };
      var virgin = true;
      var lenfix;
      var distfix;
      var fixedtables = (state) => {
        if (virgin) {
          lenfix = new Int32Array(512);
          distfix = new Int32Array(32);
          let sym = 0;
          while (sym < 144) {
            state.lens[sym++] = 8;
          }
          while (sym < 256) {
            state.lens[sym++] = 9;
          }
          while (sym < 280) {
            state.lens[sym++] = 7;
          }
          while (sym < 288) {
            state.lens[sym++] = 8;
          }
          inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
          sym = 0;
          while (sym < 32) {
            state.lens[sym++] = 5;
          }
          inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
          virgin = false;
        }
        state.lencode = lenfix;
        state.lenbits = 9;
        state.distcode = distfix;
        state.distbits = 5;
      };
      var updatewindow = (strm, src, end, copy) => {
        let dist;
        const state = strm.state;
        if (state.window === null) {
          state.wsize = 1 << state.wbits;
          state.wnext = 0;
          state.whave = 0;
          state.window = new Uint8Array(state.wsize);
        }
        if (copy >= state.wsize) {
          state.window.set(src.subarray(end - state.wsize, end), 0);
          state.wnext = 0;
          state.whave = state.wsize;
        } else {
          dist = state.wsize - state.wnext;
          if (dist > copy) {
            dist = copy;
          }
          state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
          copy -= dist;
          if (copy) {
            state.window.set(src.subarray(end - copy, end), 0);
            state.wnext = copy;
            state.whave = state.wsize;
          } else {
            state.wnext += dist;
            if (state.wnext === state.wsize) {
              state.wnext = 0;
            }
            if (state.whave < state.wsize) {
              state.whave += dist;
            }
          }
        }
        return 0;
      };
      var inflate = (strm, flush) => {
        let state;
        let input, output;
        let next;
        let put;
        let have, left;
        let hold;
        let bits;
        let _in, _out;
        let copy;
        let from;
        let from_source;
        let here = 0;
        let here_bits, here_op, here_val;
        let last_bits, last_op, last_val;
        let len;
        let ret;
        const hbuf = new Uint8Array(4);
        let opts;
        let n;
        const order = (
          /* permutation of code lengths */
          new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
        );
        if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        if (state.mode === TYPE) {
          state.mode = TYPEDO;
        }
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        _in = have;
        _out = left;
        ret = Z_OK;
        inf_leave:
          for (; ; ) {
            switch (state.mode) {
              case HEAD:
                if (state.wrap === 0) {
                  state.mode = TYPEDO;
                  break;
                }
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.wrap & 2 && hold === 35615) {
                  if (state.wbits === 0) {
                    state.wbits = 15;
                  }
                  state.check = 0;
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                  hold = 0;
                  bits = 0;
                  state.mode = FLAGS;
                  break;
                }
                if (state.head) {
                  state.head.done = false;
                }
                if (!(state.wrap & 1) || /* check if zlib header allowed */
                (((hold & 255) << 8) + (hold >> 8)) % 31) {
                  strm.msg = "incorrect header check";
                  state.mode = BAD;
                  break;
                }
                if ((hold & 15) !== Z_DEFLATED) {
                  strm.msg = "unknown compression method";
                  state.mode = BAD;
                  break;
                }
                hold >>>= 4;
                bits -= 4;
                len = (hold & 15) + 8;
                if (state.wbits === 0) {
                  state.wbits = len;
                }
                if (len > 15 || len > state.wbits) {
                  strm.msg = "invalid window size";
                  state.mode = BAD;
                  break;
                }
                state.dmax = 1 << state.wbits;
                state.flags = 0;
                strm.adler = state.check = 1;
                state.mode = hold & 512 ? DICTID : TYPE;
                hold = 0;
                bits = 0;
                break;
              case FLAGS:
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.flags = hold;
                if ((state.flags & 255) !== Z_DEFLATED) {
                  strm.msg = "unknown compression method";
                  state.mode = BAD;
                  break;
                }
                if (state.flags & 57344) {
                  strm.msg = "unknown header flags set";
                  state.mode = BAD;
                  break;
                }
                if (state.head) {
                  state.head.text = hold >> 8 & 1;
                }
                if (state.flags & 512 && state.wrap & 4) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = TIME;
              case TIME:
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.head) {
                  state.head.time = hold;
                }
                if (state.flags & 512 && state.wrap & 4) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  hbuf[2] = hold >>> 16 & 255;
                  hbuf[3] = hold >>> 24 & 255;
                  state.check = crc32(state.check, hbuf, 4, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = OS;
              case OS:
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.head) {
                  state.head.xflags = hold & 255;
                  state.head.os = hold >> 8;
                }
                if (state.flags & 512 && state.wrap & 4) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = EXLEN;
              case EXLEN:
                if (state.flags & 1024) {
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.length = hold;
                  if (state.head) {
                    state.head.extra_len = hold;
                  }
                  if (state.flags & 512 && state.wrap & 4) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32(state.check, hbuf, 2, 0);
                  }
                  hold = 0;
                  bits = 0;
                } else if (state.head) {
                  state.head.extra = null;
                }
                state.mode = EXTRA;
              case EXTRA:
                if (state.flags & 1024) {
                  copy = state.length;
                  if (copy > have) {
                    copy = have;
                  }
                  if (copy) {
                    if (state.head) {
                      len = state.head.extra_len - state.length;
                      if (!state.head.extra) {
                        state.head.extra = new Uint8Array(state.head.extra_len);
                      }
                      state.head.extra.set(
                        input.subarray(
                          next,
                          // extra field is limited to 65536 bytes
                          // - no need for additional size check
                          next + copy
                        ),
                        /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                        len
                      );
                    }
                    if (state.flags & 512 && state.wrap & 4) {
                      state.check = crc32(state.check, input, copy, next);
                    }
                    have -= copy;
                    next += copy;
                    state.length -= copy;
                  }
                  if (state.length) {
                    break inf_leave;
                  }
                }
                state.length = 0;
                state.mode = NAME;
              case NAME:
                if (state.flags & 2048) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  copy = 0;
                  do {
                    len = input[next + copy++];
                    if (state.head && len && state.length < 65536) {
                      state.head.name += String.fromCharCode(len);
                    }
                  } while (len && copy < have);
                  if (state.flags & 512 && state.wrap & 4) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  if (len) {
                    break inf_leave;
                  }
                } else if (state.head) {
                  state.head.name = null;
                }
                state.length = 0;
                state.mode = COMMENT;
              case COMMENT:
                if (state.flags & 4096) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  copy = 0;
                  do {
                    len = input[next + copy++];
                    if (state.head && len && state.length < 65536) {
                      state.head.comment += String.fromCharCode(len);
                    }
                  } while (len && copy < have);
                  if (state.flags & 512 && state.wrap & 4) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  if (len) {
                    break inf_leave;
                  }
                } else if (state.head) {
                  state.head.comment = null;
                }
                state.mode = HCRC;
              case HCRC:
                if (state.flags & 512) {
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (state.wrap & 4 && hold !== (state.check & 65535)) {
                    strm.msg = "header crc mismatch";
                    state.mode = BAD;
                    break;
                  }
                  hold = 0;
                  bits = 0;
                }
                if (state.head) {
                  state.head.hcrc = state.flags >> 9 & 1;
                  state.head.done = true;
                }
                strm.adler = state.check = 0;
                state.mode = TYPE;
                break;
              case DICTID:
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                strm.adler = state.check = zswap32(hold);
                hold = 0;
                bits = 0;
                state.mode = DICT;
              case DICT:
                if (state.havedict === 0) {
                  strm.next_out = put;
                  strm.avail_out = left;
                  strm.next_in = next;
                  strm.avail_in = have;
                  state.hold = hold;
                  state.bits = bits;
                  return Z_NEED_DICT;
                }
                strm.adler = state.check = 1;
                state.mode = TYPE;
              case TYPE:
                if (flush === Z_BLOCK || flush === Z_TREES) {
                  break inf_leave;
                }
              case TYPEDO:
                if (state.last) {
                  hold >>>= bits & 7;
                  bits -= bits & 7;
                  state.mode = CHECK;
                  break;
                }
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.last = hold & 1;
                hold >>>= 1;
                bits -= 1;
                switch (hold & 3) {
                  case 0:
                    state.mode = STORED;
                    break;
                  case 1:
                    fixedtables(state);
                    state.mode = LEN_;
                    if (flush === Z_TREES) {
                      hold >>>= 2;
                      bits -= 2;
                      break inf_leave;
                    }
                    break;
                  case 2:
                    state.mode = TABLE;
                    break;
                  case 3:
                    strm.msg = "invalid block type";
                    state.mode = BAD;
                }
                hold >>>= 2;
                bits -= 2;
                break;
              case STORED:
                hold >>>= bits & 7;
                bits -= bits & 7;
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                  strm.msg = "invalid stored block lengths";
                  state.mode = BAD;
                  break;
                }
                state.length = hold & 65535;
                hold = 0;
                bits = 0;
                state.mode = COPY_;
                if (flush === Z_TREES) {
                  break inf_leave;
                }
              case COPY_:
                state.mode = COPY;
              case COPY:
                copy = state.length;
                if (copy) {
                  if (copy > have) {
                    copy = have;
                  }
                  if (copy > left) {
                    copy = left;
                  }
                  if (copy === 0) {
                    break inf_leave;
                  }
                  output.set(input.subarray(next, next + copy), put);
                  have -= copy;
                  next += copy;
                  left -= copy;
                  put += copy;
                  state.length -= copy;
                  break;
                }
                state.mode = TYPE;
                break;
              case TABLE:
                while (bits < 14) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.nlen = (hold & 31) + 257;
                hold >>>= 5;
                bits -= 5;
                state.ndist = (hold & 31) + 1;
                hold >>>= 5;
                bits -= 5;
                state.ncode = (hold & 15) + 4;
                hold >>>= 4;
                bits -= 4;
                if (state.nlen > 286 || state.ndist > 30) {
                  strm.msg = "too many length or distance symbols";
                  state.mode = BAD;
                  break;
                }
                state.have = 0;
                state.mode = LENLENS;
              case LENLENS:
                while (state.have < state.ncode) {
                  while (bits < 3) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.lens[order[state.have++]] = hold & 7;
                  hold >>>= 3;
                  bits -= 3;
                }
                while (state.have < 19) {
                  state.lens[order[state.have++]] = 0;
                }
                state.lencode = state.lendyn;
                state.lenbits = 7;
                opts = { bits: state.lenbits };
                ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                state.lenbits = opts.bits;
                if (ret) {
                  strm.msg = "invalid code lengths set";
                  state.mode = BAD;
                  break;
                }
                state.have = 0;
                state.mode = CODELENS;
              case CODELENS:
                while (state.have < state.nlen + state.ndist) {
                  for (; ; ) {
                    here = state.lencode[hold & (1 << state.lenbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (here_val < 16) {
                    hold >>>= here_bits;
                    bits -= here_bits;
                    state.lens[state.have++] = here_val;
                  } else {
                    if (here_val === 16) {
                      n = here_bits + 2;
                      while (bits < n) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      hold >>>= here_bits;
                      bits -= here_bits;
                      if (state.have === 0) {
                        strm.msg = "invalid bit length repeat";
                        state.mode = BAD;
                        break;
                      }
                      len = state.lens[state.have - 1];
                      copy = 3 + (hold & 3);
                      hold >>>= 2;
                      bits -= 2;
                    } else if (here_val === 17) {
                      n = here_bits + 3;
                      while (bits < n) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      hold >>>= here_bits;
                      bits -= here_bits;
                      len = 0;
                      copy = 3 + (hold & 7);
                      hold >>>= 3;
                      bits -= 3;
                    } else {
                      n = here_bits + 7;
                      while (bits < n) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      hold >>>= here_bits;
                      bits -= here_bits;
                      len = 0;
                      copy = 11 + (hold & 127);
                      hold >>>= 7;
                      bits -= 7;
                    }
                    if (state.have + copy > state.nlen + state.ndist) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    while (copy--) {
                      state.lens[state.have++] = len;
                    }
                  }
                }
                if (state.mode === BAD) {
                  break;
                }
                if (state.lens[256] === 0) {
                  strm.msg = "invalid code -- missing end-of-block";
                  state.mode = BAD;
                  break;
                }
                state.lenbits = 9;
                opts = { bits: state.lenbits };
                ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                state.lenbits = opts.bits;
                if (ret) {
                  strm.msg = "invalid literal/lengths set";
                  state.mode = BAD;
                  break;
                }
                state.distbits = 6;
                state.distcode = state.distdyn;
                opts = { bits: state.distbits };
                ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                state.distbits = opts.bits;
                if (ret) {
                  strm.msg = "invalid distances set";
                  state.mode = BAD;
                  break;
                }
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  break inf_leave;
                }
              case LEN_:
                state.mode = LEN;
              case LEN:
                if (have >= 6 && left >= 258) {
                  strm.next_out = put;
                  strm.avail_out = left;
                  strm.next_in = next;
                  strm.avail_in = have;
                  state.hold = hold;
                  state.bits = bits;
                  inflate_fast(strm, _out);
                  put = strm.next_out;
                  output = strm.output;
                  left = strm.avail_out;
                  next = strm.next_in;
                  input = strm.input;
                  have = strm.avail_in;
                  hold = state.hold;
                  bits = state.bits;
                  if (state.mode === TYPE) {
                    state.back = -1;
                  }
                  break;
                }
                state.back = 0;
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_op && (here_op & 240) === 0) {
                  last_bits = here_bits;
                  last_op = here_op;
                  last_val = here_val;
                  for (; ; ) {
                    here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (last_bits + here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= last_bits;
                  bits -= last_bits;
                  state.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state.back += here_bits;
                state.length = here_val;
                if (here_op === 0) {
                  state.mode = LIT;
                  break;
                }
                if (here_op & 32) {
                  state.back = -1;
                  state.mode = TYPE;
                  break;
                }
                if (here_op & 64) {
                  strm.msg = "invalid literal/length code";
                  state.mode = BAD;
                  break;
                }
                state.extra = here_op & 15;
                state.mode = LENEXT;
              case LENEXT:
                if (state.extra) {
                  n = state.extra;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.length += hold & (1 << state.extra) - 1;
                  hold >>>= state.extra;
                  bits -= state.extra;
                  state.back += state.extra;
                }
                state.was = state.length;
                state.mode = DIST;
              case DIST:
                for (; ; ) {
                  here = state.distcode[hold & (1 << state.distbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if ((here_op & 240) === 0) {
                  last_bits = here_bits;
                  last_op = here_op;
                  last_val = here_val;
                  for (; ; ) {
                    here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (last_bits + here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= last_bits;
                  bits -= last_bits;
                  state.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state.back += here_bits;
                if (here_op & 64) {
                  strm.msg = "invalid distance code";
                  state.mode = BAD;
                  break;
                }
                state.offset = here_val;
                state.extra = here_op & 15;
                state.mode = DISTEXT;
              case DISTEXT:
                if (state.extra) {
                  n = state.extra;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.offset += hold & (1 << state.extra) - 1;
                  hold >>>= state.extra;
                  bits -= state.extra;
                  state.back += state.extra;
                }
                if (state.offset > state.dmax) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break;
                }
                state.mode = MATCH;
              case MATCH:
                if (left === 0) {
                  break inf_leave;
                }
                copy = _out - left;
                if (state.offset > copy) {
                  copy = state.offset - copy;
                  if (copy > state.whave) {
                    if (state.sane) {
                      strm.msg = "invalid distance too far back";
                      state.mode = BAD;
                      break;
                    }
                  }
                  if (copy > state.wnext) {
                    copy -= state.wnext;
                    from = state.wsize - copy;
                  } else {
                    from = state.wnext - copy;
                  }
                  if (copy > state.length) {
                    copy = state.length;
                  }
                  from_source = state.window;
                } else {
                  from_source = output;
                  from = put - state.offset;
                  copy = state.length;
                }
                if (copy > left) {
                  copy = left;
                }
                left -= copy;
                state.length -= copy;
                do {
                  output[put++] = from_source[from++];
                } while (--copy);
                if (state.length === 0) {
                  state.mode = LEN;
                }
                break;
              case LIT:
                if (left === 0) {
                  break inf_leave;
                }
                output[put++] = state.length;
                left--;
                state.mode = LEN;
                break;
              case CHECK:
                if (state.wrap) {
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold |= input[next++] << bits;
                    bits += 8;
                  }
                  _out -= left;
                  strm.total_out += _out;
                  state.total += _out;
                  if (state.wrap & 4 && _out) {
                    strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
                    state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                  }
                  _out = left;
                  if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
                    strm.msg = "incorrect data check";
                    state.mode = BAD;
                    break;
                  }
                  hold = 0;
                  bits = 0;
                }
                state.mode = LENGTH;
              case LENGTH:
                if (state.wrap && state.flags) {
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
                    strm.msg = "incorrect length check";
                    state.mode = BAD;
                    break;
                  }
                  hold = 0;
                  bits = 0;
                }
                state.mode = DONE;
              case DONE:
                ret = Z_STREAM_END;
                break inf_leave;
              case BAD:
                ret = Z_DATA_ERROR;
                break inf_leave;
              case MEM:
                return Z_MEM_ERROR;
              case SYNC:
              default:
                return Z_STREAM_ERROR;
            }
          }
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
          if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
            state.mode = MEM;
            return Z_MEM_ERROR;
          }
        }
        _in -= strm.avail_in;
        _out -= strm.avail_out;
        strm.total_in += _in;
        strm.total_out += _out;
        state.total += _out;
        if (state.wrap & 4 && _out) {
          strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
          state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
        }
        strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
        if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
          ret = Z_BUF_ERROR;
        }
        return ret;
      };
      var inflateEnd = (strm) => {
        if (inflateStateCheck(strm)) {
          return Z_STREAM_ERROR;
        }
        let state = strm.state;
        if (state.window) {
          state.window = null;
        }
        strm.state = null;
        return Z_OK;
      };
      var inflateGetHeader = (strm, head) => {
        if (inflateStateCheck(strm)) {
          return Z_STREAM_ERROR;
        }
        const state = strm.state;
        if ((state.wrap & 2) === 0) {
          return Z_STREAM_ERROR;
        }
        state.head = head;
        head.done = false;
        return Z_OK;
      };
      var inflateSetDictionary = (strm, dictionary) => {
        const dictLength = dictionary.length;
        let state;
        let dictid;
        let ret;
        if (inflateStateCheck(strm)) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        if (state.wrap !== 0 && state.mode !== DICT) {
          return Z_STREAM_ERROR;
        }
        if (state.mode === DICT) {
          dictid = 1;
          dictid = adler32(dictid, dictionary, dictLength, 0);
          if (dictid !== state.check) {
            return Z_DATA_ERROR;
          }
        }
        ret = updatewindow(strm, dictionary, dictLength, dictLength);
        if (ret) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
        state.havedict = 1;
        return Z_OK;
      };
      module.exports.inflateReset = inflateReset;
      module.exports.inflateReset2 = inflateReset2;
      module.exports.inflateResetKeep = inflateResetKeep;
      module.exports.inflateInit = inflateInit;
      module.exports.inflateInit2 = inflateInit2;
      module.exports.inflate = inflate;
      module.exports.inflateEnd = inflateEnd;
      module.exports.inflateGetHeader = inflateGetHeader;
      module.exports.inflateSetDictionary = inflateSetDictionary;
      module.exports.inflateInfo = "pako inflate (from Nodeca project)";
    }
  });

  // node_modules/pako/lib/zlib/gzheader.js
  var require_gzheader = __commonJS({
    "node_modules/pako/lib/zlib/gzheader.js"(exports, module) {
      "use strict";
      function GZheader() {
        this.text = 0;
        this.time = 0;
        this.xflags = 0;
        this.os = 0;
        this.extra = null;
        this.extra_len = 0;
        this.name = "";
        this.comment = "";
        this.hcrc = 0;
        this.done = false;
      }
      module.exports = GZheader;
    }
  });

  // node_modules/pako/lib/inflate.js
  var require_inflate2 = __commonJS({
    "node_modules/pako/lib/inflate.js"(exports, module) {
      "use strict";
      var zlib_inflate = require_inflate();
      var utils = require_common();
      var strings = require_strings();
      var msg = require_messages();
      var ZStream = require_zstream();
      var GZheader = require_gzheader();
      var toString = Object.prototype.toString;
      var {
        Z_NO_FLUSH,
        Z_FINISH,
        Z_OK,
        Z_STREAM_END,
        Z_NEED_DICT,
        Z_STREAM_ERROR,
        Z_DATA_ERROR,
        Z_MEM_ERROR
      } = require_constants();
      function Inflate(options) {
        this.options = utils.assign({
          chunkSize: 1024 * 64,
          windowBits: 15,
          to: ""
        }, options || {});
        const opt = this.options;
        if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
          opt.windowBits = -opt.windowBits;
          if (opt.windowBits === 0) {
            opt.windowBits = -15;
          }
        }
        if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
          opt.windowBits += 32;
        }
        if (opt.windowBits > 15 && opt.windowBits < 48) {
          if ((opt.windowBits & 15) === 0) {
            opt.windowBits |= 15;
          }
        }
        this.err = 0;
        this.msg = "";
        this.ended = false;
        this.chunks = [];
        this.strm = new ZStream();
        this.strm.avail_out = 0;
        let status = zlib_inflate.inflateInit2(
          this.strm,
          opt.windowBits
        );
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this.header = new GZheader();
        zlib_inflate.inflateGetHeader(this.strm, this.header);
        if (opt.dictionary) {
          if (typeof opt.dictionary === "string") {
            opt.dictionary = strings.string2buf(opt.dictionary);
          } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
            opt.dictionary = new Uint8Array(opt.dictionary);
          }
          if (opt.raw) {
            status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
            if (status !== Z_OK) {
              throw new Error(msg[status]);
            }
          }
        }
      }
      Inflate.prototype.push = function(data, flush_mode) {
        const strm = this.strm;
        const chunkSize = this.options.chunkSize;
        const dictionary = this.options.dictionary;
        let status, _flush_mode, last_avail_out;
        if (this.ended)
          return false;
        if (flush_mode === ~~flush_mode)
          _flush_mode = flush_mode;
        else
          _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
        if (toString.call(data) === "[object ArrayBuffer]") {
          strm.input = new Uint8Array(data);
        } else {
          strm.input = data;
        }
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        for (; ; ) {
          if (strm.avail_out === 0) {
            strm.output = new Uint8Array(chunkSize);
            strm.next_out = 0;
            strm.avail_out = chunkSize;
          }
          status = zlib_inflate.inflate(strm, _flush_mode);
          if (status === Z_NEED_DICT && dictionary) {
            status = zlib_inflate.inflateSetDictionary(strm, dictionary);
            if (status === Z_OK) {
              status = zlib_inflate.inflate(strm, _flush_mode);
            } else if (status === Z_DATA_ERROR) {
              status = Z_NEED_DICT;
            }
          }
          while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
            zlib_inflate.inflateReset(strm);
            status = zlib_inflate.inflate(strm, _flush_mode);
          }
          switch (status) {
            case Z_STREAM_ERROR:
            case Z_DATA_ERROR:
            case Z_NEED_DICT:
            case Z_MEM_ERROR:
              this.onEnd(status);
              this.ended = true;
              return false;
          }
          last_avail_out = strm.avail_out;
          if (strm.next_out) {
            if (strm.avail_out === 0 || status === Z_STREAM_END) {
              if (this.options.to === "string") {
                let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
                let tail = strm.next_out - next_out_utf8;
                let utf8str = strings.buf2string(strm.output, next_out_utf8);
                strm.next_out = tail;
                strm.avail_out = chunkSize - tail;
                if (tail)
                  strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
                this.onData(utf8str);
              } else {
                this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
              }
            }
          }
          if (status === Z_OK && last_avail_out === 0)
            continue;
          if (status === Z_STREAM_END) {
            status = zlib_inflate.inflateEnd(this.strm);
            this.onEnd(status);
            this.ended = true;
            return true;
          }
          if (strm.avail_in === 0)
            break;
        }
        return true;
      };
      Inflate.prototype.onData = function(chunk) {
        this.chunks.push(chunk);
      };
      Inflate.prototype.onEnd = function(status) {
        if (status === Z_OK) {
          if (this.options.to === "string") {
            this.result = this.chunks.join("");
          } else {
            this.result = utils.flattenChunks(this.chunks);
          }
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg;
      };
      function inflate(input, options) {
        const inflator = new Inflate(options);
        inflator.push(input);
        if (inflator.err)
          throw inflator.msg || msg[inflator.err];
        return inflator.result;
      }
      function inflateRaw(input, options) {
        options = options || {};
        options.raw = true;
        return inflate(input, options);
      }
      module.exports.Inflate = Inflate;
      module.exports.inflate = inflate;
      module.exports.inflateRaw = inflateRaw;
      module.exports.ungzip = inflate;
      module.exports.constants = require_constants();
    }
  });

  // node_modules/pako/index.js
  var require_pako = __commonJS({
    "node_modules/pako/index.js"(exports, module) {
      "use strict";
      var { Deflate, deflate, deflateRaw, gzip } = require_deflate2();
      var { Inflate, inflate, inflateRaw, ungzip } = require_inflate2();
      var constants = require_constants();
      module.exports.Deflate = Deflate;
      module.exports.deflate = deflate;
      module.exports.deflateRaw = deflateRaw;
      module.exports.gzip = gzip;
      module.exports.Inflate = Inflate;
      module.exports.inflate = inflate;
      module.exports.inflateRaw = inflateRaw;
      module.exports.ungzip = ungzip;
      module.exports.constants = constants;
    }
  });

  // src/modules/d3.js
  var require_d3 = __commonJS({
    "src/modules/d3.js"(exports, module) {
      "use strict";
      !function(t, n) {
        "object" == typeof exports && "undefined" != typeof module ? n(exports) : "function" == typeof define && define.amd ? define(["exports"], n) : n(t.d3 = t.d3 || {});
      }(exports, function(t) {
        "use strict";
        function n(t2, n2) {
          return t2 < n2 ? -1 : t2 > n2 ? 1 : t2 >= n2 ? 0 : NaN;
        }
        function e(t2) {
          var e2;
          return 1 === t2.length && (e2 = t2, t2 = function(t3, r2) {
            return n(e2(t3), r2);
          }), { left: function(n2, e3, r2, i2) {
            for (null == r2 && (r2 = 0), null == i2 && (i2 = n2.length); r2 < i2; ) {
              var o2 = r2 + i2 >>> 1;
              t2(n2[o2], e3) < 0 ? r2 = o2 + 1 : i2 = o2;
            }
            return r2;
          }, right: function(n2, e3, r2, i2) {
            for (null == r2 && (r2 = 0), null == i2 && (i2 = n2.length); r2 < i2; ) {
              var o2 = r2 + i2 >>> 1;
              t2(n2[o2], e3) > 0 ? i2 = o2 : r2 = o2 + 1;
            }
            return r2;
          } };
        }
        var r = e(n), i = r.right, o = r.left;
        function a(t2, n2) {
          return [t2, n2];
        }
        function u(t2) {
          return null === t2 ? NaN : +t2;
        }
        function c(t2, n2) {
          var e2, r2, i2 = t2.length, o2 = 0, a2 = -1, c2 = 0, f2 = 0;
          if (null == n2)
            for (; ++a2 < i2; )
              isNaN(e2 = u(t2[a2])) || (f2 += (r2 = e2 - c2) * (e2 - (c2 += r2 / ++o2)));
          else
            for (; ++a2 < i2; )
              isNaN(e2 = u(n2(t2[a2], a2, t2))) || (f2 += (r2 = e2 - c2) * (e2 - (c2 += r2 / ++o2)));
          if (o2 > 1)
            return f2 / (o2 - 1);
        }
        function f(t2, n2) {
          var e2 = c(t2, n2);
          return e2 ? Math.sqrt(e2) : e2;
        }
        function s(t2, n2) {
          var e2, r2, i2, o2 = t2.length, a2 = -1;
          if (null == n2) {
            for (; ++a2 < o2; )
              if (null != (e2 = t2[a2]) && e2 >= e2)
                for (r2 = i2 = e2; ++a2 < o2; )
                  null != (e2 = t2[a2]) && (r2 > e2 && (r2 = e2), i2 < e2 && (i2 = e2));
          } else
            for (; ++a2 < o2; )
              if (null != (e2 = n2(t2[a2], a2, t2)) && e2 >= e2)
                for (r2 = i2 = e2; ++a2 < o2; )
                  null != (e2 = n2(t2[a2], a2, t2)) && (r2 > e2 && (r2 = e2), i2 < e2 && (i2 = e2));
          return [r2, i2];
        }
        var l = Array.prototype, h = l.slice, d = l.map;
        function p(t2) {
          return function() {
            return t2;
          };
        }
        function v(t2) {
          return t2;
        }
        function g(t2, n2, e2) {
          t2 = +t2, n2 = +n2, e2 = (i2 = arguments.length) < 2 ? (n2 = t2, t2 = 0, 1) : i2 < 3 ? 1 : +e2;
          for (var r2 = -1, i2 = 0 | Math.max(0, Math.ceil((n2 - t2) / e2)), o2 = new Array(i2); ++r2 < i2; )
            o2[r2] = t2 + r2 * e2;
          return o2;
        }
        var y = Math.sqrt(50), _ = Math.sqrt(10), b = Math.sqrt(2);
        function m(t2, n2, e2) {
          var r2, i2, o2, a2, u2 = -1;
          if (e2 = +e2, (t2 = +t2) === (n2 = +n2) && e2 > 0)
            return [t2];
          if ((r2 = n2 < t2) && (i2 = t2, t2 = n2, n2 = i2), 0 === (a2 = x(t2, n2, e2)) || !isFinite(a2))
            return [];
          if (a2 > 0)
            for (t2 = Math.ceil(t2 / a2), n2 = Math.floor(n2 / a2), o2 = new Array(i2 = Math.ceil(n2 - t2 + 1)); ++u2 < i2; )
              o2[u2] = (t2 + u2) * a2;
          else
            for (t2 = Math.floor(t2 * a2), n2 = Math.ceil(n2 * a2), o2 = new Array(i2 = Math.ceil(t2 - n2 + 1)); ++u2 < i2; )
              o2[u2] = (t2 - u2) / a2;
          return r2 && o2.reverse(), o2;
        }
        function x(t2, n2, e2) {
          var r2 = (n2 - t2) / Math.max(0, e2), i2 = Math.floor(Math.log(r2) / Math.LN10), o2 = r2 / Math.pow(10, i2);
          return i2 >= 0 ? (o2 >= y ? 10 : o2 >= _ ? 5 : o2 >= b ? 2 : 1) * Math.pow(10, i2) : -Math.pow(10, -i2) / (o2 >= y ? 10 : o2 >= _ ? 5 : o2 >= b ? 2 : 1);
        }
        function w(t2, n2, e2) {
          var r2 = Math.abs(n2 - t2) / Math.max(0, e2), i2 = Math.pow(10, Math.floor(Math.log(r2) / Math.LN10)), o2 = r2 / i2;
          return o2 >= y ? i2 *= 10 : o2 >= _ ? i2 *= 5 : o2 >= b && (i2 *= 2), n2 < t2 ? -i2 : i2;
        }
        function M(t2) {
          return Math.ceil(Math.log(t2.length) / Math.LN2) + 1;
        }
        function N(t2, n2, e2) {
          if (null == e2 && (e2 = u), r2 = t2.length) {
            if ((n2 = +n2) <= 0 || r2 < 2)
              return +e2(t2[0], 0, t2);
            if (n2 >= 1)
              return +e2(t2[r2 - 1], r2 - 1, t2);
            var r2, i2 = (r2 - 1) * n2, o2 = Math.floor(i2), a2 = +e2(t2[o2], o2, t2);
            return a2 + (+e2(t2[o2 + 1], o2 + 1, t2) - a2) * (i2 - o2);
          }
        }
        function A(t2, n2) {
          var e2, r2, i2 = t2.length, o2 = -1;
          if (null == n2) {
            for (; ++o2 < i2; )
              if (null != (e2 = t2[o2]) && e2 >= e2)
                for (r2 = e2; ++o2 < i2; )
                  null != (e2 = t2[o2]) && e2 > r2 && (r2 = e2);
          } else
            for (; ++o2 < i2; )
              if (null != (e2 = n2(t2[o2], o2, t2)) && e2 >= e2)
                for (r2 = e2; ++o2 < i2; )
                  null != (e2 = n2(t2[o2], o2, t2)) && e2 > r2 && (r2 = e2);
          return r2;
        }
        function T(t2) {
          for (var n2, e2, r2, i2 = t2.length, o2 = -1, a2 = 0; ++o2 < i2; )
            a2 += t2[o2].length;
          for (e2 = new Array(a2); --i2 >= 0; )
            for (n2 = (r2 = t2[i2]).length; --n2 >= 0; )
              e2[--a2] = r2[n2];
          return e2;
        }
        function S(t2, n2) {
          var e2, r2, i2 = t2.length, o2 = -1;
          if (null == n2) {
            for (; ++o2 < i2; )
              if (null != (e2 = t2[o2]) && e2 >= e2)
                for (r2 = e2; ++o2 < i2; )
                  null != (e2 = t2[o2]) && r2 > e2 && (r2 = e2);
          } else
            for (; ++o2 < i2; )
              if (null != (e2 = n2(t2[o2], o2, t2)) && e2 >= e2)
                for (r2 = e2; ++o2 < i2; )
                  null != (e2 = n2(t2[o2], o2, t2)) && r2 > e2 && (r2 = e2);
          return r2;
        }
        function k(t2) {
          if (!(i2 = t2.length))
            return [];
          for (var n2 = -1, e2 = S(t2, E), r2 = new Array(e2); ++n2 < e2; )
            for (var i2, o2 = -1, a2 = r2[n2] = new Array(i2); ++o2 < i2; )
              a2[o2] = t2[o2][n2];
          return r2;
        }
        function E(t2) {
          return t2.length;
        }
        var C = Array.prototype.slice;
        function P(t2) {
          return t2;
        }
        var z = 1, R = 2, D = 3, q = 4, L = 1e-6;
        function U(t2) {
          return "translate(" + (t2 + 0.5) + ",0)";
        }
        function O(t2) {
          return "translate(0," + (t2 + 0.5) + ")";
        }
        function B() {
          return !this.__axis;
        }
        function Y(t2, n2) {
          var e2 = [], r2 = null, i2 = null, o2 = 6, a2 = 6, u2 = 3, c2 = t2 === z || t2 === q ? -1 : 1, f2 = t2 === q || t2 === R ? "x" : "y", s2 = t2 === z || t2 === D ? U : O;
          function l2(l3) {
            var h2 = null == r2 ? n2.ticks ? n2.ticks.apply(n2, e2) : n2.domain() : r2, d2 = null == i2 ? n2.tickFormat ? n2.tickFormat.apply(n2, e2) : P : i2, p2 = Math.max(o2, 0) + u2, v2 = n2.range(), g2 = +v2[0] + 0.5, y2 = +v2[v2.length - 1] + 0.5, _2 = (n2.bandwidth ? function(t3) {
              var n3 = Math.max(0, t3.bandwidth() - 1) / 2;
              return t3.round() && (n3 = Math.round(n3)), function(e3) {
                return +t3(e3) + n3;
              };
            } : function(t3) {
              return function(n3) {
                return +t3(n3);
              };
            })(n2.copy()), b2 = l3.selection ? l3.selection() : l3, m2 = b2.selectAll(".domain").data([null]), x2 = b2.selectAll(".tick").data(h2, n2).order(), w2 = x2.exit(), M2 = x2.enter().append("g").attr("class", "tick"), N2 = x2.select("line"), A2 = x2.select("text");
            m2 = m2.merge(m2.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor")), x2 = x2.merge(M2), N2 = N2.merge(M2.append("line").attr("stroke", "currentColor").attr(f2 + "2", c2 * o2)), A2 = A2.merge(M2.append("text").attr("fill", "currentColor").attr(f2, c2 * p2).attr("dy", t2 === z ? "0em" : t2 === D ? "0.71em" : "0.32em")), l3 !== b2 && (m2 = m2.transition(l3), x2 = x2.transition(l3), N2 = N2.transition(l3), A2 = A2.transition(l3), w2 = w2.transition(l3).attr("opacity", L).attr("transform", function(t3) {
              return isFinite(t3 = _2(t3)) ? s2(t3) : this.getAttribute("transform");
            }), M2.attr("opacity", L).attr("transform", function(t3) {
              var n3 = this.parentNode.__axis;
              return s2(n3 && isFinite(n3 = n3(t3)) ? n3 : _2(t3));
            })), w2.remove(), m2.attr("d", t2 === q || t2 == R ? a2 ? "M" + c2 * a2 + "," + g2 + "H0.5V" + y2 + "H" + c2 * a2 : "M0.5," + g2 + "V" + y2 : a2 ? "M" + g2 + "," + c2 * a2 + "V0.5H" + y2 + "V" + c2 * a2 : "M" + g2 + ",0.5H" + y2), x2.attr("opacity", 1).attr("transform", function(t3) {
              return s2(_2(t3));
            }), N2.attr(f2 + "2", c2 * o2), A2.attr(f2, c2 * p2).text(d2), b2.filter(B).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", t2 === R ? "start" : t2 === q ? "end" : "middle"), b2.each(function() {
              this.__axis = _2;
            });
          }
          return l2.scale = function(t3) {
            return arguments.length ? (n2 = t3, l2) : n2;
          }, l2.ticks = function() {
            return e2 = C.call(arguments), l2;
          }, l2.tickArguments = function(t3) {
            return arguments.length ? (e2 = null == t3 ? [] : C.call(t3), l2) : e2.slice();
          }, l2.tickValues = function(t3) {
            return arguments.length ? (r2 = null == t3 ? null : C.call(t3), l2) : r2 && r2.slice();
          }, l2.tickFormat = function(t3) {
            return arguments.length ? (i2 = t3, l2) : i2;
          }, l2.tickSize = function(t3) {
            return arguments.length ? (o2 = a2 = +t3, l2) : o2;
          }, l2.tickSizeInner = function(t3) {
            return arguments.length ? (o2 = +t3, l2) : o2;
          }, l2.tickSizeOuter = function(t3) {
            return arguments.length ? (a2 = +t3, l2) : a2;
          }, l2.tickPadding = function(t3) {
            return arguments.length ? (u2 = +t3, l2) : u2;
          }, l2;
        }
        var F = { value: function() {
        } };
        function I() {
          for (var t2, n2 = 0, e2 = arguments.length, r2 = {}; n2 < e2; ++n2) {
            if (!(t2 = arguments[n2] + "") || t2 in r2)
              throw new Error("illegal type: " + t2);
            r2[t2] = [];
          }
          return new j(r2);
        }
        function j(t2) {
          this._ = t2;
        }
        function H(t2, n2) {
          for (var e2, r2 = 0, i2 = t2.length; r2 < i2; ++r2)
            if ((e2 = t2[r2]).name === n2)
              return e2.value;
        }
        function X(t2, n2, e2) {
          for (var r2 = 0, i2 = t2.length; r2 < i2; ++r2)
            if (t2[r2].name === n2) {
              t2[r2] = F, t2 = t2.slice(0, r2).concat(t2.slice(r2 + 1));
              break;
            }
          return null != e2 && t2.push({ name: n2, value: e2 }), t2;
        }
        j.prototype = I.prototype = { constructor: j, on: function(t2, n2) {
          var e2, r2, i2 = this._, o2 = (r2 = i2, (t2 + "").trim().split(/^|\s+/).map(function(t3) {
            var n3 = "", e3 = t3.indexOf(".");
            if (e3 >= 0 && (n3 = t3.slice(e3 + 1), t3 = t3.slice(0, e3)), t3 && !r2.hasOwnProperty(t3))
              throw new Error("unknown type: " + t3);
            return { type: t3, name: n3 };
          })), a2 = -1, u2 = o2.length;
          if (!(arguments.length < 2)) {
            if (null != n2 && "function" != typeof n2)
              throw new Error("invalid callback: " + n2);
            for (; ++a2 < u2; )
              if (e2 = (t2 = o2[a2]).type)
                i2[e2] = X(i2[e2], t2.name, n2);
              else if (null == n2)
                for (e2 in i2)
                  i2[e2] = X(i2[e2], t2.name, null);
            return this;
          }
          for (; ++a2 < u2; )
            if ((e2 = (t2 = o2[a2]).type) && (e2 = H(i2[e2], t2.name)))
              return e2;
        }, copy: function() {
          var t2 = {}, n2 = this._;
          for (var e2 in n2)
            t2[e2] = n2[e2].slice();
          return new j(t2);
        }, call: function(t2, n2) {
          if ((e2 = arguments.length - 2) > 0)
            for (var e2, r2, i2 = new Array(e2), o2 = 0; o2 < e2; ++o2)
              i2[o2] = arguments[o2 + 2];
          if (!this._.hasOwnProperty(t2))
            throw new Error("unknown type: " + t2);
          for (o2 = 0, e2 = (r2 = this._[t2]).length; o2 < e2; ++o2)
            r2[o2].value.apply(n2, i2);
        }, apply: function(t2, n2, e2) {
          if (!this._.hasOwnProperty(t2))
            throw new Error("unknown type: " + t2);
          for (var r2 = this._[t2], i2 = 0, o2 = r2.length; i2 < o2; ++i2)
            r2[i2].value.apply(n2, e2);
        } };
        var G = "http://www.w3.org/1999/xhtml", V = { svg: "http://www.w3.org/2000/svg", xhtml: G, xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/" };
        function $(t2) {
          var n2 = t2 += "", e2 = n2.indexOf(":");
          return e2 >= 0 && "xmlns" !== (n2 = t2.slice(0, e2)) && (t2 = t2.slice(e2 + 1)), V.hasOwnProperty(n2) ? { space: V[n2], local: t2 } : t2;
        }
        function W(t2) {
          var n2 = $(t2);
          return (n2.local ? function(t3) {
            return function() {
              return this.ownerDocument.createElementNS(t3.space, t3.local);
            };
          } : function(t3) {
            return function() {
              var n3 = this.ownerDocument, e2 = this.namespaceURI;
              return e2 === G && n3.documentElement.namespaceURI === G ? n3.createElement(t3) : n3.createElementNS(e2, t3);
            };
          })(n2);
        }
        function Z() {
        }
        function Q(t2) {
          return null == t2 ? Z : function() {
            return this.querySelector(t2);
          };
        }
        function J() {
          return [];
        }
        function K(t2) {
          return null == t2 ? J : function() {
            return this.querySelectorAll(t2);
          };
        }
        function tt(t2) {
          return function() {
            return this.matches(t2);
          };
        }
        function nt(t2) {
          return new Array(t2.length);
        }
        function et(t2, n2) {
          this.ownerDocument = t2.ownerDocument, this.namespaceURI = t2.namespaceURI, this._next = null, this._parent = t2, this.__data__ = n2;
        }
        et.prototype = { constructor: et, appendChild: function(t2) {
          return this._parent.insertBefore(t2, this._next);
        }, insertBefore: function(t2, n2) {
          return this._parent.insertBefore(t2, n2);
        }, querySelector: function(t2) {
          return this._parent.querySelector(t2);
        }, querySelectorAll: function(t2) {
          return this._parent.querySelectorAll(t2);
        } };
        var rt = "$";
        function it(t2, n2, e2, r2, i2, o2) {
          for (var a2, u2 = 0, c2 = n2.length, f2 = o2.length; u2 < f2; ++u2)
            (a2 = n2[u2]) ? (a2.__data__ = o2[u2], r2[u2] = a2) : e2[u2] = new et(t2, o2[u2]);
          for (; u2 < c2; ++u2)
            (a2 = n2[u2]) && (i2[u2] = a2);
        }
        function ot(t2, n2, e2, r2, i2, o2, a2) {
          var u2, c2, f2, s2 = {}, l2 = n2.length, h2 = o2.length, d2 = new Array(l2);
          for (u2 = 0; u2 < l2; ++u2)
            (c2 = n2[u2]) && (d2[u2] = f2 = rt + a2.call(c2, c2.__data__, u2, n2), f2 in s2 ? i2[u2] = c2 : s2[f2] = c2);
          for (u2 = 0; u2 < h2; ++u2)
            (c2 = s2[f2 = rt + a2.call(t2, o2[u2], u2, o2)]) ? (r2[u2] = c2, c2.__data__ = o2[u2], s2[f2] = null) : e2[u2] = new et(t2, o2[u2]);
          for (u2 = 0; u2 < l2; ++u2)
            (c2 = n2[u2]) && s2[d2[u2]] === c2 && (i2[u2] = c2);
        }
        function at(t2, n2) {
          return t2 < n2 ? -1 : t2 > n2 ? 1 : t2 >= n2 ? 0 : NaN;
        }
        function ut(t2) {
          return t2.ownerDocument && t2.ownerDocument.defaultView || t2.document && t2 || t2.defaultView;
        }
        function ct(t2, n2) {
          return t2.style.getPropertyValue(n2) || ut(t2).getComputedStyle(t2, null).getPropertyValue(n2);
        }
        function ft(t2) {
          return t2.trim().split(/^|\s+/);
        }
        function st(t2) {
          return t2.classList || new lt(t2);
        }
        function lt(t2) {
          this._node = t2, this._names = ft(t2.getAttribute("class") || "");
        }
        function ht(t2, n2) {
          for (var e2 = st(t2), r2 = -1, i2 = n2.length; ++r2 < i2; )
            e2.add(n2[r2]);
        }
        function dt(t2, n2) {
          for (var e2 = st(t2), r2 = -1, i2 = n2.length; ++r2 < i2; )
            e2.remove(n2[r2]);
        }
        function pt() {
          this.textContent = "";
        }
        function vt() {
          this.innerHTML = "";
        }
        function gt() {
          this.nextSibling && this.parentNode.appendChild(this);
        }
        function yt() {
          this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
        }
        function _t() {
          return null;
        }
        function bt() {
          var t2 = this.parentNode;
          t2 && t2.removeChild(this);
        }
        function mt() {
          return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling);
        }
        function xt() {
          return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);
        }
        lt.prototype = { add: function(t2) {
          this._names.indexOf(t2) < 0 && (this._names.push(t2), this._node.setAttribute("class", this._names.join(" ")));
        }, remove: function(t2) {
          var n2 = this._names.indexOf(t2);
          n2 >= 0 && (this._names.splice(n2, 1), this._node.setAttribute("class", this._names.join(" ")));
        }, contains: function(t2) {
          return this._names.indexOf(t2) >= 0;
        } };
        var wt = {};
        (t.event = null, "undefined" != typeof document) && ("onmouseenter" in document.documentElement || (wt = { mouseenter: "mouseover", mouseleave: "mouseout" }));
        function Mt(t2, n2, e2) {
          return t2 = Nt(t2, n2, e2), function(n3) {
            var e3 = n3.relatedTarget;
            e3 && (e3 === this || 8 & e3.compareDocumentPosition(this)) || t2.call(this, n3);
          };
        }
        function Nt(n2, e2, r2) {
          return function(i2) {
            var o2 = t.event;
            t.event = i2;
            try {
              n2.call(this, this.__data__, e2, r2);
            } finally {
              t.event = o2;
            }
          };
        }
        function At(t2) {
          return function() {
            var n2 = this.__on;
            if (n2) {
              for (var e2, r2 = 0, i2 = -1, o2 = n2.length; r2 < o2; ++r2)
                e2 = n2[r2], t2.type && e2.type !== t2.type || e2.name !== t2.name ? n2[++i2] = e2 : this.removeEventListener(e2.type, e2.listener, e2.capture);
              ++i2 ? n2.length = i2 : delete this.__on;
            }
          };
        }
        function Tt(t2, n2, e2) {
          var r2 = wt.hasOwnProperty(t2.type) ? Mt : Nt;
          return function(i2, o2, a2) {
            var u2, c2 = this.__on, f2 = r2(n2, o2, a2);
            if (c2) {
              for (var s2 = 0, l2 = c2.length; s2 < l2; ++s2)
                if ((u2 = c2[s2]).type === t2.type && u2.name === t2.name)
                  return this.removeEventListener(u2.type, u2.listener, u2.capture), this.addEventListener(u2.type, u2.listener = f2, u2.capture = e2), void (u2.value = n2);
            }
            this.addEventListener(t2.type, f2, e2), u2 = { type: t2.type, name: t2.name, value: n2, listener: f2, capture: e2 }, c2 ? c2.push(u2) : this.__on = [u2];
          };
        }
        function St(n2, e2, r2, i2) {
          var o2 = t.event;
          n2.sourceEvent = t.event, t.event = n2;
          try {
            return e2.apply(r2, i2);
          } finally {
            t.event = o2;
          }
        }
        function kt(t2, n2, e2) {
          var r2 = ut(t2), i2 = r2.CustomEvent;
          "function" == typeof i2 ? i2 = new i2(n2, e2) : (i2 = r2.document.createEvent("Event"), e2 ? (i2.initEvent(n2, e2.bubbles, e2.cancelable), i2.detail = e2.detail) : i2.initEvent(n2, false, false)), t2.dispatchEvent(i2);
        }
        var Et = [null];
        function Ct(t2, n2) {
          this._groups = t2, this._parents = n2;
        }
        function Pt() {
          return new Ct([[document.documentElement]], Et);
        }
        function zt(t2) {
          return "string" == typeof t2 ? new Ct([[document.querySelector(t2)]], [document.documentElement]) : new Ct([[t2]], Et);
        }
        Ct.prototype = Pt.prototype = { constructor: Ct, select: function(t2) {
          "function" != typeof t2 && (t2 = Q(t2));
          for (var n2 = this._groups, e2 = n2.length, r2 = new Array(e2), i2 = 0; i2 < e2; ++i2)
            for (var o2, a2, u2 = n2[i2], c2 = u2.length, f2 = r2[i2] = new Array(c2), s2 = 0; s2 < c2; ++s2)
              (o2 = u2[s2]) && (a2 = t2.call(o2, o2.__data__, s2, u2)) && ("__data__" in o2 && (a2.__data__ = o2.__data__), f2[s2] = a2);
          return new Ct(r2, this._parents);
        }, selectAll: function(t2) {
          "function" != typeof t2 && (t2 = K(t2));
          for (var n2 = this._groups, e2 = n2.length, r2 = [], i2 = [], o2 = 0; o2 < e2; ++o2)
            for (var a2, u2 = n2[o2], c2 = u2.length, f2 = 0; f2 < c2; ++f2)
              (a2 = u2[f2]) && (r2.push(t2.call(a2, a2.__data__, f2, u2)), i2.push(a2));
          return new Ct(r2, i2);
        }, filter: function(t2) {
          "function" != typeof t2 && (t2 = tt(t2));
          for (var n2 = this._groups, e2 = n2.length, r2 = new Array(e2), i2 = 0; i2 < e2; ++i2)
            for (var o2, a2 = n2[i2], u2 = a2.length, c2 = r2[i2] = [], f2 = 0; f2 < u2; ++f2)
              (o2 = a2[f2]) && t2.call(o2, o2.__data__, f2, a2) && c2.push(o2);
          return new Ct(r2, this._parents);
        }, data: function(t2, n2) {
          if (!t2)
            return p2 = new Array(this.size()), s2 = -1, this.each(function(t3) {
              p2[++s2] = t3;
            }), p2;
          var e2, r2 = n2 ? ot : it, i2 = this._parents, o2 = this._groups;
          "function" != typeof t2 && (e2 = t2, t2 = function() {
            return e2;
          });
          for (var a2 = o2.length, u2 = new Array(a2), c2 = new Array(a2), f2 = new Array(a2), s2 = 0; s2 < a2; ++s2) {
            var l2 = i2[s2], h2 = o2[s2], d2 = h2.length, p2 = t2.call(l2, l2 && l2.__data__, s2, i2), v2 = p2.length, g2 = c2[s2] = new Array(v2), y2 = u2[s2] = new Array(v2);
            r2(l2, h2, g2, y2, f2[s2] = new Array(d2), p2, n2);
            for (var _2, b2, m2 = 0, x2 = 0; m2 < v2; ++m2)
              if (_2 = g2[m2]) {
                for (m2 >= x2 && (x2 = m2 + 1); !(b2 = y2[x2]) && ++x2 < v2; )
                  ;
                _2._next = b2 || null;
              }
          }
          return (u2 = new Ct(u2, i2))._enter = c2, u2._exit = f2, u2;
        }, enter: function() {
          return new Ct(this._enter || this._groups.map(nt), this._parents);
        }, exit: function() {
          return new Ct(this._exit || this._groups.map(nt), this._parents);
        }, join: function(t2, n2, e2) {
          var r2 = this.enter(), i2 = this, o2 = this.exit();
          return r2 = "function" == typeof t2 ? t2(r2) : r2.append(t2 + ""), null != n2 && (i2 = n2(i2)), null == e2 ? o2.remove() : e2(o2), r2 && i2 ? r2.merge(i2).order() : i2;
        }, merge: function(t2) {
          for (var n2 = this._groups, e2 = t2._groups, r2 = n2.length, i2 = e2.length, o2 = Math.min(r2, i2), a2 = new Array(r2), u2 = 0; u2 < o2; ++u2)
            for (var c2, f2 = n2[u2], s2 = e2[u2], l2 = f2.length, h2 = a2[u2] = new Array(l2), d2 = 0; d2 < l2; ++d2)
              (c2 = f2[d2] || s2[d2]) && (h2[d2] = c2);
          for (; u2 < r2; ++u2)
            a2[u2] = n2[u2];
          return new Ct(a2, this._parents);
        }, order: function() {
          for (var t2 = this._groups, n2 = -1, e2 = t2.length; ++n2 < e2; )
            for (var r2, i2 = t2[n2], o2 = i2.length - 1, a2 = i2[o2]; --o2 >= 0; )
              (r2 = i2[o2]) && (a2 && 4 ^ r2.compareDocumentPosition(a2) && a2.parentNode.insertBefore(r2, a2), a2 = r2);
          return this;
        }, sort: function(t2) {
          function n2(n3, e3) {
            return n3 && e3 ? t2(n3.__data__, e3.__data__) : !n3 - !e3;
          }
          t2 || (t2 = at);
          for (var e2 = this._groups, r2 = e2.length, i2 = new Array(r2), o2 = 0; o2 < r2; ++o2) {
            for (var a2, u2 = e2[o2], c2 = u2.length, f2 = i2[o2] = new Array(c2), s2 = 0; s2 < c2; ++s2)
              (a2 = u2[s2]) && (f2[s2] = a2);
            f2.sort(n2);
          }
          return new Ct(i2, this._parents).order();
        }, call: function() {
          var t2 = arguments[0];
          return arguments[0] = this, t2.apply(null, arguments), this;
        }, nodes: function() {
          var t2 = new Array(this.size()), n2 = -1;
          return this.each(function() {
            t2[++n2] = this;
          }), t2;
        }, node: function() {
          for (var t2 = this._groups, n2 = 0, e2 = t2.length; n2 < e2; ++n2)
            for (var r2 = t2[n2], i2 = 0, o2 = r2.length; i2 < o2; ++i2) {
              var a2 = r2[i2];
              if (a2)
                return a2;
            }
          return null;
        }, size: function() {
          var t2 = 0;
          return this.each(function() {
            ++t2;
          }), t2;
        }, empty: function() {
          return !this.node();
        }, each: function(t2) {
          for (var n2 = this._groups, e2 = 0, r2 = n2.length; e2 < r2; ++e2)
            for (var i2, o2 = n2[e2], a2 = 0, u2 = o2.length; a2 < u2; ++a2)
              (i2 = o2[a2]) && t2.call(i2, i2.__data__, a2, o2);
          return this;
        }, attr: function(t2, n2) {
          var e2 = $(t2);
          if (arguments.length < 2) {
            var r2 = this.node();
            return e2.local ? r2.getAttributeNS(e2.space, e2.local) : r2.getAttribute(e2);
          }
          return this.each((null == n2 ? e2.local ? function(t3) {
            return function() {
              this.removeAttributeNS(t3.space, t3.local);
            };
          } : function(t3) {
            return function() {
              this.removeAttribute(t3);
            };
          } : "function" == typeof n2 ? e2.local ? function(t3, n3) {
            return function() {
              var e3 = n3.apply(this, arguments);
              null == e3 ? this.removeAttributeNS(t3.space, t3.local) : this.setAttributeNS(t3.space, t3.local, e3);
            };
          } : function(t3, n3) {
            return function() {
              var e3 = n3.apply(this, arguments);
              null == e3 ? this.removeAttribute(t3) : this.setAttribute(t3, e3);
            };
          } : e2.local ? function(t3, n3) {
            return function() {
              this.setAttributeNS(t3.space, t3.local, n3);
            };
          } : function(t3, n3) {
            return function() {
              this.setAttribute(t3, n3);
            };
          })(e2, n2));
        }, style: function(t2, n2, e2) {
          return arguments.length > 1 ? this.each((null == n2 ? function(t3) {
            return function() {
              this.style.removeProperty(t3);
            };
          } : "function" == typeof n2 ? function(t3, n3, e3) {
            return function() {
              var r2 = n3.apply(this, arguments);
              null == r2 ? this.style.removeProperty(t3) : this.style.setProperty(t3, r2, e3);
            };
          } : function(t3, n3, e3) {
            return function() {
              this.style.setProperty(t3, n3, e3);
            };
          })(t2, n2, null == e2 ? "" : e2)) : ct(this.node(), t2);
        }, property: function(t2, n2) {
          return arguments.length > 1 ? this.each((null == n2 ? function(t3) {
            return function() {
              delete this[t3];
            };
          } : "function" == typeof n2 ? function(t3, n3) {
            return function() {
              var e2 = n3.apply(this, arguments);
              null == e2 ? delete this[t3] : this[t3] = e2;
            };
          } : function(t3, n3) {
            return function() {
              this[t3] = n3;
            };
          })(t2, n2)) : this.node()[t2];
        }, classed: function(t2, n2) {
          var e2 = ft(t2 + "");
          if (arguments.length < 2) {
            for (var r2 = st(this.node()), i2 = -1, o2 = e2.length; ++i2 < o2; )
              if (!r2.contains(e2[i2]))
                return false;
            return true;
          }
          return this.each(("function" == typeof n2 ? function(t3, n3) {
            return function() {
              (n3.apply(this, arguments) ? ht : dt)(this, t3);
            };
          } : n2 ? function(t3) {
            return function() {
              ht(this, t3);
            };
          } : function(t3) {
            return function() {
              dt(this, t3);
            };
          })(e2, n2));
        }, text: function(t2) {
          return arguments.length ? this.each(null == t2 ? pt : ("function" == typeof t2 ? function(t3) {
            return function() {
              var n2 = t3.apply(this, arguments);
              this.textContent = null == n2 ? "" : n2;
            };
          } : function(t3) {
            return function() {
              this.textContent = t3;
            };
          })(t2)) : this.node().textContent;
        }, html: function(t2) {
          return arguments.length ? this.each(null == t2 ? vt : ("function" == typeof t2 ? function(t3) {
            return function() {
              var n2 = t3.apply(this, arguments);
              this.innerHTML = null == n2 ? "" : n2;
            };
          } : function(t3) {
            return function() {
              this.innerHTML = t3;
            };
          })(t2)) : this.node().innerHTML;
        }, raise: function() {
          return this.each(gt);
        }, lower: function() {
          return this.each(yt);
        }, append: function(t2) {
          var n2 = "function" == typeof t2 ? t2 : W(t2);
          return this.select(function() {
            return this.appendChild(n2.apply(this, arguments));
          });
        }, insert: function(t2, n2) {
          var e2 = "function" == typeof t2 ? t2 : W(t2), r2 = null == n2 ? _t : "function" == typeof n2 ? n2 : Q(n2);
          return this.select(function() {
            return this.insertBefore(e2.apply(this, arguments), r2.apply(this, arguments) || null);
          });
        }, remove: function() {
          return this.each(bt);
        }, clone: function(t2) {
          return this.select(t2 ? xt : mt);
        }, datum: function(t2) {
          return arguments.length ? this.property("__data__", t2) : this.node().__data__;
        }, on: function(t2, n2, e2) {
          var r2, i2, o2 = function(t3) {
            return t3.trim().split(/^|\s+/).map(function(t4) {
              var n3 = "", e3 = t4.indexOf(".");
              return e3 >= 0 && (n3 = t4.slice(e3 + 1), t4 = t4.slice(0, e3)), { type: t4, name: n3 };
            });
          }(t2 + ""), a2 = o2.length;
          if (!(arguments.length < 2)) {
            for (u2 = n2 ? Tt : At, null == e2 && (e2 = false), r2 = 0; r2 < a2; ++r2)
              this.each(u2(o2[r2], n2, e2));
            return this;
          }
          var u2 = this.node().__on;
          if (u2) {
            for (var c2, f2 = 0, s2 = u2.length; f2 < s2; ++f2)
              for (r2 = 0, c2 = u2[f2]; r2 < a2; ++r2)
                if ((i2 = o2[r2]).type === c2.type && i2.name === c2.name)
                  return c2.value;
          }
        }, dispatch: function(t2, n2) {
          return this.each(("function" == typeof n2 ? function(t3, n3) {
            return function() {
              return kt(this, t3, n3.apply(this, arguments));
            };
          } : function(t3, n3) {
            return function() {
              return kt(this, t3, n3);
            };
          })(t2, n2));
        } };
        var Rt = 0;
        function Dt() {
          return new qt();
        }
        function qt() {
          this._ = "@" + (++Rt).toString(36);
        }
        function Lt() {
          for (var n2, e2 = t.event; n2 = e2.sourceEvent; )
            e2 = n2;
          return e2;
        }
        function Ut(t2, n2) {
          var e2 = t2.ownerSVGElement || t2;
          if (e2.createSVGPoint) {
            var r2 = e2.createSVGPoint();
            return r2.x = n2.clientX, r2.y = n2.clientY, [(r2 = r2.matrixTransform(t2.getScreenCTM().inverse())).x, r2.y];
          }
          var i2 = t2.getBoundingClientRect();
          return [n2.clientX - i2.left - t2.clientLeft, n2.clientY - i2.top - t2.clientTop];
        }
        function Ot(t2) {
          var n2 = Lt();
          return n2.changedTouches && (n2 = n2.changedTouches[0]), Ut(t2, n2);
        }
        function Bt(t2, n2, e2) {
          arguments.length < 3 && (e2 = n2, n2 = Lt().changedTouches);
          for (var r2, i2 = 0, o2 = n2 ? n2.length : 0; i2 < o2; ++i2)
            if ((r2 = n2[i2]).identifier === e2)
              return Ut(t2, r2);
          return null;
        }
        function Yt() {
          t.event.stopImmediatePropagation();
        }
        function Ft() {
          t.event.preventDefault(), t.event.stopImmediatePropagation();
        }
        function It(t2) {
          var n2 = t2.document.documentElement, e2 = zt(t2).on("dragstart.drag", Ft, true);
          "onselectstart" in n2 ? e2.on("selectstart.drag", Ft, true) : (n2.__noselect = n2.style.MozUserSelect, n2.style.MozUserSelect = "none");
        }
        function jt(t2, n2) {
          var e2 = t2.document.documentElement, r2 = zt(t2).on("dragstart.drag", null);
          n2 && (r2.on("click.drag", Ft, true), window.setTimeout(function() {
            r2.on("click.drag", null);
          }, 0)), "onselectstart" in e2 ? r2.on("selectstart.drag", null) : (e2.style.MozUserSelect = e2.__noselect, delete e2.__noselect);
        }
        function Ht(t2) {
          return function() {
            return t2;
          };
        }
        function Xt(t2, n2, e2, r2, i2, o2, a2, u2, c2, f2) {
          this.target = t2, this.type = n2, this.subject = e2, this.identifier = r2, this.active = i2, this.x = o2, this.y = a2, this.dx = u2, this.dy = c2, this._ = f2;
        }
        function Gt() {
          return !t.event.button;
        }
        function Vt() {
          return this.parentNode;
        }
        function $t(n2) {
          return null == n2 ? { x: t.event.x, y: t.event.y } : n2;
        }
        function Wt() {
          return "ontouchstart" in this;
        }
        function Zt(t2, n2, e2) {
          t2.prototype = n2.prototype = e2, e2.constructor = t2;
        }
        function Qt(t2, n2) {
          var e2 = Object.create(t2.prototype);
          for (var r2 in n2)
            e2[r2] = n2[r2];
          return e2;
        }
        function Jt() {
        }
        qt.prototype = Dt.prototype = { constructor: qt, get: function(t2) {
          for (var n2 = this._; !(n2 in t2); )
            if (!(t2 = t2.parentNode))
              return;
          return t2[n2];
        }, set: function(t2, n2) {
          return t2[this._] = n2;
        }, remove: function(t2) {
          return this._ in t2 && delete t2[this._];
        }, toString: function() {
          return this._;
        } }, Xt.prototype.on = function() {
          var t2 = this._.on.apply(this._, arguments);
          return t2 === this._ ? this : t2;
        };
        var Kt = "\\s*([+-]?\\d+)\\s*", tn = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*", nn = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*", en = /^#([0-9a-f]{3})$/, rn = /^#([0-9a-f]{6})$/, on = new RegExp("^rgb\\(" + [Kt, Kt, Kt] + "\\)$"), an = new RegExp("^rgb\\(" + [nn, nn, nn] + "\\)$"), un = new RegExp("^rgba\\(" + [Kt, Kt, Kt, tn] + "\\)$"), cn = new RegExp("^rgba\\(" + [nn, nn, nn, tn] + "\\)$"), fn = new RegExp("^hsl\\(" + [tn, nn, nn] + "\\)$"), sn = new RegExp("^hsla\\(" + [tn, nn, nn, tn] + "\\)$"), ln = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 };
        function hn(t2) {
          var n2;
          return t2 = (t2 + "").trim().toLowerCase(), (n2 = en.exec(t2)) ? new yn((n2 = parseInt(n2[1], 16)) >> 8 & 15 | n2 >> 4 & 240, n2 >> 4 & 15 | 240 & n2, (15 & n2) << 4 | 15 & n2, 1) : (n2 = rn.exec(t2)) ? dn(parseInt(n2[1], 16)) : (n2 = on.exec(t2)) ? new yn(n2[1], n2[2], n2[3], 1) : (n2 = an.exec(t2)) ? new yn(255 * n2[1] / 100, 255 * n2[2] / 100, 255 * n2[3] / 100, 1) : (n2 = un.exec(t2)) ? pn(n2[1], n2[2], n2[3], n2[4]) : (n2 = cn.exec(t2)) ? pn(255 * n2[1] / 100, 255 * n2[2] / 100, 255 * n2[3] / 100, n2[4]) : (n2 = fn.exec(t2)) ? bn(n2[1], n2[2] / 100, n2[3] / 100, 1) : (n2 = sn.exec(t2)) ? bn(n2[1], n2[2] / 100, n2[3] / 100, n2[4]) : ln.hasOwnProperty(t2) ? dn(ln[t2]) : "transparent" === t2 ? new yn(NaN, NaN, NaN, 0) : null;
        }
        function dn(t2) {
          return new yn(t2 >> 16 & 255, t2 >> 8 & 255, 255 & t2, 1);
        }
        function pn(t2, n2, e2, r2) {
          return r2 <= 0 && (t2 = n2 = e2 = NaN), new yn(t2, n2, e2, r2);
        }
        function vn(t2) {
          return t2 instanceof Jt || (t2 = hn(t2)), t2 ? new yn((t2 = t2.rgb()).r, t2.g, t2.b, t2.opacity) : new yn();
        }
        function gn(t2, n2, e2, r2) {
          return 1 === arguments.length ? vn(t2) : new yn(t2, n2, e2, null == r2 ? 1 : r2);
        }
        function yn(t2, n2, e2, r2) {
          this.r = +t2, this.g = +n2, this.b = +e2, this.opacity = +r2;
        }
        function _n(t2) {
          return ((t2 = Math.max(0, Math.min(255, Math.round(t2) || 0))) < 16 ? "0" : "") + t2.toString(16);
        }
        function bn(t2, n2, e2, r2) {
          return r2 <= 0 ? t2 = n2 = e2 = NaN : e2 <= 0 || e2 >= 1 ? t2 = n2 = NaN : n2 <= 0 && (t2 = NaN), new xn(t2, n2, e2, r2);
        }
        function mn(t2, n2, e2, r2) {
          return 1 === arguments.length ? function(t3) {
            if (t3 instanceof xn)
              return new xn(t3.h, t3.s, t3.l, t3.opacity);
            if (t3 instanceof Jt || (t3 = hn(t3)), !t3)
              return new xn();
            if (t3 instanceof xn)
              return t3;
            var n3 = (t3 = t3.rgb()).r / 255, e3 = t3.g / 255, r3 = t3.b / 255, i2 = Math.min(n3, e3, r3), o2 = Math.max(n3, e3, r3), a2 = NaN, u2 = o2 - i2, c2 = (o2 + i2) / 2;
            return u2 ? (a2 = n3 === o2 ? (e3 - r3) / u2 + 6 * (e3 < r3) : e3 === o2 ? (r3 - n3) / u2 + 2 : (n3 - e3) / u2 + 4, u2 /= c2 < 0.5 ? o2 + i2 : 2 - o2 - i2, a2 *= 60) : u2 = c2 > 0 && c2 < 1 ? 0 : a2, new xn(a2, u2, c2, t3.opacity);
          }(t2) : new xn(t2, n2, e2, null == r2 ? 1 : r2);
        }
        function xn(t2, n2, e2, r2) {
          this.h = +t2, this.s = +n2, this.l = +e2, this.opacity = +r2;
        }
        function wn(t2, n2, e2) {
          return 255 * (t2 < 60 ? n2 + (e2 - n2) * t2 / 60 : t2 < 180 ? e2 : t2 < 240 ? n2 + (e2 - n2) * (240 - t2) / 60 : n2);
        }
        Zt(Jt, hn, { displayable: function() {
          return this.rgb().displayable();
        }, hex: function() {
          return this.rgb().hex();
        }, toString: function() {
          return this.rgb() + "";
        } }), Zt(yn, gn, Qt(Jt, { brighter: function(t2) {
          return t2 = null == t2 ? 1 / 0.7 : Math.pow(1 / 0.7, t2), new yn(this.r * t2, this.g * t2, this.b * t2, this.opacity);
        }, darker: function(t2) {
          return t2 = null == t2 ? 0.7 : Math.pow(0.7, t2), new yn(this.r * t2, this.g * t2, this.b * t2, this.opacity);
        }, rgb: function() {
          return this;
        }, displayable: function() {
          return 0 <= this.r && this.r <= 255 && 0 <= this.g && this.g <= 255 && 0 <= this.b && this.b <= 255 && 0 <= this.opacity && this.opacity <= 1;
        }, hex: function() {
          return "#" + _n(this.r) + _n(this.g) + _n(this.b);
        }, toString: function() {
          var t2 = this.opacity;
          return (1 === (t2 = isNaN(t2) ? 1 : Math.max(0, Math.min(1, t2))) ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (1 === t2 ? ")" : ", " + t2 + ")");
        } })), Zt(xn, mn, Qt(Jt, { brighter: function(t2) {
          return t2 = null == t2 ? 1 / 0.7 : Math.pow(1 / 0.7, t2), new xn(this.h, this.s, this.l * t2, this.opacity);
        }, darker: function(t2) {
          return t2 = null == t2 ? 0.7 : Math.pow(0.7, t2), new xn(this.h, this.s, this.l * t2, this.opacity);
        }, rgb: function() {
          var t2 = this.h % 360 + 360 * (this.h < 0), n2 = isNaN(t2) || isNaN(this.s) ? 0 : this.s, e2 = this.l, r2 = e2 + (e2 < 0.5 ? e2 : 1 - e2) * n2, i2 = 2 * e2 - r2;
          return new yn(wn(t2 >= 240 ? t2 - 240 : t2 + 120, i2, r2), wn(t2, i2, r2), wn(t2 < 120 ? t2 + 240 : t2 - 120, i2, r2), this.opacity);
        }, displayable: function() {
          return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
        } }));
        var Mn = Math.PI / 180, Nn = 180 / Math.PI, An = 0.96422, Tn = 1, Sn = 0.82521, kn = 4 / 29, En = 6 / 29, Cn = 3 * En * En, Pn = En * En * En;
        function zn(t2) {
          if (t2 instanceof Dn)
            return new Dn(t2.l, t2.a, t2.b, t2.opacity);
          if (t2 instanceof Fn) {
            if (isNaN(t2.h))
              return new Dn(t2.l, 0, 0, t2.opacity);
            var n2 = t2.h * Mn;
            return new Dn(t2.l, Math.cos(n2) * t2.c, Math.sin(n2) * t2.c, t2.opacity);
          }
          t2 instanceof yn || (t2 = vn(t2));
          var e2, r2, i2 = On(t2.r), o2 = On(t2.g), a2 = On(t2.b), u2 = qn((0.2225045 * i2 + 0.7168786 * o2 + 0.0606169 * a2) / Tn);
          return i2 === o2 && o2 === a2 ? e2 = r2 = u2 : (e2 = qn((0.4360747 * i2 + 0.3850649 * o2 + 0.1430804 * a2) / An), r2 = qn((0.0139322 * i2 + 0.0971045 * o2 + 0.7141733 * a2) / Sn)), new Dn(116 * u2 - 16, 500 * (e2 - u2), 200 * (u2 - r2), t2.opacity);
        }
        function Rn(t2, n2, e2, r2) {
          return 1 === arguments.length ? zn(t2) : new Dn(t2, n2, e2, null == r2 ? 1 : r2);
        }
        function Dn(t2, n2, e2, r2) {
          this.l = +t2, this.a = +n2, this.b = +e2, this.opacity = +r2;
        }
        function qn(t2) {
          return t2 > Pn ? Math.pow(t2, 1 / 3) : t2 / Cn + kn;
        }
        function Ln(t2) {
          return t2 > En ? t2 * t2 * t2 : Cn * (t2 - kn);
        }
        function Un(t2) {
          return 255 * (t2 <= 31308e-7 ? 12.92 * t2 : 1.055 * Math.pow(t2, 1 / 2.4) - 0.055);
        }
        function On(t2) {
          return (t2 /= 255) <= 0.04045 ? t2 / 12.92 : Math.pow((t2 + 0.055) / 1.055, 2.4);
        }
        function Bn(t2) {
          if (t2 instanceof Fn)
            return new Fn(t2.h, t2.c, t2.l, t2.opacity);
          if (t2 instanceof Dn || (t2 = zn(t2)), 0 === t2.a && 0 === t2.b)
            return new Fn(NaN, 0, t2.l, t2.opacity);
          var n2 = Math.atan2(t2.b, t2.a) * Nn;
          return new Fn(n2 < 0 ? n2 + 360 : n2, Math.sqrt(t2.a * t2.a + t2.b * t2.b), t2.l, t2.opacity);
        }
        function Yn(t2, n2, e2, r2) {
          return 1 === arguments.length ? Bn(t2) : new Fn(t2, n2, e2, null == r2 ? 1 : r2);
        }
        function Fn(t2, n2, e2, r2) {
          this.h = +t2, this.c = +n2, this.l = +e2, this.opacity = +r2;
        }
        Zt(Dn, Rn, Qt(Jt, { brighter: function(t2) {
          return new Dn(this.l + 18 * (null == t2 ? 1 : t2), this.a, this.b, this.opacity);
        }, darker: function(t2) {
          return new Dn(this.l - 18 * (null == t2 ? 1 : t2), this.a, this.b, this.opacity);
        }, rgb: function() {
          var t2 = (this.l + 16) / 116, n2 = isNaN(this.a) ? t2 : t2 + this.a / 500, e2 = isNaN(this.b) ? t2 : t2 - this.b / 200;
          return new yn(Un(3.1338561 * (n2 = An * Ln(n2)) - 1.6168667 * (t2 = Tn * Ln(t2)) - 0.4906146 * (e2 = Sn * Ln(e2))), Un(-0.9787684 * n2 + 1.9161415 * t2 + 0.033454 * e2), Un(0.0719453 * n2 - 0.2289914 * t2 + 1.4052427 * e2), this.opacity);
        } })), Zt(Fn, Yn, Qt(Jt, { brighter: function(t2) {
          return new Fn(this.h, this.c, this.l + 18 * (null == t2 ? 1 : t2), this.opacity);
        }, darker: function(t2) {
          return new Fn(this.h, this.c, this.l - 18 * (null == t2 ? 1 : t2), this.opacity);
        }, rgb: function() {
          return zn(this).rgb();
        } }));
        var In = -0.14861, jn = 1.78277, Hn = -0.29227, Xn = -0.90649, Gn = 1.97294, Vn = Gn * Xn, $n = Gn * jn, Wn = jn * Hn - Xn * In;
        function Zn(t2, n2, e2, r2) {
          return 1 === arguments.length ? function(t3) {
            if (t3 instanceof Qn)
              return new Qn(t3.h, t3.s, t3.l, t3.opacity);
            t3 instanceof yn || (t3 = vn(t3));
            var n3 = t3.r / 255, e3 = t3.g / 255, r3 = t3.b / 255, i2 = (Wn * r3 + Vn * n3 - $n * e3) / (Wn + Vn - $n), o2 = r3 - i2, a2 = (Gn * (e3 - i2) - Hn * o2) / Xn, u2 = Math.sqrt(a2 * a2 + o2 * o2) / (Gn * i2 * (1 - i2)), c2 = u2 ? Math.atan2(a2, o2) * Nn - 120 : NaN;
            return new Qn(c2 < 0 ? c2 + 360 : c2, u2, i2, t3.opacity);
          }(t2) : new Qn(t2, n2, e2, null == r2 ? 1 : r2);
        }
        function Qn(t2, n2, e2, r2) {
          this.h = +t2, this.s = +n2, this.l = +e2, this.opacity = +r2;
        }
        function Jn(t2, n2, e2, r2, i2) {
          var o2 = t2 * t2, a2 = o2 * t2;
          return ((1 - 3 * t2 + 3 * o2 - a2) * n2 + (4 - 6 * o2 + 3 * a2) * e2 + (1 + 3 * t2 + 3 * o2 - 3 * a2) * r2 + a2 * i2) / 6;
        }
        function Kn(t2) {
          var n2 = t2.length - 1;
          return function(e2) {
            var r2 = e2 <= 0 ? e2 = 0 : e2 >= 1 ? (e2 = 1, n2 - 1) : Math.floor(e2 * n2), i2 = t2[r2], o2 = t2[r2 + 1], a2 = r2 > 0 ? t2[r2 - 1] : 2 * i2 - o2, u2 = r2 < n2 - 1 ? t2[r2 + 2] : 2 * o2 - i2;
            return Jn((e2 - r2 / n2) * n2, a2, i2, o2, u2);
          };
        }
        function te(t2) {
          var n2 = t2.length;
          return function(e2) {
            var r2 = Math.floor(((e2 %= 1) < 0 ? ++e2 : e2) * n2), i2 = t2[(r2 + n2 - 1) % n2], o2 = t2[r2 % n2], a2 = t2[(r2 + 1) % n2], u2 = t2[(r2 + 2) % n2];
            return Jn((e2 - r2 / n2) * n2, i2, o2, a2, u2);
          };
        }
        function ne(t2) {
          return function() {
            return t2;
          };
        }
        function ee(t2, n2) {
          return function(e2) {
            return t2 + e2 * n2;
          };
        }
        function re(t2, n2) {
          var e2 = n2 - t2;
          return e2 ? ee(t2, e2 > 180 || e2 < -180 ? e2 - 360 * Math.round(e2 / 360) : e2) : ne(isNaN(t2) ? n2 : t2);
        }
        function ie(t2) {
          return 1 == (t2 = +t2) ? oe : function(n2, e2) {
            return e2 - n2 ? function(t3, n3, e3) {
              return t3 = Math.pow(t3, e3), n3 = Math.pow(n3, e3) - t3, e3 = 1 / e3, function(r2) {
                return Math.pow(t3 + r2 * n3, e3);
              };
            }(n2, e2, t2) : ne(isNaN(n2) ? e2 : n2);
          };
        }
        function oe(t2, n2) {
          var e2 = n2 - t2;
          return e2 ? ee(t2, e2) : ne(isNaN(t2) ? n2 : t2);
        }
        Zt(Qn, Zn, Qt(Jt, { brighter: function(t2) {
          return t2 = null == t2 ? 1 / 0.7 : Math.pow(1 / 0.7, t2), new Qn(this.h, this.s, this.l * t2, this.opacity);
        }, darker: function(t2) {
          return t2 = null == t2 ? 0.7 : Math.pow(0.7, t2), new Qn(this.h, this.s, this.l * t2, this.opacity);
        }, rgb: function() {
          var t2 = isNaN(this.h) ? 0 : (this.h + 120) * Mn, n2 = +this.l, e2 = isNaN(this.s) ? 0 : this.s * n2 * (1 - n2), r2 = Math.cos(t2), i2 = Math.sin(t2);
          return new yn(255 * (n2 + e2 * (In * r2 + jn * i2)), 255 * (n2 + e2 * (Hn * r2 + Xn * i2)), 255 * (n2 + e2 * (Gn * r2)), this.opacity);
        } }));
        var ae = function t2(n2) {
          var e2 = ie(n2);
          function r2(t3, n3) {
            var r3 = e2((t3 = gn(t3)).r, (n3 = gn(n3)).r), i2 = e2(t3.g, n3.g), o2 = e2(t3.b, n3.b), a2 = oe(t3.opacity, n3.opacity);
            return function(n4) {
              return t3.r = r3(n4), t3.g = i2(n4), t3.b = o2(n4), t3.opacity = a2(n4), t3 + "";
            };
          }
          return r2.gamma = t2, r2;
        }(1);
        function ue(t2) {
          return function(n2) {
            var e2, r2, i2 = n2.length, o2 = new Array(i2), a2 = new Array(i2), u2 = new Array(i2);
            for (e2 = 0; e2 < i2; ++e2)
              r2 = gn(n2[e2]), o2[e2] = r2.r || 0, a2[e2] = r2.g || 0, u2[e2] = r2.b || 0;
            return o2 = t2(o2), a2 = t2(a2), u2 = t2(u2), r2.opacity = 1, function(t3) {
              return r2.r = o2(t3), r2.g = a2(t3), r2.b = u2(t3), r2 + "";
            };
          };
        }
        var ce = ue(Kn), fe = ue(te);
        function se(t2, n2) {
          var e2, r2 = n2 ? n2.length : 0, i2 = t2 ? Math.min(r2, t2.length) : 0, o2 = new Array(i2), a2 = new Array(r2);
          for (e2 = 0; e2 < i2; ++e2)
            o2[e2] = ye(t2[e2], n2[e2]);
          for (; e2 < r2; ++e2)
            a2[e2] = n2[e2];
          return function(t3) {
            for (e2 = 0; e2 < i2; ++e2)
              a2[e2] = o2[e2](t3);
            return a2;
          };
        }
        function le(t2, n2) {
          var e2 = /* @__PURE__ */ new Date();
          return n2 -= t2 = +t2, function(r2) {
            return e2.setTime(t2 + n2 * r2), e2;
          };
        }
        function he(t2, n2) {
          return n2 -= t2 = +t2, function(e2) {
            return t2 + n2 * e2;
          };
        }
        function de(t2, n2) {
          var e2, r2 = {}, i2 = {};
          for (e2 in null !== t2 && "object" == typeof t2 || (t2 = {}), null !== n2 && "object" == typeof n2 || (n2 = {}), n2)
            e2 in t2 ? r2[e2] = ye(t2[e2], n2[e2]) : i2[e2] = n2[e2];
          return function(t3) {
            for (e2 in r2)
              i2[e2] = r2[e2](t3);
            return i2;
          };
        }
        var pe = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, ve = new RegExp(pe.source, "g");
        function ge(t2, n2) {
          var e2, r2, i2, o2 = pe.lastIndex = ve.lastIndex = 0, a2 = -1, u2 = [], c2 = [];
          for (t2 += "", n2 += ""; (e2 = pe.exec(t2)) && (r2 = ve.exec(n2)); )
            (i2 = r2.index) > o2 && (i2 = n2.slice(o2, i2), u2[a2] ? u2[a2] += i2 : u2[++a2] = i2), (e2 = e2[0]) === (r2 = r2[0]) ? u2[a2] ? u2[a2] += r2 : u2[++a2] = r2 : (u2[++a2] = null, c2.push({ i: a2, x: he(e2, r2) })), o2 = ve.lastIndex;
          return o2 < n2.length && (i2 = n2.slice(o2), u2[a2] ? u2[a2] += i2 : u2[++a2] = i2), u2.length < 2 ? c2[0] ? function(t3) {
            return function(n3) {
              return t3(n3) + "";
            };
          }(c2[0].x) : function(t3) {
            return function() {
              return t3;
            };
          }(n2) : (n2 = c2.length, function(t3) {
            for (var e3, r3 = 0; r3 < n2; ++r3)
              u2[(e3 = c2[r3]).i] = e3.x(t3);
            return u2.join("");
          });
        }
        function ye(t2, n2) {
          var e2, r2 = typeof n2;
          return null == n2 || "boolean" === r2 ? ne(n2) : ("number" === r2 ? he : "string" === r2 ? (e2 = hn(n2)) ? (n2 = e2, ae) : ge : n2 instanceof hn ? ae : n2 instanceof Date ? le : Array.isArray(n2) ? se : "function" != typeof n2.valueOf && "function" != typeof n2.toString || isNaN(n2) ? de : he)(t2, n2);
        }
        function _e(t2, n2) {
          return n2 -= t2 = +t2, function(e2) {
            return Math.round(t2 + n2 * e2);
          };
        }
        var be, me, xe, we, Me = 180 / Math.PI, Ne = { translateX: 0, translateY: 0, rotate: 0, skewX: 0, scaleX: 1, scaleY: 1 };
        function Ae(t2, n2, e2, r2, i2, o2) {
          var a2, u2, c2;
          return (a2 = Math.sqrt(t2 * t2 + n2 * n2)) && (t2 /= a2, n2 /= a2), (c2 = t2 * e2 + n2 * r2) && (e2 -= t2 * c2, r2 -= n2 * c2), (u2 = Math.sqrt(e2 * e2 + r2 * r2)) && (e2 /= u2, r2 /= u2, c2 /= u2), t2 * r2 < n2 * e2 && (t2 = -t2, n2 = -n2, c2 = -c2, a2 = -a2), { translateX: i2, translateY: o2, rotate: Math.atan2(n2, t2) * Me, skewX: Math.atan(c2) * Me, scaleX: a2, scaleY: u2 };
        }
        function Te(t2, n2, e2, r2) {
          function i2(t3) {
            return t3.length ? t3.pop() + " " : "";
          }
          return function(o2, a2) {
            var u2 = [], c2 = [];
            return o2 = t2(o2), a2 = t2(a2), function(t3, r3, i3, o3, a3, u3) {
              if (t3 !== i3 || r3 !== o3) {
                var c3 = a3.push("translate(", null, n2, null, e2);
                u3.push({ i: c3 - 4, x: he(t3, i3) }, { i: c3 - 2, x: he(r3, o3) });
              } else
                (i3 || o3) && a3.push("translate(" + i3 + n2 + o3 + e2);
            }(o2.translateX, o2.translateY, a2.translateX, a2.translateY, u2, c2), function(t3, n3, e3, o3) {
              t3 !== n3 ? (t3 - n3 > 180 ? n3 += 360 : n3 - t3 > 180 && (t3 += 360), o3.push({ i: e3.push(i2(e3) + "rotate(", null, r2) - 2, x: he(t3, n3) })) : n3 && e3.push(i2(e3) + "rotate(" + n3 + r2);
            }(o2.rotate, a2.rotate, u2, c2), function(t3, n3, e3, o3) {
              t3 !== n3 ? o3.push({ i: e3.push(i2(e3) + "skewX(", null, r2) - 2, x: he(t3, n3) }) : n3 && e3.push(i2(e3) + "skewX(" + n3 + r2);
            }(o2.skewX, a2.skewX, u2, c2), function(t3, n3, e3, r3, o3, a3) {
              if (t3 !== e3 || n3 !== r3) {
                var u3 = o3.push(i2(o3) + "scale(", null, ",", null, ")");
                a3.push({ i: u3 - 4, x: he(t3, e3) }, { i: u3 - 2, x: he(n3, r3) });
              } else
                1 === e3 && 1 === r3 || o3.push(i2(o3) + "scale(" + e3 + "," + r3 + ")");
            }(o2.scaleX, o2.scaleY, a2.scaleX, a2.scaleY, u2, c2), o2 = a2 = null, function(t3) {
              for (var n3, e3 = -1, r3 = c2.length; ++e3 < r3; )
                u2[(n3 = c2[e3]).i] = n3.x(t3);
              return u2.join("");
            };
          };
        }
        var Se = Te(function(t2) {
          return "none" === t2 ? Ne : (be || (be = document.createElement("DIV"), me = document.documentElement, xe = document.defaultView), be.style.transform = t2, t2 = xe.getComputedStyle(me.appendChild(be), null).getPropertyValue("transform"), me.removeChild(be), Ae(+(t2 = t2.slice(7, -1).split(","))[0], +t2[1], +t2[2], +t2[3], +t2[4], +t2[5]));
        }, "px, ", "px)", "deg)"), ke = Te(function(t2) {
          return null == t2 ? Ne : (we || (we = document.createElementNS("http://www.w3.org/2000/svg", "g")), we.setAttribute("transform", t2), (t2 = we.transform.baseVal.consolidate()) ? Ae((t2 = t2.matrix).a, t2.b, t2.c, t2.d, t2.e, t2.f) : Ne);
        }, ", ", ")", ")"), Ee = Math.SQRT2, Ce = 2, Pe = 4, ze = 1e-12;
        function Re(t2) {
          return ((t2 = Math.exp(t2)) + 1 / t2) / 2;
        }
        function De(t2, n2) {
          var e2, r2, i2 = t2[0], o2 = t2[1], a2 = t2[2], u2 = n2[0], c2 = n2[1], f2 = n2[2], s2 = u2 - i2, l2 = c2 - o2, h2 = s2 * s2 + l2 * l2;
          if (h2 < ze)
            r2 = Math.log(f2 / a2) / Ee, e2 = function(t3) {
              return [i2 + t3 * s2, o2 + t3 * l2, a2 * Math.exp(Ee * t3 * r2)];
            };
          else {
            var d2 = Math.sqrt(h2), p2 = (f2 * f2 - a2 * a2 + Pe * h2) / (2 * a2 * Ce * d2), v2 = (f2 * f2 - a2 * a2 - Pe * h2) / (2 * f2 * Ce * d2), g2 = Math.log(Math.sqrt(p2 * p2 + 1) - p2), y2 = Math.log(Math.sqrt(v2 * v2 + 1) - v2);
            r2 = (y2 - g2) / Ee, e2 = function(t3) {
              var n3, e3 = t3 * r2, u3 = Re(g2), c3 = a2 / (Ce * d2) * (u3 * (n3 = Ee * e3 + g2, ((n3 = Math.exp(2 * n3)) - 1) / (n3 + 1)) - function(t4) {
                return ((t4 = Math.exp(t4)) - 1 / t4) / 2;
              }(g2));
              return [i2 + c3 * s2, o2 + c3 * l2, a2 * u3 / Re(Ee * e3 + g2)];
            };
          }
          return e2.duration = 1e3 * r2, e2;
        }
        function qe(t2) {
          return function(n2, e2) {
            var r2 = t2((n2 = mn(n2)).h, (e2 = mn(e2)).h), i2 = oe(n2.s, e2.s), o2 = oe(n2.l, e2.l), a2 = oe(n2.opacity, e2.opacity);
            return function(t3) {
              return n2.h = r2(t3), n2.s = i2(t3), n2.l = o2(t3), n2.opacity = a2(t3), n2 + "";
            };
          };
        }
        var Le = qe(re), Ue = qe(oe);
        function Oe(t2) {
          return function(n2, e2) {
            var r2 = t2((n2 = Yn(n2)).h, (e2 = Yn(e2)).h), i2 = oe(n2.c, e2.c), o2 = oe(n2.l, e2.l), a2 = oe(n2.opacity, e2.opacity);
            return function(t3) {
              return n2.h = r2(t3), n2.c = i2(t3), n2.l = o2(t3), n2.opacity = a2(t3), n2 + "";
            };
          };
        }
        var Be = Oe(re), Ye = Oe(oe);
        function Fe(t2) {
          return function n2(e2) {
            function r2(n3, r3) {
              var i2 = t2((n3 = Zn(n3)).h, (r3 = Zn(r3)).h), o2 = oe(n3.s, r3.s), a2 = oe(n3.l, r3.l), u2 = oe(n3.opacity, r3.opacity);
              return function(t3) {
                return n3.h = i2(t3), n3.s = o2(t3), n3.l = a2(Math.pow(t3, e2)), n3.opacity = u2(t3), n3 + "";
              };
            }
            return e2 = +e2, r2.gamma = n2, r2;
          }(1);
        }
        var Ie = Fe(re), je = Fe(oe);
        var He, Xe, Ge = 0, Ve = 0, $e = 0, We = 1e3, Ze = 0, Qe = 0, Je = 0, Ke = "object" == typeof performance && performance.now ? performance : Date, tr = "object" == typeof window && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(t2) {
          window.setTimeout(t2, 17);
        };
        function nr() {
          return Qe || (tr(er), Qe = Ke.now() + Je);
        }
        function er() {
          Qe = 0;
        }
        function rr() {
          this._call = this._time = this._next = null;
        }
        function ir(t2, n2, e2) {
          var r2 = new rr();
          return r2.restart(t2, n2, e2), r2;
        }
        function or() {
          nr(), ++Ge;
          for (var t2, n2 = He; n2; )
            (t2 = Qe - n2._time) >= 0 && n2._call.call(null, t2), n2 = n2._next;
          --Ge;
        }
        function ar() {
          Qe = (Ze = Ke.now()) + Je, Ge = Ve = 0;
          try {
            or();
          } finally {
            Ge = 0, function() {
              var t2, n2, e2 = He, r2 = 1 / 0;
              for (; e2; )
                e2._call ? (r2 > e2._time && (r2 = e2._time), t2 = e2, e2 = e2._next) : (n2 = e2._next, e2._next = null, e2 = t2 ? t2._next = n2 : He = n2);
              Xe = t2, cr(r2);
            }(), Qe = 0;
          }
        }
        function ur() {
          var t2 = Ke.now(), n2 = t2 - Ze;
          n2 > We && (Je -= n2, Ze = t2);
        }
        function cr(t2) {
          Ge || (Ve && (Ve = window.clearTimeout(Ve)), t2 - Qe > 24 ? (t2 < 1 / 0 && (Ve = window.setTimeout(ar, t2 - Ke.now() - Je)), $e && ($e = window.clearInterval($e))) : ($e || (Ze = Ke.now(), $e = window.setInterval(ur, We)), Ge = 1, tr(ar)));
        }
        function fr(t2, n2, e2) {
          var r2 = new rr();
          return n2 = null == n2 ? 0 : +n2, r2.restart(function(e3) {
            r2.stop(), t2(e3 + n2);
          }, n2, e2), r2;
        }
        rr.prototype = ir.prototype = { constructor: rr, restart: function(t2, n2, e2) {
          if ("function" != typeof t2)
            throw new TypeError("callback is not a function");
          e2 = (null == e2 ? nr() : +e2) + (null == n2 ? 0 : +n2), this._next || Xe === this || (Xe ? Xe._next = this : He = this, Xe = this), this._call = t2, this._time = e2, cr();
        }, stop: function() {
          this._call && (this._call = null, this._time = 1 / 0, cr());
        } };
        var sr = I("start", "end", "cancel", "interrupt"), lr = [], hr = 0, dr = 1, pr = 2, vr = 3, gr = 4, yr = 5, _r = 6;
        function br(t2, n2, e2, r2, i2, o2) {
          var a2 = t2.__transition;
          if (a2) {
            if (e2 in a2)
              return;
          } else
            t2.__transition = {};
          !function(t3, n3, e3) {
            var r3, i3 = t3.__transition;
            function o3(c2) {
              var f2, s2, l2, h2;
              if (e3.state !== dr)
                return u2();
              for (f2 in i3)
                if ((h2 = i3[f2]).name === e3.name) {
                  if (h2.state === vr)
                    return fr(o3);
                  h2.state === gr ? (h2.state = _r, h2.timer.stop(), h2.on.call("interrupt", t3, t3.__data__, h2.index, h2.group), delete i3[f2]) : +f2 < n3 && (h2.state = _r, h2.timer.stop(), h2.on.call("cancel", t3, t3.__data__, h2.index, h2.group), delete i3[f2]);
                }
              if (fr(function() {
                e3.state === vr && (e3.state = gr, e3.timer.restart(a3, e3.delay, e3.time), a3(c2));
              }), e3.state = pr, e3.on.call("start", t3, t3.__data__, e3.index, e3.group), e3.state === pr) {
                for (e3.state = vr, r3 = new Array(l2 = e3.tween.length), f2 = 0, s2 = -1; f2 < l2; ++f2)
                  (h2 = e3.tween[f2].value.call(t3, t3.__data__, e3.index, e3.group)) && (r3[++s2] = h2);
                r3.length = s2 + 1;
              }
            }
            function a3(n4) {
              for (var i4 = n4 < e3.duration ? e3.ease.call(null, n4 / e3.duration) : (e3.timer.restart(u2), e3.state = yr, 1), o4 = -1, a4 = r3.length; ++o4 < a4; )
                r3[o4].call(t3, i4);
              e3.state === yr && (e3.on.call("end", t3, t3.__data__, e3.index, e3.group), u2());
            }
            function u2() {
              for (var r4 in e3.state = _r, e3.timer.stop(), delete i3[n3], i3)
                return;
              delete t3.__transition;
            }
            i3[n3] = e3, e3.timer = ir(function(t4) {
              e3.state = dr, e3.timer.restart(o3, e3.delay, e3.time), e3.delay <= t4 && o3(t4 - e3.delay);
            }, 0, e3.time);
          }(t2, e2, { name: n2, index: r2, group: i2, on: sr, tween: lr, time: o2.time, delay: o2.delay, duration: o2.duration, ease: o2.ease, timer: null, state: hr });
        }
        function mr(t2, n2) {
          var e2 = wr(t2, n2);
          if (e2.state > hr)
            throw new Error("too late; already scheduled");
          return e2;
        }
        function xr(t2, n2) {
          var e2 = wr(t2, n2);
          if (e2.state > vr)
            throw new Error("too late; already running");
          return e2;
        }
        function wr(t2, n2) {
          var e2 = t2.__transition;
          if (!e2 || !(e2 = e2[n2]))
            throw new Error("transition not found");
          return e2;
        }
        function Mr(t2, n2) {
          var e2, r2, i2, o2 = t2.__transition, a2 = true;
          if (o2) {
            for (i2 in n2 = null == n2 ? null : n2 + "", o2)
              (e2 = o2[i2]).name === n2 ? (r2 = e2.state > pr && e2.state < yr, e2.state = _r, e2.timer.stop(), e2.on.call(r2 ? "interrupt" : "cancel", t2, t2.__data__, e2.index, e2.group), delete o2[i2]) : a2 = false;
            a2 && delete t2.__transition;
          }
        }
        function Nr(t2, n2, e2) {
          var r2 = t2._id;
          return t2.each(function() {
            var t3 = xr(this, r2);
            (t3.value || (t3.value = {}))[n2] = e2.apply(this, arguments);
          }), function(t3) {
            return wr(t3, r2).value[n2];
          };
        }
        function Ar(t2, n2) {
          var e2;
          return ("number" == typeof n2 ? he : n2 instanceof hn ? ae : (e2 = hn(n2)) ? (n2 = e2, ae) : ge)(t2, n2);
        }
        var Tr = Pt.prototype.constructor;
        function Sr(t2) {
          return function() {
            this.style.removeProperty(t2);
          };
        }
        var kr = 0;
        function Er(t2, n2, e2, r2) {
          this._groups = t2, this._parents = n2, this._name = e2, this._id = r2;
        }
        function Cr(t2) {
          return Pt().transition(t2);
        }
        function Pr() {
          return ++kr;
        }
        var zr = Pt.prototype;
        function Rr(t2) {
          return ((t2 *= 2) <= 1 ? t2 * t2 : --t2 * (2 - t2) + 1) / 2;
        }
        function Dr(t2) {
          return ((t2 *= 2) <= 1 ? t2 * t2 * t2 : (t2 -= 2) * t2 * t2 + 2) / 2;
        }
        Er.prototype = Cr.prototype = { constructor: Er, select: function(t2) {
          var n2 = this._name, e2 = this._id;
          "function" != typeof t2 && (t2 = Q(t2));
          for (var r2 = this._groups, i2 = r2.length, o2 = new Array(i2), a2 = 0; a2 < i2; ++a2)
            for (var u2, c2, f2 = r2[a2], s2 = f2.length, l2 = o2[a2] = new Array(s2), h2 = 0; h2 < s2; ++h2)
              (u2 = f2[h2]) && (c2 = t2.call(u2, u2.__data__, h2, f2)) && ("__data__" in u2 && (c2.__data__ = u2.__data__), l2[h2] = c2, br(l2[h2], n2, e2, h2, l2, wr(u2, e2)));
          return new Er(o2, this._parents, n2, e2);
        }, selectAll: function(t2) {
          var n2 = this._name, e2 = this._id;
          "function" != typeof t2 && (t2 = K(t2));
          for (var r2 = this._groups, i2 = r2.length, o2 = [], a2 = [], u2 = 0; u2 < i2; ++u2)
            for (var c2, f2 = r2[u2], s2 = f2.length, l2 = 0; l2 < s2; ++l2)
              if (c2 = f2[l2]) {
                for (var h2, d2 = t2.call(c2, c2.__data__, l2, f2), p2 = wr(c2, e2), v2 = 0, g2 = d2.length; v2 < g2; ++v2)
                  (h2 = d2[v2]) && br(h2, n2, e2, v2, d2, p2);
                o2.push(d2), a2.push(c2);
              }
          return new Er(o2, a2, n2, e2);
        }, filter: function(t2) {
          "function" != typeof t2 && (t2 = tt(t2));
          for (var n2 = this._groups, e2 = n2.length, r2 = new Array(e2), i2 = 0; i2 < e2; ++i2)
            for (var o2, a2 = n2[i2], u2 = a2.length, c2 = r2[i2] = [], f2 = 0; f2 < u2; ++f2)
              (o2 = a2[f2]) && t2.call(o2, o2.__data__, f2, a2) && c2.push(o2);
          return new Er(r2, this._parents, this._name, this._id);
        }, merge: function(t2) {
          if (t2._id !== this._id)
            throw new Error();
          for (var n2 = this._groups, e2 = t2._groups, r2 = n2.length, i2 = e2.length, o2 = Math.min(r2, i2), a2 = new Array(r2), u2 = 0; u2 < o2; ++u2)
            for (var c2, f2 = n2[u2], s2 = e2[u2], l2 = f2.length, h2 = a2[u2] = new Array(l2), d2 = 0; d2 < l2; ++d2)
              (c2 = f2[d2] || s2[d2]) && (h2[d2] = c2);
          for (; u2 < r2; ++u2)
            a2[u2] = n2[u2];
          return new Er(a2, this._parents, this._name, this._id);
        }, selection: function() {
          return new Tr(this._groups, this._parents);
        }, transition: function() {
          for (var t2 = this._name, n2 = this._id, e2 = Pr(), r2 = this._groups, i2 = r2.length, o2 = 0; o2 < i2; ++o2)
            for (var a2, u2 = r2[o2], c2 = u2.length, f2 = 0; f2 < c2; ++f2)
              if (a2 = u2[f2]) {
                var s2 = wr(a2, n2);
                br(a2, t2, e2, f2, u2, { time: s2.time + s2.delay + s2.duration, delay: 0, duration: s2.duration, ease: s2.ease });
              }
          return new Er(r2, this._parents, t2, e2);
        }, call: zr.call, nodes: zr.nodes, node: zr.node, size: zr.size, empty: zr.empty, each: zr.each, on: function(t2, n2) {
          var e2 = this._id;
          return arguments.length < 2 ? wr(this.node(), e2).on.on(t2) : this.each(function(t3, n3, e3) {
            var r2, i2, o2 = function(t4) {
              return (t4 + "").trim().split(/^|\s+/).every(function(t5) {
                var n4 = t5.indexOf(".");
                return n4 >= 0 && (t5 = t5.slice(0, n4)), !t5 || "start" === t5;
              });
            }(n3) ? mr : xr;
            return function() {
              var a2 = o2(this, t3), u2 = a2.on;
              u2 !== r2 && (i2 = (r2 = u2).copy()).on(n3, e3), a2.on = i2;
            };
          }(e2, t2, n2));
        }, attr: function(t2, n2) {
          var e2 = $(t2), r2 = "transform" === e2 ? ke : Ar;
          return this.attrTween(t2, "function" == typeof n2 ? (e2.local ? function(t3, n3, e3) {
            var r3, i2, o2;
            return function() {
              var a2, u2, c2 = e3(this);
              if (null != c2)
                return (a2 = this.getAttributeNS(t3.space, t3.local)) === (u2 = c2 + "") ? null : a2 === r3 && u2 === i2 ? o2 : (i2 = u2, o2 = n3(r3 = a2, c2));
              this.removeAttributeNS(t3.space, t3.local);
            };
          } : function(t3, n3, e3) {
            var r3, i2, o2;
            return function() {
              var a2, u2, c2 = e3(this);
              if (null != c2)
                return (a2 = this.getAttribute(t3)) === (u2 = c2 + "") ? null : a2 === r3 && u2 === i2 ? o2 : (i2 = u2, o2 = n3(r3 = a2, c2));
              this.removeAttribute(t3);
            };
          })(e2, r2, Nr(this, "attr." + t2, n2)) : null == n2 ? (e2.local ? function(t3) {
            return function() {
              this.removeAttributeNS(t3.space, t3.local);
            };
          } : function(t3) {
            return function() {
              this.removeAttribute(t3);
            };
          })(e2) : (e2.local ? function(t3, n3, e3) {
            var r3, i2, o2 = e3 + "";
            return function() {
              var a2 = this.getAttributeNS(t3.space, t3.local);
              return a2 === o2 ? null : a2 === r3 ? i2 : i2 = n3(r3 = a2, e3);
            };
          } : function(t3, n3, e3) {
            var r3, i2, o2 = e3 + "";
            return function() {
              var a2 = this.getAttribute(t3);
              return a2 === o2 ? null : a2 === r3 ? i2 : i2 = n3(r3 = a2, e3);
            };
          })(e2, r2, n2));
        }, attrTween: function(t2, n2) {
          var e2 = "attr." + t2;
          if (arguments.length < 2)
            return (e2 = this.tween(e2)) && e2._value;
          if (null == n2)
            return this.tween(e2, null);
          if ("function" != typeof n2)
            throw new Error();
          var r2 = $(t2);
          return this.tween(e2, (r2.local ? function(t3, n3) {
            var e3, r3;
            function i2() {
              var i3 = n3.apply(this, arguments);
              return i3 !== r3 && (e3 = (r3 = i3) && function(t4, n4) {
                return function(e4) {
                  this.setAttributeNS(t4.space, t4.local, n4(e4));
                };
              }(t3, i3)), e3;
            }
            return i2._value = n3, i2;
          } : function(t3, n3) {
            var e3, r3;
            function i2() {
              var i3 = n3.apply(this, arguments);
              return i3 !== r3 && (e3 = (r3 = i3) && function(t4, n4) {
                return function(e4) {
                  this.setAttribute(t4, n4(e4));
                };
              }(t3, i3)), e3;
            }
            return i2._value = n3, i2;
          })(r2, n2));
        }, style: function(t2, n2, e2) {
          var r2 = "transform" == (t2 += "") ? Se : Ar;
          return null == n2 ? this.styleTween(t2, function(t3, n3) {
            var e3, r3, i2;
            return function() {
              var o2 = ct(this, t3), a2 = (this.style.removeProperty(t3), ct(this, t3));
              return o2 === a2 ? null : o2 === e3 && a2 === r3 ? i2 : i2 = n3(e3 = o2, r3 = a2);
            };
          }(t2, r2)).on("end.style." + t2, Sr(t2)) : "function" == typeof n2 ? this.styleTween(t2, function(t3, n3, e3) {
            var r3, i2, o2;
            return function() {
              var a2 = ct(this, t3), u2 = e3(this), c2 = u2 + "";
              return null == u2 && (this.style.removeProperty(t3), c2 = u2 = ct(this, t3)), a2 === c2 ? null : a2 === r3 && c2 === i2 ? o2 : (i2 = c2, o2 = n3(r3 = a2, u2));
            };
          }(t2, r2, Nr(this, "style." + t2, n2))).each(function(t3, n3) {
            var e3, r3, i2, o2, a2 = "style." + n3, u2 = "end." + a2;
            return function() {
              var c2 = xr(this, t3), f2 = c2.on, s2 = null == c2.value[a2] ? o2 || (o2 = Sr(n3)) : void 0;
              f2 === e3 && i2 === s2 || (r3 = (e3 = f2).copy()).on(u2, i2 = s2), c2.on = r3;
            };
          }(this._id, t2)) : this.styleTween(t2, function(t3, n3, e3) {
            var r3, i2, o2 = e3 + "";
            return function() {
              var a2 = ct(this, t3);
              return a2 === o2 ? null : a2 === r3 ? i2 : i2 = n3(r3 = a2, e3);
            };
          }(t2, r2, n2), e2).on("end.style." + t2, null);
        }, styleTween: function(t2, n2, e2) {
          var r2 = "style." + (t2 += "");
          if (arguments.length < 2)
            return (r2 = this.tween(r2)) && r2._value;
          if (null == n2)
            return this.tween(r2, null);
          if ("function" != typeof n2)
            throw new Error();
          return this.tween(r2, function(t3, n3, e3) {
            var r3, i2;
            function o2() {
              var o3 = n3.apply(this, arguments);
              return o3 !== i2 && (r3 = (i2 = o3) && function(t4, n4, e4) {
                return function(r4) {
                  this.style.setProperty(t4, n4(r4), e4);
                };
              }(t3, o3, e3)), r3;
            }
            return o2._value = n3, o2;
          }(t2, n2, null == e2 ? "" : e2));
        }, text: function(t2) {
          return this.tween("text", "function" == typeof t2 ? function(t3) {
            return function() {
              var n2 = t3(this);
              this.textContent = null == n2 ? "" : n2;
            };
          }(Nr(this, "text", t2)) : function(t3) {
            return function() {
              this.textContent = t3;
            };
          }(null == t2 ? "" : t2 + ""));
        }, remove: function() {
          return this.on("end.remove", (t2 = this._id, function() {
            var n2 = this.parentNode;
            for (var e2 in this.__transition)
              if (+e2 !== t2)
                return;
            n2 && n2.removeChild(this);
          }));
          var t2;
        }, tween: function(t2, n2) {
          var e2 = this._id;
          if (t2 += "", arguments.length < 2) {
            for (var r2, i2 = wr(this.node(), e2).tween, o2 = 0, a2 = i2.length; o2 < a2; ++o2)
              if ((r2 = i2[o2]).name === t2)
                return r2.value;
            return null;
          }
          return this.each((null == n2 ? function(t3, n3) {
            var e3, r3;
            return function() {
              var i3 = xr(this, t3), o3 = i3.tween;
              if (o3 !== e3) {
                for (var a3 = 0, u2 = (r3 = e3 = o3).length; a3 < u2; ++a3)
                  if (r3[a3].name === n3) {
                    (r3 = r3.slice()).splice(a3, 1);
                    break;
                  }
              }
              i3.tween = r3;
            };
          } : function(t3, n3, e3) {
            var r3, i3;
            if ("function" != typeof e3)
              throw new Error();
            return function() {
              var o3 = xr(this, t3), a3 = o3.tween;
              if (a3 !== r3) {
                i3 = (r3 = a3).slice();
                for (var u2 = { name: n3, value: e3 }, c2 = 0, f2 = i3.length; c2 < f2; ++c2)
                  if (i3[c2].name === n3) {
                    i3[c2] = u2;
                    break;
                  }
                c2 === f2 && i3.push(u2);
              }
              o3.tween = i3;
            };
          })(e2, t2, n2));
        }, delay: function(t2) {
          var n2 = this._id;
          return arguments.length ? this.each(("function" == typeof t2 ? function(t3, n3) {
            return function() {
              mr(this, t3).delay = +n3.apply(this, arguments);
            };
          } : function(t3, n3) {
            return n3 = +n3, function() {
              mr(this, t3).delay = n3;
            };
          })(n2, t2)) : wr(this.node(), n2).delay;
        }, duration: function(t2) {
          var n2 = this._id;
          return arguments.length ? this.each(("function" == typeof t2 ? function(t3, n3) {
            return function() {
              xr(this, t3).duration = +n3.apply(this, arguments);
            };
          } : function(t3, n3) {
            return n3 = +n3, function() {
              xr(this, t3).duration = n3;
            };
          })(n2, t2)) : wr(this.node(), n2).duration;
        }, ease: function(t2) {
          var n2 = this._id;
          return arguments.length ? this.each(function(t3, n3) {
            if ("function" != typeof n3)
              throw new Error();
            return function() {
              xr(this, t3).ease = n3;
            };
          }(n2, t2)) : wr(this.node(), n2).ease;
        }, end: function() {
          var t2, n2, e2 = this, r2 = e2._id, i2 = e2.size();
          return new Promise(function(o2, a2) {
            var u2 = { value: a2 }, c2 = { value: function() {
              0 == --i2 && o2();
            } };
            e2.each(function() {
              var e3 = xr(this, r2), i3 = e3.on;
              i3 !== t2 && ((n2 = (t2 = i3).copy())._.cancel.push(u2), n2._.interrupt.push(u2), n2._.end.push(c2)), e3.on = n2;
            });
          });
        } };
        var qr = function t2(n2) {
          function e2(t3) {
            return Math.pow(t3, n2);
          }
          return n2 = +n2, e2.exponent = t2, e2;
        }(3), Lr = function t2(n2) {
          function e2(t3) {
            return 1 - Math.pow(1 - t3, n2);
          }
          return n2 = +n2, e2.exponent = t2, e2;
        }(3), Ur = function t2(n2) {
          function e2(t3) {
            return ((t3 *= 2) <= 1 ? Math.pow(t3, n2) : 2 - Math.pow(2 - t3, n2)) / 2;
          }
          return n2 = +n2, e2.exponent = t2, e2;
        }(3), Or = Math.PI, Br = Or / 2;
        function Yr(t2) {
          return (1 - Math.cos(Or * t2)) / 2;
        }
        function Fr(t2) {
          return ((t2 *= 2) <= 1 ? Math.pow(2, 10 * t2 - 10) : 2 - Math.pow(2, 10 - 10 * t2)) / 2;
        }
        function Ir(t2) {
          return ((t2 *= 2) <= 1 ? 1 - Math.sqrt(1 - t2 * t2) : Math.sqrt(1 - (t2 -= 2) * t2) + 1) / 2;
        }
        var jr = 4 / 11, Hr = 6 / 11, Xr = 8 / 11, Gr = 0.75, Vr = 9 / 11, $r = 10 / 11, Wr = 0.9375, Zr = 21 / 22, Qr = 63 / 64, Jr = 1 / jr / jr;
        function Kr(t2) {
          return (t2 = +t2) < jr ? Jr * t2 * t2 : t2 < Xr ? Jr * (t2 -= Hr) * t2 + Gr : t2 < $r ? Jr * (t2 -= Vr) * t2 + Wr : Jr * (t2 -= Zr) * t2 + Qr;
        }
        var ti = function t2(n2) {
          function e2(t3) {
            return t3 * t3 * ((n2 + 1) * t3 - n2);
          }
          return n2 = +n2, e2.overshoot = t2, e2;
        }(1.70158), ni = function t2(n2) {
          function e2(t3) {
            return --t3 * t3 * ((n2 + 1) * t3 + n2) + 1;
          }
          return n2 = +n2, e2.overshoot = t2, e2;
        }(1.70158), ei = function t2(n2) {
          function e2(t3) {
            return ((t3 *= 2) < 1 ? t3 * t3 * ((n2 + 1) * t3 - n2) : (t3 -= 2) * t3 * ((n2 + 1) * t3 + n2) + 2) / 2;
          }
          return n2 = +n2, e2.overshoot = t2, e2;
        }(1.70158), ri = 2 * Math.PI, ii = function t2(n2, e2) {
          var r2 = Math.asin(1 / (n2 = Math.max(1, n2))) * (e2 /= ri);
          function i2(t3) {
            return n2 * Math.pow(2, 10 * --t3) * Math.sin((r2 - t3) / e2);
          }
          return i2.amplitude = function(n3) {
            return t2(n3, e2 * ri);
          }, i2.period = function(e3) {
            return t2(n2, e3);
          }, i2;
        }(1, 0.3), oi = function t2(n2, e2) {
          var r2 = Math.asin(1 / (n2 = Math.max(1, n2))) * (e2 /= ri);
          function i2(t3) {
            return 1 - n2 * Math.pow(2, -10 * (t3 = +t3)) * Math.sin((t3 + r2) / e2);
          }
          return i2.amplitude = function(n3) {
            return t2(n3, e2 * ri);
          }, i2.period = function(e3) {
            return t2(n2, e3);
          }, i2;
        }(1, 0.3), ai = function t2(n2, e2) {
          var r2 = Math.asin(1 / (n2 = Math.max(1, n2))) * (e2 /= ri);
          function i2(t3) {
            return ((t3 = 2 * t3 - 1) < 0 ? n2 * Math.pow(2, 10 * t3) * Math.sin((r2 - t3) / e2) : 2 - n2 * Math.pow(2, -10 * t3) * Math.sin((r2 + t3) / e2)) / 2;
          }
          return i2.amplitude = function(n3) {
            return t2(n3, e2 * ri);
          }, i2.period = function(e3) {
            return t2(n2, e3);
          }, i2;
        }(1, 0.3), ui = { time: null, delay: 0, duration: 250, ease: Dr };
        function ci(t2, n2) {
          for (var e2; !(e2 = t2.__transition) || !(e2 = e2[n2]); )
            if (!(t2 = t2.parentNode))
              return ui.time = nr(), ui;
          return e2;
        }
        Pt.prototype.interrupt = function(t2) {
          return this.each(function() {
            Mr(this, t2);
          });
        }, Pt.prototype.transition = function(t2) {
          var n2, e2;
          t2 instanceof Er ? (n2 = t2._id, t2 = t2._name) : (n2 = Pr(), (e2 = ui).time = nr(), t2 = null == t2 ? null : t2 + "");
          for (var r2 = this._groups, i2 = r2.length, o2 = 0; o2 < i2; ++o2)
            for (var a2, u2 = r2[o2], c2 = u2.length, f2 = 0; f2 < c2; ++f2)
              (a2 = u2[f2]) && br(a2, t2, n2, f2, u2, e2 || ci(a2, n2));
          return new Er(r2, this._parents, t2, n2);
        };
        var fi = [null];
        function si(t2) {
          return function() {
            return t2;
          };
        }
        function li(t2, n2, e2) {
          this.target = t2, this.type = n2, this.selection = e2;
        }
        function hi() {
          t.event.stopImmediatePropagation();
        }
        function di() {
          t.event.preventDefault(), t.event.stopImmediatePropagation();
        }
        var pi = { name: "drag" }, vi = { name: "space" }, gi = { name: "handle" }, yi = { name: "center" }, _i = { name: "x", handles: ["e", "w"].map(Ti), input: function(t2, n2) {
          return t2 && [[t2[0], n2[0][1]], [t2[1], n2[1][1]]];
        }, output: function(t2) {
          return t2 && [t2[0][0], t2[1][0]];
        } }, bi = { name: "y", handles: ["n", "s"].map(Ti), input: function(t2, n2) {
          return t2 && [[n2[0][0], t2[0]], [n2[1][0], t2[1]]];
        }, output: function(t2) {
          return t2 && [t2[0][1], t2[1][1]];
        } }, mi = { name: "xy", handles: ["n", "e", "s", "w", "nw", "ne", "se", "sw"].map(Ti), input: function(t2) {
          return t2;
        }, output: function(t2) {
          return t2;
        } }, xi = { overlay: "crosshair", selection: "move", n: "ns-resize", e: "ew-resize", s: "ns-resize", w: "ew-resize", nw: "nwse-resize", ne: "nesw-resize", se: "nwse-resize", sw: "nesw-resize" }, wi = { e: "w", w: "e", nw: "ne", ne: "nw", se: "sw", sw: "se" }, Mi = { n: "s", s: "n", nw: "sw", ne: "se", se: "ne", sw: "nw" }, Ni = { overlay: 1, selection: 1, n: null, e: 1, s: null, w: -1, nw: -1, ne: 1, se: 1, sw: -1 }, Ai = { overlay: 1, selection: 1, n: -1, e: null, s: 1, w: null, nw: -1, ne: -1, se: 1, sw: 1 };
        function Ti(t2) {
          return { type: t2 };
        }
        function Si() {
          return !t.event.button;
        }
        function ki() {
          var t2 = this.ownerSVGElement || this;
          return [[0, 0], [t2.width.baseVal.value, t2.height.baseVal.value]];
        }
        function Ei(t2) {
          for (; !t2.__brush; )
            if (!(t2 = t2.parentNode))
              return;
          return t2.__brush;
        }
        function Ci(t2) {
          return t2[0][0] === t2[1][0] || t2[0][1] === t2[1][1];
        }
        function Pi(n2) {
          var e2, r2 = ki, i2 = Si, o2 = I(u2, "start", "brush", "end"), a2 = 6;
          function u2(t2) {
            var e3 = t2.property("__brush", h2).selectAll(".overlay").data([Ti("overlay")]);
            e3.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", xi.overlay).merge(e3).each(function() {
              var t3 = Ei(this).extent;
              zt(this).attr("x", t3[0][0]).attr("y", t3[0][1]).attr("width", t3[1][0] - t3[0][0]).attr("height", t3[1][1] - t3[0][1]);
            }), t2.selectAll(".selection").data([Ti("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", xi.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
            var r3 = t2.selectAll(".handle").data(n2.handles, function(t3) {
              return t3.type;
            });
            r3.exit().remove(), r3.enter().append("rect").attr("class", function(t3) {
              return "handle handle--" + t3.type;
            }).attr("cursor", function(t3) {
              return xi[t3.type];
            }), t2.each(c2).attr("fill", "none").attr("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush touchstart.brush", l2);
          }
          function c2() {
            var t2 = zt(this), n3 = Ei(this).selection;
            n3 ? (t2.selectAll(".selection").style("display", null).attr("x", n3[0][0]).attr("y", n3[0][1]).attr("width", n3[1][0] - n3[0][0]).attr("height", n3[1][1] - n3[0][1]), t2.selectAll(".handle").style("display", null).attr("x", function(t3) {
              return "e" === t3.type[t3.type.length - 1] ? n3[1][0] - a2 / 2 : n3[0][0] - a2 / 2;
            }).attr("y", function(t3) {
              return "s" === t3.type[0] ? n3[1][1] - a2 / 2 : n3[0][1] - a2 / 2;
            }).attr("width", function(t3) {
              return "n" === t3.type || "s" === t3.type ? n3[1][0] - n3[0][0] + a2 : a2;
            }).attr("height", function(t3) {
              return "e" === t3.type || "w" === t3.type ? n3[1][1] - n3[0][1] + a2 : a2;
            })) : t2.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
          }
          function f2(t2, n3) {
            return t2.__brush.emitter || new s2(t2, n3);
          }
          function s2(t2, n3) {
            this.that = t2, this.args = n3, this.state = t2.__brush, this.active = 0;
          }
          function l2() {
            if (t.event.touches) {
              if (t.event.changedTouches.length < t.event.touches.length)
                return di();
            } else if (e2)
              return;
            if (i2.apply(this, arguments)) {
              var r3, o3, a3, u3, s3, l3, h3, d2, p2, v2, g2, y2, _2, b2 = this, m2 = t.event.target.__data__.type, x2 = "selection" === (t.event.metaKey ? m2 = "overlay" : m2) ? pi : t.event.altKey ? yi : gi, w2 = n2 === bi ? null : Ni[m2], M2 = n2 === _i ? null : Ai[m2], N2 = Ei(b2), A2 = N2.extent, T2 = N2.selection, S2 = A2[0][0], k2 = A2[0][1], E2 = A2[1][0], C2 = A2[1][1], P2 = w2 && M2 && t.event.shiftKey, z2 = Ot(b2), R2 = z2, D2 = f2(b2, arguments).beforestart();
              "overlay" === m2 ? N2.selection = T2 = [[r3 = n2 === bi ? S2 : z2[0], a3 = n2 === _i ? k2 : z2[1]], [s3 = n2 === bi ? E2 : r3, h3 = n2 === _i ? C2 : a3]] : (r3 = T2[0][0], a3 = T2[0][1], s3 = T2[1][0], h3 = T2[1][1]), o3 = r3, u3 = a3, l3 = s3, d2 = h3;
              var q2 = zt(b2).attr("pointer-events", "none"), L2 = q2.selectAll(".overlay").attr("cursor", xi[m2]);
              if (t.event.touches)
                q2.on("touchmove.brush", O2, true).on("touchend.brush touchcancel.brush", Y2, true);
              else {
                var U2 = zt(t.event.view).on("keydown.brush", function() {
                  switch (t.event.keyCode) {
                    case 16:
                      P2 = w2 && M2;
                      break;
                    case 18:
                      x2 === gi && (w2 && (s3 = l3 - p2 * w2, r3 = o3 + p2 * w2), M2 && (h3 = d2 - v2 * M2, a3 = u3 + v2 * M2), x2 = yi, B2());
                      break;
                    case 32:
                      x2 !== gi && x2 !== yi || (w2 < 0 ? s3 = l3 - p2 : w2 > 0 && (r3 = o3 - p2), M2 < 0 ? h3 = d2 - v2 : M2 > 0 && (a3 = u3 - v2), x2 = vi, L2.attr("cursor", xi.selection), B2());
                      break;
                    default:
                      return;
                  }
                  di();
                }, true).on("keyup.brush", function() {
                  switch (t.event.keyCode) {
                    case 16:
                      P2 && (y2 = _2 = P2 = false, B2());
                      break;
                    case 18:
                      x2 === yi && (w2 < 0 ? s3 = l3 : w2 > 0 && (r3 = o3), M2 < 0 ? h3 = d2 : M2 > 0 && (a3 = u3), x2 = gi, B2());
                      break;
                    case 32:
                      x2 === vi && (t.event.altKey ? (w2 && (s3 = l3 - p2 * w2, r3 = o3 + p2 * w2), M2 && (h3 = d2 - v2 * M2, a3 = u3 + v2 * M2), x2 = yi) : (w2 < 0 ? s3 = l3 : w2 > 0 && (r3 = o3), M2 < 0 ? h3 = d2 : M2 > 0 && (a3 = u3), x2 = gi), L2.attr("cursor", xi[m2]), B2());
                      break;
                    default:
                      return;
                  }
                  di();
                }, true).on("mousemove.brush", O2, true).on("mouseup.brush", Y2, true);
                It(t.event.view);
              }
              hi(), Mr(b2), c2.call(b2), D2.start();
            }
            function O2() {
              var t2 = Ot(b2);
              !P2 || y2 || _2 || (Math.abs(t2[0] - R2[0]) > Math.abs(t2[1] - R2[1]) ? _2 = true : y2 = true), R2 = t2, g2 = true, di(), B2();
            }
            function B2() {
              var t2;
              switch (p2 = R2[0] - z2[0], v2 = R2[1] - z2[1], x2) {
                case vi:
                case pi:
                  w2 && (p2 = Math.max(S2 - r3, Math.min(E2 - s3, p2)), o3 = r3 + p2, l3 = s3 + p2), M2 && (v2 = Math.max(k2 - a3, Math.min(C2 - h3, v2)), u3 = a3 + v2, d2 = h3 + v2);
                  break;
                case gi:
                  w2 < 0 ? (p2 = Math.max(S2 - r3, Math.min(E2 - r3, p2)), o3 = r3 + p2, l3 = s3) : w2 > 0 && (p2 = Math.max(S2 - s3, Math.min(E2 - s3, p2)), o3 = r3, l3 = s3 + p2), M2 < 0 ? (v2 = Math.max(k2 - a3, Math.min(C2 - a3, v2)), u3 = a3 + v2, d2 = h3) : M2 > 0 && (v2 = Math.max(k2 - h3, Math.min(C2 - h3, v2)), u3 = a3, d2 = h3 + v2);
                  break;
                case yi:
                  w2 && (o3 = Math.max(S2, Math.min(E2, r3 - p2 * w2)), l3 = Math.max(S2, Math.min(E2, s3 + p2 * w2))), M2 && (u3 = Math.max(k2, Math.min(C2, a3 - v2 * M2)), d2 = Math.max(k2, Math.min(C2, h3 + v2 * M2)));
              }
              l3 < o3 && (w2 *= -1, t2 = r3, r3 = s3, s3 = t2, t2 = o3, o3 = l3, l3 = t2, m2 in wi && L2.attr("cursor", xi[m2 = wi[m2]])), d2 < u3 && (M2 *= -1, t2 = a3, a3 = h3, h3 = t2, t2 = u3, u3 = d2, d2 = t2, m2 in Mi && L2.attr("cursor", xi[m2 = Mi[m2]])), N2.selection && (T2 = N2.selection), y2 && (o3 = T2[0][0], l3 = T2[1][0]), _2 && (u3 = T2[0][1], d2 = T2[1][1]), T2[0][0] === o3 && T2[0][1] === u3 && T2[1][0] === l3 && T2[1][1] === d2 || (N2.selection = [[o3, u3], [l3, d2]], c2.call(b2), D2.brush());
            }
            function Y2() {
              if (hi(), t.event.touches) {
                if (t.event.touches.length)
                  return;
                e2 && window.clearTimeout(e2), e2 = window.setTimeout(function() {
                  e2 = null;
                }, 500), q2.on("touchmove.brush touchend.brush touchcancel.brush", null);
              } else
                jt(t.event.view, g2), U2.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
              q2.attr("pointer-events", "all"), L2.attr("cursor", xi.overlay), N2.selection && (T2 = N2.selection), Ci(T2) && (N2.selection = null, c2.call(b2)), D2.end();
            }
          }
          function h2() {
            var t2 = this.__brush || { selection: null };
            return t2.extent = r2.apply(this, arguments), t2.dim = n2, t2;
          }
          return u2.move = function(t2, e3) {
            t2.selection ? t2.on("start.brush", function() {
              f2(this, arguments).beforestart().start();
            }).on("interrupt.brush end.brush", function() {
              f2(this, arguments).end();
            }).tween("brush", function() {
              var t3 = this, r3 = t3.__brush, i3 = f2(t3, arguments), o3 = r3.selection, a3 = n2.input("function" == typeof e3 ? e3.apply(this, arguments) : e3, r3.extent), u3 = ye(o3, a3);
              function s3(n3) {
                r3.selection = 1 === n3 && Ci(a3) ? null : u3(n3), c2.call(t3), i3.brush();
              }
              return o3 && a3 ? s3 : s3(1);
            }) : t2.each(function() {
              var t3 = arguments, r3 = this.__brush, i3 = n2.input("function" == typeof e3 ? e3.apply(this, t3) : e3, r3.extent), o3 = f2(this, t3).beforestart();
              Mr(this), r3.selection = null == i3 || Ci(i3) ? null : i3, c2.call(this), o3.start().brush().end();
            });
          }, s2.prototype = { beforestart: function() {
            return 1 == ++this.active && (this.state.emitter = this, this.starting = true), this;
          }, start: function() {
            return this.starting && (this.starting = false, this.emit("start")), this;
          }, brush: function() {
            return this.emit("brush"), this;
          }, end: function() {
            return 0 == --this.active && (delete this.state.emitter, this.emit("end")), this;
          }, emit: function(t2) {
            St(new li(u2, t2, n2.output(this.state.selection)), o2.apply, o2, [t2, this.that, this.args]);
          } }, u2.extent = function(t2) {
            return arguments.length ? (r2 = "function" == typeof t2 ? t2 : si([[+t2[0][0], +t2[0][1]], [+t2[1][0], +t2[1][1]]]), u2) : r2;
          }, u2.filter = function(t2) {
            return arguments.length ? (i2 = "function" == typeof t2 ? t2 : si(!!t2), u2) : i2;
          }, u2.handleSize = function(t2) {
            return arguments.length ? (a2 = +t2, u2) : a2;
          }, u2.on = function() {
            var t2 = o2.on.apply(o2, arguments);
            return t2 === o2 ? u2 : t2;
          }, u2;
        }
        var zi = Math.cos, Ri = Math.sin, Di = Math.PI, qi = Di / 2, Li = 2 * Di, Ui = Math.max;
        var Oi = Array.prototype.slice;
        function Bi(t2) {
          return function() {
            return t2;
          };
        }
        var Yi = Math.PI, Fi = 2 * Yi, Ii = Fi - 1e-6;
        function ji() {
          this._x0 = this._y0 = this._x1 = this._y1 = null, this._ = "";
        }
        function Hi() {
          return new ji();
        }
        function Xi(t2) {
          return t2.source;
        }
        function Gi(t2) {
          return t2.target;
        }
        function Vi(t2) {
          return t2.radius;
        }
        function $i(t2) {
          return t2.startAngle;
        }
        function Wi(t2) {
          return t2.endAngle;
        }
        ji.prototype = Hi.prototype = { constructor: ji, moveTo: function(t2, n2) {
          this._ += "M" + (this._x0 = this._x1 = +t2) + "," + (this._y0 = this._y1 = +n2);
        }, closePath: function() {
          null !== this._x1 && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z");
        }, lineTo: function(t2, n2) {
          this._ += "L" + (this._x1 = +t2) + "," + (this._y1 = +n2);
        }, quadraticCurveTo: function(t2, n2, e2, r2) {
          this._ += "Q" + +t2 + "," + +n2 + "," + (this._x1 = +e2) + "," + (this._y1 = +r2);
        }, bezierCurveTo: function(t2, n2, e2, r2, i2, o2) {
          this._ += "C" + +t2 + "," + +n2 + "," + +e2 + "," + +r2 + "," + (this._x1 = +i2) + "," + (this._y1 = +o2);
        }, arcTo: function(t2, n2, e2, r2, i2) {
          t2 = +t2, n2 = +n2, e2 = +e2, r2 = +r2, i2 = +i2;
          var o2 = this._x1, a2 = this._y1, u2 = e2 - t2, c2 = r2 - n2, f2 = o2 - t2, s2 = a2 - n2, l2 = f2 * f2 + s2 * s2;
          if (i2 < 0)
            throw new Error("negative radius: " + i2);
          if (null === this._x1)
            this._ += "M" + (this._x1 = t2) + "," + (this._y1 = n2);
          else if (l2 > 1e-6)
            if (Math.abs(s2 * u2 - c2 * f2) > 1e-6 && i2) {
              var h2 = e2 - o2, d2 = r2 - a2, p2 = u2 * u2 + c2 * c2, v2 = h2 * h2 + d2 * d2, g2 = Math.sqrt(p2), y2 = Math.sqrt(l2), _2 = i2 * Math.tan((Yi - Math.acos((p2 + l2 - v2) / (2 * g2 * y2))) / 2), b2 = _2 / y2, m2 = _2 / g2;
              Math.abs(b2 - 1) > 1e-6 && (this._ += "L" + (t2 + b2 * f2) + "," + (n2 + b2 * s2)), this._ += "A" + i2 + "," + i2 + ",0,0," + +(s2 * h2 > f2 * d2) + "," + (this._x1 = t2 + m2 * u2) + "," + (this._y1 = n2 + m2 * c2);
            } else
              this._ += "L" + (this._x1 = t2) + "," + (this._y1 = n2);
          else
            ;
        }, arc: function(t2, n2, e2, r2, i2, o2) {
          t2 = +t2, n2 = +n2;
          var a2 = (e2 = +e2) * Math.cos(r2), u2 = e2 * Math.sin(r2), c2 = t2 + a2, f2 = n2 + u2, s2 = 1 ^ o2, l2 = o2 ? r2 - i2 : i2 - r2;
          if (e2 < 0)
            throw new Error("negative radius: " + e2);
          null === this._x1 ? this._ += "M" + c2 + "," + f2 : (Math.abs(this._x1 - c2) > 1e-6 || Math.abs(this._y1 - f2) > 1e-6) && (this._ += "L" + c2 + "," + f2), e2 && (l2 < 0 && (l2 = l2 % Fi + Fi), l2 > Ii ? this._ += "A" + e2 + "," + e2 + ",0,1," + s2 + "," + (t2 - a2) + "," + (n2 - u2) + "A" + e2 + "," + e2 + ",0,1," + s2 + "," + (this._x1 = c2) + "," + (this._y1 = f2) : l2 > 1e-6 && (this._ += "A" + e2 + "," + e2 + ",0," + +(l2 >= Yi) + "," + s2 + "," + (this._x1 = t2 + e2 * Math.cos(i2)) + "," + (this._y1 = n2 + e2 * Math.sin(i2))));
        }, rect: function(t2, n2, e2, r2) {
          this._ += "M" + (this._x0 = this._x1 = +t2) + "," + (this._y0 = this._y1 = +n2) + "h" + +e2 + "v" + +r2 + "h" + -e2 + "Z";
        }, toString: function() {
          return this._;
        } };
        function Zi() {
        }
        function Qi(t2, n2) {
          var e2 = new Zi();
          if (t2 instanceof Zi)
            t2.each(function(t3, n3) {
              e2.set(n3, t3);
            });
          else if (Array.isArray(t2)) {
            var r2, i2 = -1, o2 = t2.length;
            if (null == n2)
              for (; ++i2 < o2; )
                e2.set(i2, t2[i2]);
            else
              for (; ++i2 < o2; )
                e2.set(n2(r2 = t2[i2], i2, t2), r2);
          } else if (t2)
            for (var a2 in t2)
              e2.set(a2, t2[a2]);
          return e2;
        }
        function Ji() {
          return {};
        }
        function Ki(t2, n2, e2) {
          t2[n2] = e2;
        }
        function to() {
          return Qi();
        }
        function no(t2, n2, e2) {
          t2.set(n2, e2);
        }
        function eo() {
        }
        Zi.prototype = Qi.prototype = { constructor: Zi, has: function(t2) {
          return "$" + t2 in this;
        }, get: function(t2) {
          return this["$" + t2];
        }, set: function(t2, n2) {
          return this["$" + t2] = n2, this;
        }, remove: function(t2) {
          var n2 = "$" + t2;
          return n2 in this && delete this[n2];
        }, clear: function() {
          for (var t2 in this)
            "$" === t2[0] && delete this[t2];
        }, keys: function() {
          var t2 = [];
          for (var n2 in this)
            "$" === n2[0] && t2.push(n2.slice(1));
          return t2;
        }, values: function() {
          var t2 = [];
          for (var n2 in this)
            "$" === n2[0] && t2.push(this[n2]);
          return t2;
        }, entries: function() {
          var t2 = [];
          for (var n2 in this)
            "$" === n2[0] && t2.push({ key: n2.slice(1), value: this[n2] });
          return t2;
        }, size: function() {
          var t2 = 0;
          for (var n2 in this)
            "$" === n2[0] && ++t2;
          return t2;
        }, empty: function() {
          for (var t2 in this)
            if ("$" === t2[0])
              return false;
          return true;
        }, each: function(t2) {
          for (var n2 in this)
            "$" === n2[0] && t2(this[n2], n2.slice(1), this);
        } };
        var ro = Qi.prototype;
        function io(t2, n2) {
          var e2 = new eo();
          if (t2 instanceof eo)
            t2.each(function(t3) {
              e2.add(t3);
            });
          else if (t2) {
            var r2 = -1, i2 = t2.length;
            if (null == n2)
              for (; ++r2 < i2; )
                e2.add(t2[r2]);
            else
              for (; ++r2 < i2; )
                e2.add(n2(t2[r2], r2, t2));
          }
          return e2;
        }
        eo.prototype = io.prototype = { constructor: eo, has: ro.has, add: function(t2) {
          return this["$" + (t2 += "")] = t2, this;
        }, remove: ro.remove, clear: ro.clear, values: ro.keys, size: ro.size, empty: ro.empty, each: ro.each };
        var oo = Array.prototype.slice;
        function ao(t2, n2) {
          return t2 - n2;
        }
        function uo(t2) {
          return function() {
            return t2;
          };
        }
        function co(t2, n2) {
          for (var e2, r2 = -1, i2 = n2.length; ++r2 < i2; )
            if (e2 = fo(t2, n2[r2]))
              return e2;
          return 0;
        }
        function fo(t2, n2) {
          for (var e2 = n2[0], r2 = n2[1], i2 = -1, o2 = 0, a2 = t2.length, u2 = a2 - 1; o2 < a2; u2 = o2++) {
            var c2 = t2[o2], f2 = c2[0], s2 = c2[1], l2 = t2[u2], h2 = l2[0], d2 = l2[1];
            if (so(c2, l2, n2))
              return 0;
            s2 > r2 != d2 > r2 && e2 < (h2 - f2) * (r2 - s2) / (d2 - s2) + f2 && (i2 = -i2);
          }
          return i2;
        }
        function so(t2, n2, e2) {
          var r2, i2, o2, a2;
          return function(t3, n3, e3) {
            return (n3[0] - t3[0]) * (e3[1] - t3[1]) == (e3[0] - t3[0]) * (n3[1] - t3[1]);
          }(t2, n2, e2) && (i2 = t2[r2 = +(t2[0] === n2[0])], o2 = e2[r2], a2 = n2[r2], i2 <= o2 && o2 <= a2 || a2 <= o2 && o2 <= i2);
        }
        function lo() {
        }
        var ho = [[], [[[1, 1.5], [0.5, 1]]], [[[1.5, 1], [1, 1.5]]], [[[1.5, 1], [0.5, 1]]], [[[1, 0.5], [1.5, 1]]], [[[1, 1.5], [0.5, 1]], [[1, 0.5], [1.5, 1]]], [[[1, 0.5], [1, 1.5]]], [[[1, 0.5], [0.5, 1]]], [[[0.5, 1], [1, 0.5]]], [[[1, 1.5], [1, 0.5]]], [[[0.5, 1], [1, 0.5]], [[1.5, 1], [1, 1.5]]], [[[1.5, 1], [1, 0.5]]], [[[0.5, 1], [1.5, 1]]], [[[1, 1.5], [1.5, 1]]], [[[0.5, 1], [1, 1.5]]], []];
        function po() {
          var t2 = 1, n2 = 1, e2 = M, r2 = u2;
          function i2(t3) {
            var n3 = e2(t3);
            if (Array.isArray(n3))
              n3 = n3.slice().sort(ao);
            else {
              var r3 = s(t3), i3 = r3[0], a3 = r3[1];
              n3 = w(i3, a3, n3), n3 = g(Math.floor(i3 / n3) * n3, Math.floor(a3 / n3) * n3, n3);
            }
            return n3.map(function(n4) {
              return o2(t3, n4);
            });
          }
          function o2(e3, i3) {
            var o3 = [], u3 = [];
            return function(e4, r3, i4) {
              var o4, u4, c2, f2, s2, l2, h2 = new Array(), d2 = new Array();
              o4 = u4 = -1, f2 = e4[0] >= r3, ho[f2 << 1].forEach(p2);
              for (; ++o4 < t2 - 1; )
                c2 = f2, f2 = e4[o4 + 1] >= r3, ho[c2 | f2 << 1].forEach(p2);
              ho[f2 << 0].forEach(p2);
              for (; ++u4 < n2 - 1; ) {
                for (o4 = -1, f2 = e4[u4 * t2 + t2] >= r3, s2 = e4[u4 * t2] >= r3, ho[f2 << 1 | s2 << 2].forEach(p2); ++o4 < t2 - 1; )
                  c2 = f2, f2 = e4[u4 * t2 + t2 + o4 + 1] >= r3, l2 = s2, s2 = e4[u4 * t2 + o4 + 1] >= r3, ho[c2 | f2 << 1 | s2 << 2 | l2 << 3].forEach(p2);
                ho[f2 | s2 << 3].forEach(p2);
              }
              o4 = -1, s2 = e4[u4 * t2] >= r3, ho[s2 << 2].forEach(p2);
              for (; ++o4 < t2 - 1; )
                l2 = s2, s2 = e4[u4 * t2 + o4 + 1] >= r3, ho[s2 << 2 | l2 << 3].forEach(p2);
              function p2(t3) {
                var n3, e5, r4 = [t3[0][0] + o4, t3[0][1] + u4], c3 = [t3[1][0] + o4, t3[1][1] + u4], f3 = a2(r4), s3 = a2(c3);
                (n3 = d2[f3]) ? (e5 = h2[s3]) ? (delete d2[n3.end], delete h2[e5.start], n3 === e5 ? (n3.ring.push(c3), i4(n3.ring)) : h2[n3.start] = d2[e5.end] = { start: n3.start, end: e5.end, ring: n3.ring.concat(e5.ring) }) : (delete d2[n3.end], n3.ring.push(c3), d2[n3.end = s3] = n3) : (n3 = h2[s3]) ? (e5 = d2[f3]) ? (delete h2[n3.start], delete d2[e5.end], n3 === e5 ? (n3.ring.push(c3), i4(n3.ring)) : h2[e5.start] = d2[n3.end] = { start: e5.start, end: n3.end, ring: e5.ring.concat(n3.ring) }) : (delete h2[n3.start], n3.ring.unshift(r4), h2[n3.start = f3] = n3) : h2[f3] = d2[s3] = { start: f3, end: s3, ring: [r4, c3] };
              }
              ho[s2 << 3].forEach(p2);
            }(e3, i3, function(t3) {
              r2(t3, e3, i3), function(t4) {
                for (var n3 = 0, e4 = t4.length, r3 = t4[e4 - 1][1] * t4[0][0] - t4[e4 - 1][0] * t4[0][1]; ++n3 < e4; )
                  r3 += t4[n3 - 1][1] * t4[n3][0] - t4[n3 - 1][0] * t4[n3][1];
                return r3;
              }(t3) > 0 ? o3.push([t3]) : u3.push(t3);
            }), u3.forEach(function(t3) {
              for (var n3, e4 = 0, r3 = o3.length; e4 < r3; ++e4)
                if (-1 !== co((n3 = o3[e4])[0], t3))
                  return void n3.push(t3);
            }), { type: "MultiPolygon", value: i3, coordinates: o3 };
          }
          function a2(n3) {
            return 2 * n3[0] + n3[1] * (t2 + 1) * 4;
          }
          function u2(e3, r3, i3) {
            e3.forEach(function(e4) {
              var o3, a3 = e4[0], u3 = e4[1], c2 = 0 | a3, f2 = 0 | u3, s2 = r3[f2 * t2 + c2];
              a3 > 0 && a3 < t2 && c2 === a3 && (o3 = r3[f2 * t2 + c2 - 1], e4[0] = a3 + (i3 - o3) / (s2 - o3) - 0.5), u3 > 0 && u3 < n2 && f2 === u3 && (o3 = r3[(f2 - 1) * t2 + c2], e4[1] = u3 + (i3 - o3) / (s2 - o3) - 0.5);
            });
          }
          return i2.contour = o2, i2.size = function(e3) {
            if (!arguments.length)
              return [t2, n2];
            var r3 = Math.ceil(e3[0]), o3 = Math.ceil(e3[1]);
            if (!(r3 > 0 && o3 > 0))
              throw new Error("invalid size");
            return t2 = r3, n2 = o3, i2;
          }, i2.thresholds = function(t3) {
            return arguments.length ? (e2 = "function" == typeof t3 ? t3 : Array.isArray(t3) ? uo(oo.call(t3)) : uo(t3), i2) : e2;
          }, i2.smooth = function(t3) {
            return arguments.length ? (r2 = t3 ? u2 : lo, i2) : r2 === u2;
          }, i2;
        }
        function vo(t2, n2, e2) {
          for (var r2 = t2.width, i2 = t2.height, o2 = 1 + (e2 << 1), a2 = 0; a2 < i2; ++a2)
            for (var u2 = 0, c2 = 0; u2 < r2 + e2; ++u2)
              u2 < r2 && (c2 += t2.data[u2 + a2 * r2]), u2 >= e2 && (u2 >= o2 && (c2 -= t2.data[u2 - o2 + a2 * r2]), n2.data[u2 - e2 + a2 * r2] = c2 / Math.min(u2 + 1, r2 - 1 + o2 - u2, o2));
        }
        function go(t2, n2, e2) {
          for (var r2 = t2.width, i2 = t2.height, o2 = 1 + (e2 << 1), a2 = 0; a2 < r2; ++a2)
            for (var u2 = 0, c2 = 0; u2 < i2 + e2; ++u2)
              u2 < i2 && (c2 += t2.data[a2 + u2 * r2]), u2 >= e2 && (u2 >= o2 && (c2 -= t2.data[a2 + (u2 - o2) * r2]), n2.data[a2 + (u2 - e2) * r2] = c2 / Math.min(u2 + 1, i2 - 1 + o2 - u2, o2));
        }
        function yo(t2) {
          return t2[0];
        }
        function _o(t2) {
          return t2[1];
        }
        function bo() {
          return 1;
        }
        var mo = {}, xo = {}, wo = 34, Mo = 10, No = 13;
        function Ao(t2) {
          return new Function("d", "return {" + t2.map(function(t3, n2) {
            return JSON.stringify(t3) + ": d[" + n2 + "]";
          }).join(",") + "}");
        }
        function To(t2) {
          var n2 = /* @__PURE__ */ Object.create(null), e2 = [];
          return t2.forEach(function(t3) {
            for (var r2 in t3)
              r2 in n2 || e2.push(n2[r2] = r2);
          }), e2;
        }
        function So(t2, n2) {
          var e2 = t2 + "", r2 = e2.length;
          return r2 < n2 ? new Array(n2 - r2 + 1).join(0) + e2 : e2;
        }
        function ko(t2) {
          var n2, e2 = t2.getUTCHours(), r2 = t2.getUTCMinutes(), i2 = t2.getUTCSeconds(), o2 = t2.getUTCMilliseconds();
          return isNaN(t2) ? "Invalid Date" : ((n2 = t2.getUTCFullYear()) < 0 ? "-" + So(-n2, 6) : n2 > 9999 ? "+" + So(n2, 6) : So(n2, 4)) + "-" + So(t2.getUTCMonth() + 1, 2) + "-" + So(t2.getUTCDate(), 2) + (o2 ? "T" + So(e2, 2) + ":" + So(r2, 2) + ":" + So(i2, 2) + "." + So(o2, 3) + "Z" : i2 ? "T" + So(e2, 2) + ":" + So(r2, 2) + ":" + So(i2, 2) + "Z" : r2 || e2 ? "T" + So(e2, 2) + ":" + So(r2, 2) + "Z" : "");
        }
        function Eo(t2) {
          var n2 = new RegExp('["' + t2 + "\n\r]"), e2 = t2.charCodeAt(0);
          function r2(t3, n3) {
            var r3, i3 = [], o3 = t3.length, a3 = 0, u2 = 0, c2 = o3 <= 0, f2 = false;
            function s2() {
              if (c2)
                return xo;
              if (f2)
                return f2 = false, mo;
              var n4, r4, i4 = a3;
              if (t3.charCodeAt(i4) === wo) {
                for (; a3++ < o3 && t3.charCodeAt(a3) !== wo || t3.charCodeAt(++a3) === wo; )
                  ;
                return (n4 = a3) >= o3 ? c2 = true : (r4 = t3.charCodeAt(a3++)) === Mo ? f2 = true : r4 === No && (f2 = true, t3.charCodeAt(a3) === Mo && ++a3), t3.slice(i4 + 1, n4 - 1).replace(/""/g, '"');
              }
              for (; a3 < o3; ) {
                if ((r4 = t3.charCodeAt(n4 = a3++)) === Mo)
                  f2 = true;
                else if (r4 === No)
                  f2 = true, t3.charCodeAt(a3) === Mo && ++a3;
                else if (r4 !== e2)
                  continue;
                return t3.slice(i4, n4);
              }
              return c2 = true, t3.slice(i4, o3);
            }
            for (t3.charCodeAt(o3 - 1) === Mo && --o3, t3.charCodeAt(o3 - 1) === No && --o3; (r3 = s2()) !== xo; ) {
              for (var l2 = []; r3 !== mo && r3 !== xo; )
                l2.push(r3), r3 = s2();
              n3 && null == (l2 = n3(l2, u2++)) || i3.push(l2);
            }
            return i3;
          }
          function i2(n3, e3) {
            return n3.map(function(n4) {
              return e3.map(function(t3) {
                return a2(n4[t3]);
              }).join(t2);
            });
          }
          function o2(n3) {
            return n3.map(a2).join(t2);
          }
          function a2(t3) {
            return null == t3 ? "" : t3 instanceof Date ? ko(t3) : n2.test(t3 += "") ? '"' + t3.replace(/"/g, '""') + '"' : t3;
          }
          return { parse: function(t3, n3) {
            var e3, i3, o3 = r2(t3, function(t4, r3) {
              if (e3)
                return e3(t4, r3 - 1);
              i3 = t4, e3 = n3 ? function(t5, n4) {
                var e4 = Ao(t5);
                return function(r4, i4) {
                  return n4(e4(r4), i4, t5);
                };
              }(t4, n3) : Ao(t4);
            });
            return o3.columns = i3 || [], o3;
          }, parseRows: r2, format: function(n3, e3) {
            return null == e3 && (e3 = To(n3)), [e3.map(a2).join(t2)].concat(i2(n3, e3)).join("\n");
          }, formatBody: function(t3, n3) {
            return null == n3 && (n3 = To(t3)), i2(t3, n3).join("\n");
          }, formatRows: function(t3) {
            return t3.map(o2).join("\n");
          } };
        }
        var Co = Eo(","), Po = Co.parse, zo = Co.parseRows, Ro = Co.format, Do = Co.formatBody, qo = Co.formatRows, Lo = Eo("	"), Uo = Lo.parse, Oo = Lo.parseRows, Bo = Lo.format, Yo = Lo.formatBody, Fo = Lo.formatRows;
        function Io(t2) {
          if (!t2.ok)
            throw new Error(t2.status + " " + t2.statusText);
          return t2.blob();
        }
        function jo(t2) {
          if (!t2.ok)
            throw new Error(t2.status + " " + t2.statusText);
          return t2.arrayBuffer();
        }
        function Ho(t2) {
          if (!t2.ok)
            throw new Error(t2.status + " " + t2.statusText);
          return t2.text();
        }
        function Xo(t2, n2) {
          return fetch(t2, n2).then(Ho);
        }
        function Go(t2) {
          return function(n2, e2, r2) {
            return 2 === arguments.length && "function" == typeof e2 && (r2 = e2, e2 = void 0), Xo(n2, e2).then(function(n3) {
              return t2(n3, r2);
            });
          };
        }
        var Vo = Go(Po), $o = Go(Uo);
        function Wo(t2) {
          if (!t2.ok)
            throw new Error(t2.status + " " + t2.statusText);
          return t2.json();
        }
        function Zo(t2) {
          return function(n2, e2) {
            return Xo(n2, e2).then(function(n3) {
              return new DOMParser().parseFromString(n3, t2);
            });
          };
        }
        var Qo = Zo("application/xml"), Jo = Zo("text/html"), Ko = Zo("image/svg+xml");
        function ta(t2) {
          return function() {
            return t2;
          };
        }
        function na() {
          return 1e-6 * (Math.random() - 0.5);
        }
        function ea(t2, n2, e2, r2) {
          if (isNaN(n2) || isNaN(e2))
            return t2;
          var i2, o2, a2, u2, c2, f2, s2, l2, h2, d2 = t2._root, p2 = { data: r2 }, v2 = t2._x0, g2 = t2._y0, y2 = t2._x1, _2 = t2._y1;
          if (!d2)
            return t2._root = p2, t2;
          for (; d2.length; )
            if ((f2 = n2 >= (o2 = (v2 + y2) / 2)) ? v2 = o2 : y2 = o2, (s2 = e2 >= (a2 = (g2 + _2) / 2)) ? g2 = a2 : _2 = a2, i2 = d2, !(d2 = d2[l2 = s2 << 1 | f2]))
              return i2[l2] = p2, t2;
          if (u2 = +t2._x.call(null, d2.data), c2 = +t2._y.call(null, d2.data), n2 === u2 && e2 === c2)
            return p2.next = d2, i2 ? i2[l2] = p2 : t2._root = p2, t2;
          do {
            i2 = i2 ? i2[l2] = new Array(4) : t2._root = new Array(4), (f2 = n2 >= (o2 = (v2 + y2) / 2)) ? v2 = o2 : y2 = o2, (s2 = e2 >= (a2 = (g2 + _2) / 2)) ? g2 = a2 : _2 = a2;
          } while ((l2 = s2 << 1 | f2) == (h2 = (c2 >= a2) << 1 | u2 >= o2));
          return i2[h2] = d2, i2[l2] = p2, t2;
        }
        function ra(t2, n2, e2, r2, i2) {
          this.node = t2, this.x0 = n2, this.y0 = e2, this.x1 = r2, this.y1 = i2;
        }
        function ia(t2) {
          return t2[0];
        }
        function oa(t2) {
          return t2[1];
        }
        function aa(t2, n2, e2) {
          var r2 = new ua(null == n2 ? ia : n2, null == e2 ? oa : e2, NaN, NaN, NaN, NaN);
          return null == t2 ? r2 : r2.addAll(t2);
        }
        function ua(t2, n2, e2, r2, i2, o2) {
          this._x = t2, this._y = n2, this._x0 = e2, this._y0 = r2, this._x1 = i2, this._y1 = o2, this._root = void 0;
        }
        function ca(t2) {
          for (var n2 = { data: t2.data }, e2 = n2; t2 = t2.next; )
            e2 = e2.next = { data: t2.data };
          return n2;
        }
        var fa = aa.prototype = ua.prototype;
        function sa(t2) {
          return t2.x + t2.vx;
        }
        function la(t2) {
          return t2.y + t2.vy;
        }
        function ha(t2) {
          return t2.index;
        }
        function da(t2, n2) {
          var e2 = t2.get(n2);
          if (!e2)
            throw new Error("missing: " + n2);
          return e2;
        }
        function pa(t2) {
          return t2.x;
        }
        function va(t2) {
          return t2.y;
        }
        fa.copy = function() {
          var t2, n2, e2 = new ua(this._x, this._y, this._x0, this._y0, this._x1, this._y1), r2 = this._root;
          if (!r2)
            return e2;
          if (!r2.length)
            return e2._root = ca(r2), e2;
          for (t2 = [{ source: r2, target: e2._root = new Array(4) }]; r2 = t2.pop(); )
            for (var i2 = 0; i2 < 4; ++i2)
              (n2 = r2.source[i2]) && (n2.length ? t2.push({ source: n2, target: r2.target[i2] = new Array(4) }) : r2.target[i2] = ca(n2));
          return e2;
        }, fa.add = function(t2) {
          var n2 = +this._x.call(null, t2), e2 = +this._y.call(null, t2);
          return ea(this.cover(n2, e2), n2, e2, t2);
        }, fa.addAll = function(t2) {
          var n2, e2, r2, i2, o2 = t2.length, a2 = new Array(o2), u2 = new Array(o2), c2 = 1 / 0, f2 = 1 / 0, s2 = -1 / 0, l2 = -1 / 0;
          for (e2 = 0; e2 < o2; ++e2)
            isNaN(r2 = +this._x.call(null, n2 = t2[e2])) || isNaN(i2 = +this._y.call(null, n2)) || (a2[e2] = r2, u2[e2] = i2, r2 < c2 && (c2 = r2), r2 > s2 && (s2 = r2), i2 < f2 && (f2 = i2), i2 > l2 && (l2 = i2));
          if (c2 > s2 || f2 > l2)
            return this;
          for (this.cover(c2, f2).cover(s2, l2), e2 = 0; e2 < o2; ++e2)
            ea(this, a2[e2], u2[e2], t2[e2]);
          return this;
        }, fa.cover = function(t2, n2) {
          if (isNaN(t2 = +t2) || isNaN(n2 = +n2))
            return this;
          var e2 = this._x0, r2 = this._y0, i2 = this._x1, o2 = this._y1;
          if (isNaN(e2))
            i2 = (e2 = Math.floor(t2)) + 1, o2 = (r2 = Math.floor(n2)) + 1;
          else {
            for (var a2, u2, c2 = i2 - e2, f2 = this._root; e2 > t2 || t2 >= i2 || r2 > n2 || n2 >= o2; )
              switch (u2 = (n2 < r2) << 1 | t2 < e2, (a2 = new Array(4))[u2] = f2, f2 = a2, c2 *= 2, u2) {
                case 0:
                  i2 = e2 + c2, o2 = r2 + c2;
                  break;
                case 1:
                  e2 = i2 - c2, o2 = r2 + c2;
                  break;
                case 2:
                  i2 = e2 + c2, r2 = o2 - c2;
                  break;
                case 3:
                  e2 = i2 - c2, r2 = o2 - c2;
              }
            this._root && this._root.length && (this._root = f2);
          }
          return this._x0 = e2, this._y0 = r2, this._x1 = i2, this._y1 = o2, this;
        }, fa.data = function() {
          var t2 = [];
          return this.visit(function(n2) {
            if (!n2.length)
              do {
                t2.push(n2.data);
              } while (n2 = n2.next);
          }), t2;
        }, fa.extent = function(t2) {
          return arguments.length ? this.cover(+t2[0][0], +t2[0][1]).cover(+t2[1][0], +t2[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
        }, fa.find = function(t2, n2, e2) {
          var r2, i2, o2, a2, u2, c2, f2, s2 = this._x0, l2 = this._y0, h2 = this._x1, d2 = this._y1, p2 = [], v2 = this._root;
          for (v2 && p2.push(new ra(v2, s2, l2, h2, d2)), null == e2 ? e2 = 1 / 0 : (s2 = t2 - e2, l2 = n2 - e2, h2 = t2 + e2, d2 = n2 + e2, e2 *= e2); c2 = p2.pop(); )
            if (!(!(v2 = c2.node) || (i2 = c2.x0) > h2 || (o2 = c2.y0) > d2 || (a2 = c2.x1) < s2 || (u2 = c2.y1) < l2))
              if (v2.length) {
                var g2 = (i2 + a2) / 2, y2 = (o2 + u2) / 2;
                p2.push(new ra(v2[3], g2, y2, a2, u2), new ra(v2[2], i2, y2, g2, u2), new ra(v2[1], g2, o2, a2, y2), new ra(v2[0], i2, o2, g2, y2)), (f2 = (n2 >= y2) << 1 | t2 >= g2) && (c2 = p2[p2.length - 1], p2[p2.length - 1] = p2[p2.length - 1 - f2], p2[p2.length - 1 - f2] = c2);
              } else {
                var _2 = t2 - +this._x.call(null, v2.data), b2 = n2 - +this._y.call(null, v2.data), m2 = _2 * _2 + b2 * b2;
                if (m2 < e2) {
                  var x2 = Math.sqrt(e2 = m2);
                  s2 = t2 - x2, l2 = n2 - x2, h2 = t2 + x2, d2 = n2 + x2, r2 = v2.data;
                }
              }
          return r2;
        }, fa.remove = function(t2) {
          if (isNaN(o2 = +this._x.call(null, t2)) || isNaN(a2 = +this._y.call(null, t2)))
            return this;
          var n2, e2, r2, i2, o2, a2, u2, c2, f2, s2, l2, h2, d2 = this._root, p2 = this._x0, v2 = this._y0, g2 = this._x1, y2 = this._y1;
          if (!d2)
            return this;
          if (d2.length)
            for (; ; ) {
              if ((f2 = o2 >= (u2 = (p2 + g2) / 2)) ? p2 = u2 : g2 = u2, (s2 = a2 >= (c2 = (v2 + y2) / 2)) ? v2 = c2 : y2 = c2, n2 = d2, !(d2 = d2[l2 = s2 << 1 | f2]))
                return this;
              if (!d2.length)
                break;
              (n2[l2 + 1 & 3] || n2[l2 + 2 & 3] || n2[l2 + 3 & 3]) && (e2 = n2, h2 = l2);
            }
          for (; d2.data !== t2; )
            if (r2 = d2, !(d2 = d2.next))
              return this;
          return (i2 = d2.next) && delete d2.next, r2 ? (i2 ? r2.next = i2 : delete r2.next, this) : n2 ? (i2 ? n2[l2] = i2 : delete n2[l2], (d2 = n2[0] || n2[1] || n2[2] || n2[3]) && d2 === (n2[3] || n2[2] || n2[1] || n2[0]) && !d2.length && (e2 ? e2[h2] = d2 : this._root = d2), this) : (this._root = i2, this);
        }, fa.removeAll = function(t2) {
          for (var n2 = 0, e2 = t2.length; n2 < e2; ++n2)
            this.remove(t2[n2]);
          return this;
        }, fa.root = function() {
          return this._root;
        }, fa.size = function() {
          var t2 = 0;
          return this.visit(function(n2) {
            if (!n2.length)
              do {
                ++t2;
              } while (n2 = n2.next);
          }), t2;
        }, fa.visit = function(t2) {
          var n2, e2, r2, i2, o2, a2, u2 = [], c2 = this._root;
          for (c2 && u2.push(new ra(c2, this._x0, this._y0, this._x1, this._y1)); n2 = u2.pop(); )
            if (!t2(c2 = n2.node, r2 = n2.x0, i2 = n2.y0, o2 = n2.x1, a2 = n2.y1) && c2.length) {
              var f2 = (r2 + o2) / 2, s2 = (i2 + a2) / 2;
              (e2 = c2[3]) && u2.push(new ra(e2, f2, s2, o2, a2)), (e2 = c2[2]) && u2.push(new ra(e2, r2, s2, f2, a2)), (e2 = c2[1]) && u2.push(new ra(e2, f2, i2, o2, s2)), (e2 = c2[0]) && u2.push(new ra(e2, r2, i2, f2, s2));
            }
          return this;
        }, fa.visitAfter = function(t2) {
          var n2, e2 = [], r2 = [];
          for (this._root && e2.push(new ra(this._root, this._x0, this._y0, this._x1, this._y1)); n2 = e2.pop(); ) {
            var i2 = n2.node;
            if (i2.length) {
              var o2, a2 = n2.x0, u2 = n2.y0, c2 = n2.x1, f2 = n2.y1, s2 = (a2 + c2) / 2, l2 = (u2 + f2) / 2;
              (o2 = i2[0]) && e2.push(new ra(o2, a2, u2, s2, l2)), (o2 = i2[1]) && e2.push(new ra(o2, s2, u2, c2, l2)), (o2 = i2[2]) && e2.push(new ra(o2, a2, l2, s2, f2)), (o2 = i2[3]) && e2.push(new ra(o2, s2, l2, c2, f2));
            }
            r2.push(n2);
          }
          for (; n2 = r2.pop(); )
            t2(n2.node, n2.x0, n2.y0, n2.x1, n2.y1);
          return this;
        }, fa.x = function(t2) {
          return arguments.length ? (this._x = t2, this) : this._x;
        }, fa.y = function(t2) {
          return arguments.length ? (this._y = t2, this) : this._y;
        };
        var ga = 10, ya = Math.PI * (3 - Math.sqrt(5));
        function _a(t2, n2) {
          if ((e2 = (t2 = n2 ? t2.toExponential(n2 - 1) : t2.toExponential()).indexOf("e")) < 0)
            return null;
          var e2, r2 = t2.slice(0, e2);
          return [r2.length > 1 ? r2[0] + r2.slice(2) : r2, +t2.slice(e2 + 1)];
        }
        function ba(t2) {
          return (t2 = _a(Math.abs(t2))) ? t2[1] : NaN;
        }
        var ma, xa = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
        function wa(t2) {
          return new Ma(t2);
        }
        function Ma(t2) {
          if (!(n2 = xa.exec(t2)))
            throw new Error("invalid format: " + t2);
          var n2;
          this.fill = n2[1] || " ", this.align = n2[2] || ">", this.sign = n2[3] || "-", this.symbol = n2[4] || "", this.zero = !!n2[5], this.width = n2[6] && +n2[6], this.comma = !!n2[7], this.precision = n2[8] && +n2[8].slice(1), this.trim = !!n2[9], this.type = n2[10] || "";
        }
        function Na(t2, n2) {
          var e2 = _a(t2, n2);
          if (!e2)
            return t2 + "";
          var r2 = e2[0], i2 = e2[1];
          return i2 < 0 ? "0." + new Array(-i2).join("0") + r2 : r2.length > i2 + 1 ? r2.slice(0, i2 + 1) + "." + r2.slice(i2 + 1) : r2 + new Array(i2 - r2.length + 2).join("0");
        }
        wa.prototype = Ma.prototype, Ma.prototype.toString = function() {
          return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (null == this.width ? "" : Math.max(1, 0 | this.width)) + (this.comma ? "," : "") + (null == this.precision ? "" : "." + Math.max(0, 0 | this.precision)) + (this.trim ? "~" : "") + this.type;
        };
        var Aa = { "%": function(t2, n2) {
          return (100 * t2).toFixed(n2);
        }, b: function(t2) {
          return Math.round(t2).toString(2);
        }, c: function(t2) {
          return t2 + "";
        }, d: function(t2) {
          return Math.round(t2).toString(10);
        }, e: function(t2, n2) {
          return t2.toExponential(n2);
        }, f: function(t2, n2) {
          return t2.toFixed(n2);
        }, g: function(t2, n2) {
          return t2.toPrecision(n2);
        }, o: function(t2) {
          return Math.round(t2).toString(8);
        }, p: function(t2, n2) {
          return Na(100 * t2, n2);
        }, r: Na, s: function(t2, n2) {
          var e2 = _a(t2, n2);
          if (!e2)
            return t2 + "";
          var r2 = e2[0], i2 = e2[1], o2 = i2 - (ma = 3 * Math.max(-8, Math.min(8, Math.floor(i2 / 3)))) + 1, a2 = r2.length;
          return o2 === a2 ? r2 : o2 > a2 ? r2 + new Array(o2 - a2 + 1).join("0") : o2 > 0 ? r2.slice(0, o2) + "." + r2.slice(o2) : "0." + new Array(1 - o2).join("0") + _a(t2, Math.max(0, n2 + o2 - 1))[0];
        }, X: function(t2) {
          return Math.round(t2).toString(16).toUpperCase();
        }, x: function(t2) {
          return Math.round(t2).toString(16);
        } };
        function Ta(t2) {
          return t2;
        }
        var Sa, ka = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
        function Ea(t2) {
          var n2, e2, r2 = t2.grouping && t2.thousands ? (n2 = t2.grouping, e2 = t2.thousands, function(t3, r3) {
            for (var i3 = t3.length, o3 = [], a3 = 0, u3 = n2[0], c3 = 0; i3 > 0 && u3 > 0 && (c3 + u3 + 1 > r3 && (u3 = Math.max(1, r3 - c3)), o3.push(t3.substring(i3 -= u3, i3 + u3)), !((c3 += u3 + 1) > r3)); )
              u3 = n2[a3 = (a3 + 1) % n2.length];
            return o3.reverse().join(e2);
          }) : Ta, i2 = t2.currency, o2 = t2.decimal, a2 = t2.numerals ? function(t3) {
            return function(n3) {
              return n3.replace(/[0-9]/g, function(n4) {
                return t3[+n4];
              });
            };
          }(t2.numerals) : Ta, u2 = t2.percent || "%";
          function c2(t3) {
            var n3 = (t3 = wa(t3)).fill, e3 = t3.align, c3 = t3.sign, f2 = t3.symbol, s2 = t3.zero, l2 = t3.width, h2 = t3.comma, d2 = t3.precision, p2 = t3.trim, v2 = t3.type;
            "n" === v2 ? (h2 = true, v2 = "g") : Aa[v2] || (null == d2 && (d2 = 12), p2 = true, v2 = "g"), (s2 || "0" === n3 && "=" === e3) && (s2 = true, n3 = "0", e3 = "=");
            var g2 = "$" === f2 ? i2[0] : "#" === f2 && /[boxX]/.test(v2) ? "0" + v2.toLowerCase() : "", y2 = "$" === f2 ? i2[1] : /[%p]/.test(v2) ? u2 : "", _2 = Aa[v2], b2 = /[defgprs%]/.test(v2);
            function m2(t4) {
              var i3, u3, f3, m3 = g2, x2 = y2;
              if ("c" === v2)
                x2 = _2(t4) + x2, t4 = "";
              else {
                var w2 = (t4 = +t4) < 0;
                if (t4 = _2(Math.abs(t4), d2), p2 && (t4 = function(t5) {
                  t:
                    for (var n4, e4 = t5.length, r3 = 1, i4 = -1; r3 < e4; ++r3)
                      switch (t5[r3]) {
                        case ".":
                          i4 = n4 = r3;
                          break;
                        case "0":
                          0 === i4 && (i4 = r3), n4 = r3;
                          break;
                        default:
                          if (i4 > 0) {
                            if (!+t5[r3])
                              break t;
                            i4 = 0;
                          }
                      }
                  return i4 > 0 ? t5.slice(0, i4) + t5.slice(n4 + 1) : t5;
                }(t4)), w2 && 0 == +t4 && (w2 = false), m3 = (w2 ? "(" === c3 ? c3 : "-" : "-" === c3 || "(" === c3 ? "" : c3) + m3, x2 = ("s" === v2 ? ka[8 + ma / 3] : "") + x2 + (w2 && "(" === c3 ? ")" : ""), b2) {
                  for (i3 = -1, u3 = t4.length; ++i3 < u3; )
                    if (48 > (f3 = t4.charCodeAt(i3)) || f3 > 57) {
                      x2 = (46 === f3 ? o2 + t4.slice(i3 + 1) : t4.slice(i3)) + x2, t4 = t4.slice(0, i3);
                      break;
                    }
                }
              }
              h2 && !s2 && (t4 = r2(t4, 1 / 0));
              var M2 = m3.length + t4.length + x2.length, N2 = M2 < l2 ? new Array(l2 - M2 + 1).join(n3) : "";
              switch (h2 && s2 && (t4 = r2(N2 + t4, N2.length ? l2 - x2.length : 1 / 0), N2 = ""), e3) {
                case "<":
                  t4 = m3 + t4 + x2 + N2;
                  break;
                case "=":
                  t4 = m3 + N2 + t4 + x2;
                  break;
                case "^":
                  t4 = N2.slice(0, M2 = N2.length >> 1) + m3 + t4 + x2 + N2.slice(M2);
                  break;
                default:
                  t4 = N2 + m3 + t4 + x2;
              }
              return a2(t4);
            }
            return d2 = null == d2 ? 6 : /[gprs]/.test(v2) ? Math.max(1, Math.min(21, d2)) : Math.max(0, Math.min(20, d2)), m2.toString = function() {
              return t3 + "";
            }, m2;
          }
          return { format: c2, formatPrefix: function(t3, n3) {
            var e3 = c2(((t3 = wa(t3)).type = "f", t3)), r3 = 3 * Math.max(-8, Math.min(8, Math.floor(ba(n3) / 3))), i3 = Math.pow(10, -r3), o3 = ka[8 + r3 / 3];
            return function(t4) {
              return e3(i3 * t4) + o3;
            };
          } };
        }
        function Ca(n2) {
          return Sa = Ea(n2), t.format = Sa.format, t.formatPrefix = Sa.formatPrefix, Sa;
        }
        function Pa(t2) {
          return Math.max(0, -ba(Math.abs(t2)));
        }
        function za(t2, n2) {
          return Math.max(0, 3 * Math.max(-8, Math.min(8, Math.floor(ba(n2) / 3))) - ba(Math.abs(t2)));
        }
        function Ra(t2, n2) {
          return t2 = Math.abs(t2), n2 = Math.abs(n2) - t2, Math.max(0, ba(n2) - ba(t2)) + 1;
        }
        function Da() {
          return new qa();
        }
        function qa() {
          this.reset();
        }
        Ca({ decimal: ".", thousands: ",", grouping: [3], currency: ["$", ""] }), qa.prototype = { constructor: qa, reset: function() {
          this.s = this.t = 0;
        }, add: function(t2) {
          Ua(La, t2, this.t), Ua(this, La.s, this.s), this.s ? this.t += La.t : this.s = La.t;
        }, valueOf: function() {
          return this.s;
        } };
        var La = new qa();
        function Ua(t2, n2, e2) {
          var r2 = t2.s = n2 + e2, i2 = r2 - n2, o2 = r2 - i2;
          t2.t = n2 - o2 + (e2 - i2);
        }
        var Oa = 1e-6, Ba = 1e-12, Ya = Math.PI, Fa = Ya / 2, Ia = Ya / 4, ja = 2 * Ya, Ha = 180 / Ya, Xa = Ya / 180, Ga = Math.abs, Va = Math.atan, $a = Math.atan2, Wa = Math.cos, Za = Math.ceil, Qa = Math.exp, Ja = Math.log, Ka = Math.pow, tu = Math.sin, nu = Math.sign || function(t2) {
          return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
        }, eu = Math.sqrt, ru = Math.tan;
        function iu(t2) {
          return t2 > 1 ? 0 : t2 < -1 ? Ya : Math.acos(t2);
        }
        function ou(t2) {
          return t2 > 1 ? Fa : t2 < -1 ? -Fa : Math.asin(t2);
        }
        function au(t2) {
          return (t2 = tu(t2 / 2)) * t2;
        }
        function uu() {
        }
        function cu(t2, n2) {
          t2 && su.hasOwnProperty(t2.type) && su[t2.type](t2, n2);
        }
        var fu = { Feature: function(t2, n2) {
          cu(t2.geometry, n2);
        }, FeatureCollection: function(t2, n2) {
          for (var e2 = t2.features, r2 = -1, i2 = e2.length; ++r2 < i2; )
            cu(e2[r2].geometry, n2);
        } }, su = { Sphere: function(t2, n2) {
          n2.sphere();
        }, Point: function(t2, n2) {
          t2 = t2.coordinates, n2.point(t2[0], t2[1], t2[2]);
        }, MultiPoint: function(t2, n2) {
          for (var e2 = t2.coordinates, r2 = -1, i2 = e2.length; ++r2 < i2; )
            t2 = e2[r2], n2.point(t2[0], t2[1], t2[2]);
        }, LineString: function(t2, n2) {
          lu(t2.coordinates, n2, 0);
        }, MultiLineString: function(t2, n2) {
          for (var e2 = t2.coordinates, r2 = -1, i2 = e2.length; ++r2 < i2; )
            lu(e2[r2], n2, 0);
        }, Polygon: function(t2, n2) {
          hu(t2.coordinates, n2);
        }, MultiPolygon: function(t2, n2) {
          for (var e2 = t2.coordinates, r2 = -1, i2 = e2.length; ++r2 < i2; )
            hu(e2[r2], n2);
        }, GeometryCollection: function(t2, n2) {
          for (var e2 = t2.geometries, r2 = -1, i2 = e2.length; ++r2 < i2; )
            cu(e2[r2], n2);
        } };
        function lu(t2, n2, e2) {
          var r2, i2 = -1, o2 = t2.length - e2;
          for (n2.lineStart(); ++i2 < o2; )
            r2 = t2[i2], n2.point(r2[0], r2[1], r2[2]);
          n2.lineEnd();
        }
        function hu(t2, n2) {
          var e2 = -1, r2 = t2.length;
          for (n2.polygonStart(); ++e2 < r2; )
            lu(t2[e2], n2, 1);
          n2.polygonEnd();
        }
        function du(t2, n2) {
          t2 && fu.hasOwnProperty(t2.type) ? fu[t2.type](t2, n2) : cu(t2, n2);
        }
        var pu, vu, gu, yu, _u, bu = Da(), mu = Da(), xu = { point: uu, lineStart: uu, lineEnd: uu, polygonStart: function() {
          bu.reset(), xu.lineStart = wu, xu.lineEnd = Mu;
        }, polygonEnd: function() {
          var t2 = +bu;
          mu.add(t2 < 0 ? ja + t2 : t2), this.lineStart = this.lineEnd = this.point = uu;
        }, sphere: function() {
          mu.add(ja);
        } };
        function wu() {
          xu.point = Nu;
        }
        function Mu() {
          Au(pu, vu);
        }
        function Nu(t2, n2) {
          xu.point = Au, pu = t2, vu = n2, gu = t2 *= Xa, yu = Wa(n2 = (n2 *= Xa) / 2 + Ia), _u = tu(n2);
        }
        function Au(t2, n2) {
          var e2 = (t2 *= Xa) - gu, r2 = e2 >= 0 ? 1 : -1, i2 = r2 * e2, o2 = Wa(n2 = (n2 *= Xa) / 2 + Ia), a2 = tu(n2), u2 = _u * a2, c2 = yu * o2 + u2 * Wa(i2), f2 = u2 * r2 * tu(i2);
          bu.add($a(f2, c2)), gu = t2, yu = o2, _u = a2;
        }
        function Tu(t2) {
          return [$a(t2[1], t2[0]), ou(t2[2])];
        }
        function Su(t2) {
          var n2 = t2[0], e2 = t2[1], r2 = Wa(e2);
          return [r2 * Wa(n2), r2 * tu(n2), tu(e2)];
        }
        function ku(t2, n2) {
          return t2[0] * n2[0] + t2[1] * n2[1] + t2[2] * n2[2];
        }
        function Eu(t2, n2) {
          return [t2[1] * n2[2] - t2[2] * n2[1], t2[2] * n2[0] - t2[0] * n2[2], t2[0] * n2[1] - t2[1] * n2[0]];
        }
        function Cu(t2, n2) {
          t2[0] += n2[0], t2[1] += n2[1], t2[2] += n2[2];
        }
        function Pu(t2, n2) {
          return [t2[0] * n2, t2[1] * n2, t2[2] * n2];
        }
        function zu(t2) {
          var n2 = eu(t2[0] * t2[0] + t2[1] * t2[1] + t2[2] * t2[2]);
          t2[0] /= n2, t2[1] /= n2, t2[2] /= n2;
        }
        var Ru, Du, qu, Lu, Uu, Ou, Bu, Yu, Fu, Iu, ju, Hu, Xu, Gu, Vu, $u, Wu, Zu, Qu, Ju, Ku, tc, nc, ec, rc, ic, oc = Da(), ac = { point: uc, lineStart: fc, lineEnd: sc, polygonStart: function() {
          ac.point = lc, ac.lineStart = hc, ac.lineEnd = dc, oc.reset(), xu.polygonStart();
        }, polygonEnd: function() {
          xu.polygonEnd(), ac.point = uc, ac.lineStart = fc, ac.lineEnd = sc, bu < 0 ? (Ru = -(qu = 180), Du = -(Lu = 90)) : oc > Oa ? Lu = 90 : oc < -Oa && (Du = -90), Iu[0] = Ru, Iu[1] = qu;
        } };
        function uc(t2, n2) {
          Fu.push(Iu = [Ru = t2, qu = t2]), n2 < Du && (Du = n2), n2 > Lu && (Lu = n2);
        }
        function cc(t2, n2) {
          var e2 = Su([t2 * Xa, n2 * Xa]);
          if (Yu) {
            var r2 = Eu(Yu, e2), i2 = Eu([r2[1], -r2[0], 0], r2);
            zu(i2), i2 = Tu(i2);
            var o2, a2 = t2 - Uu, u2 = a2 > 0 ? 1 : -1, c2 = i2[0] * Ha * u2, f2 = Ga(a2) > 180;
            f2 ^ (u2 * Uu < c2 && c2 < u2 * t2) ? (o2 = i2[1] * Ha) > Lu && (Lu = o2) : f2 ^ (u2 * Uu < (c2 = (c2 + 360) % 360 - 180) && c2 < u2 * t2) ? (o2 = -i2[1] * Ha) < Du && (Du = o2) : (n2 < Du && (Du = n2), n2 > Lu && (Lu = n2)), f2 ? t2 < Uu ? pc(Ru, t2) > pc(Ru, qu) && (qu = t2) : pc(t2, qu) > pc(Ru, qu) && (Ru = t2) : qu >= Ru ? (t2 < Ru && (Ru = t2), t2 > qu && (qu = t2)) : t2 > Uu ? pc(Ru, t2) > pc(Ru, qu) && (qu = t2) : pc(t2, qu) > pc(Ru, qu) && (Ru = t2);
          } else
            Fu.push(Iu = [Ru = t2, qu = t2]);
          n2 < Du && (Du = n2), n2 > Lu && (Lu = n2), Yu = e2, Uu = t2;
        }
        function fc() {
          ac.point = cc;
        }
        function sc() {
          Iu[0] = Ru, Iu[1] = qu, ac.point = uc, Yu = null;
        }
        function lc(t2, n2) {
          if (Yu) {
            var e2 = t2 - Uu;
            oc.add(Ga(e2) > 180 ? e2 + (e2 > 0 ? 360 : -360) : e2);
          } else
            Ou = t2, Bu = n2;
          xu.point(t2, n2), cc(t2, n2);
        }
        function hc() {
          xu.lineStart();
        }
        function dc() {
          lc(Ou, Bu), xu.lineEnd(), Ga(oc) > Oa && (Ru = -(qu = 180)), Iu[0] = Ru, Iu[1] = qu, Yu = null;
        }
        function pc(t2, n2) {
          return (n2 -= t2) < 0 ? n2 + 360 : n2;
        }
        function vc(t2, n2) {
          return t2[0] - n2[0];
        }
        function gc(t2, n2) {
          return t2[0] <= t2[1] ? t2[0] <= n2 && n2 <= t2[1] : n2 < t2[0] || t2[1] < n2;
        }
        var yc = { sphere: uu, point: _c, lineStart: mc, lineEnd: Mc, polygonStart: function() {
          yc.lineStart = Nc, yc.lineEnd = Ac;
        }, polygonEnd: function() {
          yc.lineStart = mc, yc.lineEnd = Mc;
        } };
        function _c(t2, n2) {
          t2 *= Xa;
          var e2 = Wa(n2 *= Xa);
          bc(e2 * Wa(t2), e2 * tu(t2), tu(n2));
        }
        function bc(t2, n2, e2) {
          Xu += (t2 - Xu) / ++ju, Gu += (n2 - Gu) / ju, Vu += (e2 - Vu) / ju;
        }
        function mc() {
          yc.point = xc;
        }
        function xc(t2, n2) {
          t2 *= Xa;
          var e2 = Wa(n2 *= Xa);
          ec = e2 * Wa(t2), rc = e2 * tu(t2), ic = tu(n2), yc.point = wc, bc(ec, rc, ic);
        }
        function wc(t2, n2) {
          t2 *= Xa;
          var e2 = Wa(n2 *= Xa), r2 = e2 * Wa(t2), i2 = e2 * tu(t2), o2 = tu(n2), a2 = $a(eu((a2 = rc * o2 - ic * i2) * a2 + (a2 = ic * r2 - ec * o2) * a2 + (a2 = ec * i2 - rc * r2) * a2), ec * r2 + rc * i2 + ic * o2);
          Hu += a2, $u += a2 * (ec + (ec = r2)), Wu += a2 * (rc + (rc = i2)), Zu += a2 * (ic + (ic = o2)), bc(ec, rc, ic);
        }
        function Mc() {
          yc.point = _c;
        }
        function Nc() {
          yc.point = Tc;
        }
        function Ac() {
          Sc(tc, nc), yc.point = _c;
        }
        function Tc(t2, n2) {
          tc = t2, nc = n2, t2 *= Xa, n2 *= Xa, yc.point = Sc;
          var e2 = Wa(n2);
          ec = e2 * Wa(t2), rc = e2 * tu(t2), ic = tu(n2), bc(ec, rc, ic);
        }
        function Sc(t2, n2) {
          t2 *= Xa;
          var e2 = Wa(n2 *= Xa), r2 = e2 * Wa(t2), i2 = e2 * tu(t2), o2 = tu(n2), a2 = rc * o2 - ic * i2, u2 = ic * r2 - ec * o2, c2 = ec * i2 - rc * r2, f2 = eu(a2 * a2 + u2 * u2 + c2 * c2), s2 = ou(f2), l2 = f2 && -s2 / f2;
          Qu += l2 * a2, Ju += l2 * u2, Ku += l2 * c2, Hu += s2, $u += s2 * (ec + (ec = r2)), Wu += s2 * (rc + (rc = i2)), Zu += s2 * (ic + (ic = o2)), bc(ec, rc, ic);
        }
        function kc(t2) {
          return function() {
            return t2;
          };
        }
        function Ec(t2, n2) {
          function e2(e3, r2) {
            return e3 = t2(e3, r2), n2(e3[0], e3[1]);
          }
          return t2.invert && n2.invert && (e2.invert = function(e3, r2) {
            return (e3 = n2.invert(e3, r2)) && t2.invert(e3[0], e3[1]);
          }), e2;
        }
        function Cc(t2, n2) {
          return [Ga(t2) > Ya ? t2 + Math.round(-t2 / ja) * ja : t2, n2];
        }
        function Pc(t2, n2, e2) {
          return (t2 %= ja) ? n2 || e2 ? Ec(Rc(t2), Dc(n2, e2)) : Rc(t2) : n2 || e2 ? Dc(n2, e2) : Cc;
        }
        function zc(t2) {
          return function(n2, e2) {
            return [(n2 += t2) > Ya ? n2 - ja : n2 < -Ya ? n2 + ja : n2, e2];
          };
        }
        function Rc(t2) {
          var n2 = zc(t2);
          return n2.invert = zc(-t2), n2;
        }
        function Dc(t2, n2) {
          var e2 = Wa(t2), r2 = tu(t2), i2 = Wa(n2), o2 = tu(n2);
          function a2(t3, n3) {
            var a3 = Wa(n3), u2 = Wa(t3) * a3, c2 = tu(t3) * a3, f2 = tu(n3), s2 = f2 * e2 + u2 * r2;
            return [$a(c2 * i2 - s2 * o2, u2 * e2 - f2 * r2), ou(s2 * i2 + c2 * o2)];
          }
          return a2.invert = function(t3, n3) {
            var a3 = Wa(n3), u2 = Wa(t3) * a3, c2 = tu(t3) * a3, f2 = tu(n3), s2 = f2 * i2 - c2 * o2;
            return [$a(c2 * i2 + f2 * o2, u2 * e2 + s2 * r2), ou(s2 * e2 - u2 * r2)];
          }, a2;
        }
        function qc(t2) {
          function n2(n3) {
            return (n3 = t2(n3[0] * Xa, n3[1] * Xa))[0] *= Ha, n3[1] *= Ha, n3;
          }
          return t2 = Pc(t2[0] * Xa, t2[1] * Xa, t2.length > 2 ? t2[2] * Xa : 0), n2.invert = function(n3) {
            return (n3 = t2.invert(n3[0] * Xa, n3[1] * Xa))[0] *= Ha, n3[1] *= Ha, n3;
          }, n2;
        }
        function Lc(t2, n2, e2, r2, i2, o2) {
          if (e2) {
            var a2 = Wa(n2), u2 = tu(n2), c2 = r2 * e2;
            null == i2 ? (i2 = n2 + r2 * ja, o2 = n2 - c2 / 2) : (i2 = Uc(a2, i2), o2 = Uc(a2, o2), (r2 > 0 ? i2 < o2 : i2 > o2) && (i2 += r2 * ja));
            for (var f2, s2 = i2; r2 > 0 ? s2 > o2 : s2 < o2; s2 -= c2)
              f2 = Tu([a2, -u2 * Wa(s2), -u2 * tu(s2)]), t2.point(f2[0], f2[1]);
          }
        }
        function Uc(t2, n2) {
          (n2 = Su(n2))[0] -= t2, zu(n2);
          var e2 = iu(-n2[1]);
          return ((-n2[2] < 0 ? -e2 : e2) + ja - Oa) % ja;
        }
        function Oc() {
          var t2, n2 = [];
          return { point: function(n3, e2) {
            t2.push([n3, e2]);
          }, lineStart: function() {
            n2.push(t2 = []);
          }, lineEnd: uu, rejoin: function() {
            n2.length > 1 && n2.push(n2.pop().concat(n2.shift()));
          }, result: function() {
            var e2 = n2;
            return n2 = [], t2 = null, e2;
          } };
        }
        function Bc(t2, n2) {
          return Ga(t2[0] - n2[0]) < Oa && Ga(t2[1] - n2[1]) < Oa;
        }
        function Yc(t2, n2, e2, r2) {
          this.x = t2, this.z = n2, this.o = e2, this.e = r2, this.v = false, this.n = this.p = null;
        }
        function Fc(t2, n2, e2, r2, i2) {
          var o2, a2, u2 = [], c2 = [];
          if (t2.forEach(function(t3) {
            if (!((n3 = t3.length - 1) <= 0)) {
              var n3, e3, r3 = t3[0], a3 = t3[n3];
              if (Bc(r3, a3)) {
                for (i2.lineStart(), o2 = 0; o2 < n3; ++o2)
                  i2.point((r3 = t3[o2])[0], r3[1]);
                i2.lineEnd();
              } else
                u2.push(e3 = new Yc(r3, t3, null, true)), c2.push(e3.o = new Yc(r3, null, e3, false)), u2.push(e3 = new Yc(a3, t3, null, false)), c2.push(e3.o = new Yc(a3, null, e3, true));
            }
          }), u2.length) {
            for (c2.sort(n2), Ic(u2), Ic(c2), o2 = 0, a2 = c2.length; o2 < a2; ++o2)
              c2[o2].e = e2 = !e2;
            for (var f2, s2, l2 = u2[0]; ; ) {
              for (var h2 = l2, d2 = true; h2.v; )
                if ((h2 = h2.n) === l2)
                  return;
              f2 = h2.z, i2.lineStart();
              do {
                if (h2.v = h2.o.v = true, h2.e) {
                  if (d2)
                    for (o2 = 0, a2 = f2.length; o2 < a2; ++o2)
                      i2.point((s2 = f2[o2])[0], s2[1]);
                  else
                    r2(h2.x, h2.n.x, 1, i2);
                  h2 = h2.n;
                } else {
                  if (d2)
                    for (f2 = h2.p.z, o2 = f2.length - 1; o2 >= 0; --o2)
                      i2.point((s2 = f2[o2])[0], s2[1]);
                  else
                    r2(h2.x, h2.p.x, -1, i2);
                  h2 = h2.p;
                }
                f2 = (h2 = h2.o).z, d2 = !d2;
              } while (!h2.v);
              i2.lineEnd();
            }
          }
        }
        function Ic(t2) {
          if (n2 = t2.length) {
            for (var n2, e2, r2 = 0, i2 = t2[0]; ++r2 < n2; )
              i2.n = e2 = t2[r2], e2.p = i2, i2 = e2;
            i2.n = e2 = t2[0], e2.p = i2;
          }
        }
        Cc.invert = Cc;
        var jc = Da();
        function Hc(t2, n2) {
          var e2 = n2[0], r2 = n2[1], i2 = tu(r2), o2 = [tu(e2), -Wa(e2), 0], a2 = 0, u2 = 0;
          jc.reset(), 1 === i2 ? r2 = Fa + Oa : -1 === i2 && (r2 = -Fa - Oa);
          for (var c2 = 0, f2 = t2.length; c2 < f2; ++c2)
            if (l2 = (s2 = t2[c2]).length)
              for (var s2, l2, h2 = s2[l2 - 1], d2 = h2[0], p2 = h2[1] / 2 + Ia, v2 = tu(p2), g2 = Wa(p2), y2 = 0; y2 < l2; ++y2, d2 = b2, v2 = x2, g2 = w2, h2 = _2) {
                var _2 = s2[y2], b2 = _2[0], m2 = _2[1] / 2 + Ia, x2 = tu(m2), w2 = Wa(m2), M2 = b2 - d2, N2 = M2 >= 0 ? 1 : -1, A2 = N2 * M2, T2 = A2 > Ya, S2 = v2 * x2;
                if (jc.add($a(S2 * N2 * tu(A2), g2 * w2 + S2 * Wa(A2))), a2 += T2 ? M2 + N2 * ja : M2, T2 ^ d2 >= e2 ^ b2 >= e2) {
                  var k2 = Eu(Su(h2), Su(_2));
                  zu(k2);
                  var E2 = Eu(o2, k2);
                  zu(E2);
                  var C2 = (T2 ^ M2 >= 0 ? -1 : 1) * ou(E2[2]);
                  (r2 > C2 || r2 === C2 && (k2[0] || k2[1])) && (u2 += T2 ^ M2 >= 0 ? 1 : -1);
                }
              }
          return (a2 < -Oa || a2 < Oa && jc < -Oa) ^ 1 & u2;
        }
        function Xc(t2, n2, e2, r2) {
          return function(i2) {
            var o2, a2, u2, c2 = n2(i2), f2 = Oc(), s2 = n2(f2), l2 = false, h2 = { point: d2, lineStart: v2, lineEnd: g2, polygonStart: function() {
              h2.point = y2, h2.lineStart = _2, h2.lineEnd = b2, a2 = [], o2 = [];
            }, polygonEnd: function() {
              h2.point = d2, h2.lineStart = v2, h2.lineEnd = g2, a2 = T(a2);
              var t3 = Hc(o2, r2);
              a2.length ? (l2 || (i2.polygonStart(), l2 = true), Fc(a2, Vc, t3, e2, i2)) : t3 && (l2 || (i2.polygonStart(), l2 = true), i2.lineStart(), e2(null, null, 1, i2), i2.lineEnd()), l2 && (i2.polygonEnd(), l2 = false), a2 = o2 = null;
            }, sphere: function() {
              i2.polygonStart(), i2.lineStart(), e2(null, null, 1, i2), i2.lineEnd(), i2.polygonEnd();
            } };
            function d2(n3, e3) {
              t2(n3, e3) && i2.point(n3, e3);
            }
            function p2(t3, n3) {
              c2.point(t3, n3);
            }
            function v2() {
              h2.point = p2, c2.lineStart();
            }
            function g2() {
              h2.point = d2, c2.lineEnd();
            }
            function y2(t3, n3) {
              u2.push([t3, n3]), s2.point(t3, n3);
            }
            function _2() {
              s2.lineStart(), u2 = [];
            }
            function b2() {
              y2(u2[0][0], u2[0][1]), s2.lineEnd();
              var t3, n3, e3, r3, c3 = s2.clean(), h3 = f2.result(), d4 = h3.length;
              if (u2.pop(), o2.push(u2), u2 = null, d4)
                if (1 & c3) {
                  if ((n3 = (e3 = h3[0]).length - 1) > 0) {
                    for (l2 || (i2.polygonStart(), l2 = true), i2.lineStart(), t3 = 0; t3 < n3; ++t3)
                      i2.point((r3 = e3[t3])[0], r3[1]);
                    i2.lineEnd();
                  }
                } else
                  d4 > 1 && 2 & c3 && h3.push(h3.pop().concat(h3.shift())), a2.push(h3.filter(Gc));
            }
            return h2;
          };
        }
        function Gc(t2) {
          return t2.length > 1;
        }
        function Vc(t2, n2) {
          return ((t2 = t2.x)[0] < 0 ? t2[1] - Fa - Oa : Fa - t2[1]) - ((n2 = n2.x)[0] < 0 ? n2[1] - Fa - Oa : Fa - n2[1]);
        }
        var $c = Xc(function() {
          return true;
        }, function(t2) {
          var n2, e2 = NaN, r2 = NaN, i2 = NaN;
          return { lineStart: function() {
            t2.lineStart(), n2 = 1;
          }, point: function(o2, a2) {
            var u2 = o2 > 0 ? Ya : -Ya, c2 = Ga(o2 - e2);
            Ga(c2 - Ya) < Oa ? (t2.point(e2, r2 = (r2 + a2) / 2 > 0 ? Fa : -Fa), t2.point(i2, r2), t2.lineEnd(), t2.lineStart(), t2.point(u2, r2), t2.point(o2, r2), n2 = 0) : i2 !== u2 && c2 >= Ya && (Ga(e2 - i2) < Oa && (e2 -= i2 * Oa), Ga(o2 - u2) < Oa && (o2 -= u2 * Oa), r2 = function(t3, n3, e3, r3) {
              var i3, o3, a3 = tu(t3 - e3);
              return Ga(a3) > Oa ? Va((tu(n3) * (o3 = Wa(r3)) * tu(e3) - tu(r3) * (i3 = Wa(n3)) * tu(t3)) / (i3 * o3 * a3)) : (n3 + r3) / 2;
            }(e2, r2, o2, a2), t2.point(i2, r2), t2.lineEnd(), t2.lineStart(), t2.point(u2, r2), n2 = 0), t2.point(e2 = o2, r2 = a2), i2 = u2;
          }, lineEnd: function() {
            t2.lineEnd(), e2 = r2 = NaN;
          }, clean: function() {
            return 2 - n2;
          } };
        }, function(t2, n2, e2, r2) {
          var i2;
          if (null == t2)
            i2 = e2 * Fa, r2.point(-Ya, i2), r2.point(0, i2), r2.point(Ya, i2), r2.point(Ya, 0), r2.point(Ya, -i2), r2.point(0, -i2), r2.point(-Ya, -i2), r2.point(-Ya, 0), r2.point(-Ya, i2);
          else if (Ga(t2[0] - n2[0]) > Oa) {
            var o2 = t2[0] < n2[0] ? Ya : -Ya;
            i2 = e2 * o2 / 2, r2.point(-o2, i2), r2.point(0, i2), r2.point(o2, i2);
          } else
            r2.point(n2[0], n2[1]);
        }, [-Ya, -Fa]);
        function Wc(t2) {
          var n2 = Wa(t2), e2 = 6 * Xa, r2 = n2 > 0, i2 = Ga(n2) > Oa;
          function o2(t3, e3) {
            return Wa(t3) * Wa(e3) > n2;
          }
          function a2(t3, e3, r3) {
            var i3 = [1, 0, 0], o3 = Eu(Su(t3), Su(e3)), a3 = ku(o3, o3), u3 = o3[0], c2 = a3 - u3 * u3;
            if (!c2)
              return !r3 && t3;
            var f2 = n2 * a3 / c2, s2 = -n2 * u3 / c2, l2 = Eu(i3, o3), h2 = Pu(i3, f2);
            Cu(h2, Pu(o3, s2));
            var d2 = l2, p2 = ku(h2, d2), v2 = ku(d2, d2), g2 = p2 * p2 - v2 * (ku(h2, h2) - 1);
            if (!(g2 < 0)) {
              var y2 = eu(g2), _2 = Pu(d2, (-p2 - y2) / v2);
              if (Cu(_2, h2), _2 = Tu(_2), !r3)
                return _2;
              var b2, m2 = t3[0], x2 = e3[0], w2 = t3[1], M2 = e3[1];
              x2 < m2 && (b2 = m2, m2 = x2, x2 = b2);
              var N2 = x2 - m2, A2 = Ga(N2 - Ya) < Oa;
              if (!A2 && M2 < w2 && (b2 = w2, w2 = M2, M2 = b2), A2 || N2 < Oa ? A2 ? w2 + M2 > 0 ^ _2[1] < (Ga(_2[0] - m2) < Oa ? w2 : M2) : w2 <= _2[1] && _2[1] <= M2 : N2 > Ya ^ (m2 <= _2[0] && _2[0] <= x2)) {
                var T2 = Pu(d2, (-p2 + y2) / v2);
                return Cu(T2, h2), [_2, Tu(T2)];
              }
            }
          }
          function u2(n3, e3) {
            var i3 = r2 ? t2 : Ya - t2, o3 = 0;
            return n3 < -i3 ? o3 |= 1 : n3 > i3 && (o3 |= 2), e3 < -i3 ? o3 |= 4 : e3 > i3 && (o3 |= 8), o3;
          }
          return Xc(o2, function(t3) {
            var n3, e3, c2, f2, s2;
            return { lineStart: function() {
              f2 = c2 = false, s2 = 1;
            }, point: function(l2, h2) {
              var d2, p2 = [l2, h2], v2 = o2(l2, h2), g2 = r2 ? v2 ? 0 : u2(l2, h2) : v2 ? u2(l2 + (l2 < 0 ? Ya : -Ya), h2) : 0;
              if (!n3 && (f2 = c2 = v2) && t3.lineStart(), v2 !== c2 && (!(d2 = a2(n3, p2)) || Bc(n3, d2) || Bc(p2, d2)) && (p2[0] += Oa, p2[1] += Oa, v2 = o2(p2[0], p2[1])), v2 !== c2)
                s2 = 0, v2 ? (t3.lineStart(), d2 = a2(p2, n3), t3.point(d2[0], d2[1])) : (d2 = a2(n3, p2), t3.point(d2[0], d2[1]), t3.lineEnd()), n3 = d2;
              else if (i2 && n3 && r2 ^ v2) {
                var y2;
                g2 & e3 || !(y2 = a2(p2, n3, true)) || (s2 = 0, r2 ? (t3.lineStart(), t3.point(y2[0][0], y2[0][1]), t3.point(y2[1][0], y2[1][1]), t3.lineEnd()) : (t3.point(y2[1][0], y2[1][1]), t3.lineEnd(), t3.lineStart(), t3.point(y2[0][0], y2[0][1])));
              }
              !v2 || n3 && Bc(n3, p2) || t3.point(p2[0], p2[1]), n3 = p2, c2 = v2, e3 = g2;
            }, lineEnd: function() {
              c2 && t3.lineEnd(), n3 = null;
            }, clean: function() {
              return s2 | (f2 && c2) << 1;
            } };
          }, function(n3, r3, i3, o3) {
            Lc(o3, t2, e2, i3, n3, r3);
          }, r2 ? [0, -t2] : [-Ya, t2 - Ya]);
        }
        var Zc = 1e9, Qc = -Zc;
        function Jc(t2, n2, e2, r2) {
          function i2(i3, o3) {
            return t2 <= i3 && i3 <= e2 && n2 <= o3 && o3 <= r2;
          }
          function o2(i3, o3, u3, f2) {
            var s2 = 0, l2 = 0;
            if (null == i3 || (s2 = a2(i3, u3)) !== (l2 = a2(o3, u3)) || c2(i3, o3) < 0 ^ u3 > 0)
              do {
                f2.point(0 === s2 || 3 === s2 ? t2 : e2, s2 > 1 ? r2 : n2);
              } while ((s2 = (s2 + u3 + 4) % 4) !== l2);
            else
              f2.point(o3[0], o3[1]);
          }
          function a2(r3, i3) {
            return Ga(r3[0] - t2) < Oa ? i3 > 0 ? 0 : 3 : Ga(r3[0] - e2) < Oa ? i3 > 0 ? 2 : 1 : Ga(r3[1] - n2) < Oa ? i3 > 0 ? 1 : 0 : i3 > 0 ? 3 : 2;
          }
          function u2(t3, n3) {
            return c2(t3.x, n3.x);
          }
          function c2(t3, n3) {
            var e3 = a2(t3, 1), r3 = a2(n3, 1);
            return e3 !== r3 ? e3 - r3 : 0 === e3 ? n3[1] - t3[1] : 1 === e3 ? t3[0] - n3[0] : 2 === e3 ? t3[1] - n3[1] : n3[0] - t3[0];
          }
          return function(a3) {
            var c3, f2, s2, l2, h2, d2, p2, v2, g2, y2, _2, b2 = a3, m2 = Oc(), x2 = { point: w2, lineStart: function() {
              x2.point = M2, f2 && f2.push(s2 = []);
              y2 = true, g2 = false, p2 = v2 = NaN;
            }, lineEnd: function() {
              c3 && (M2(l2, h2), d2 && g2 && m2.rejoin(), c3.push(m2.result()));
              x2.point = w2, g2 && b2.lineEnd();
            }, polygonStart: function() {
              b2 = m2, c3 = [], f2 = [], _2 = true;
            }, polygonEnd: function() {
              var n3 = function() {
                for (var n4 = 0, e4 = 0, i4 = f2.length; e4 < i4; ++e4)
                  for (var o3, a4, u3 = f2[e4], c4 = 1, s3 = u3.length, l3 = u3[0], h3 = l3[0], d4 = l3[1]; c4 < s3; ++c4)
                    o3 = h3, a4 = d4, l3 = u3[c4], h3 = l3[0], d4 = l3[1], a4 <= r2 ? d4 > r2 && (h3 - o3) * (r2 - a4) > (d4 - a4) * (t2 - o3) && ++n4 : d4 <= r2 && (h3 - o3) * (r2 - a4) < (d4 - a4) * (t2 - o3) && --n4;
                return n4;
              }(), e3 = _2 && n3, i3 = (c3 = T(c3)).length;
              (e3 || i3) && (a3.polygonStart(), e3 && (a3.lineStart(), o2(null, null, 1, a3), a3.lineEnd()), i3 && Fc(c3, u2, n3, o2, a3), a3.polygonEnd());
              b2 = a3, c3 = f2 = s2 = null;
            } };
            function w2(t3, n3) {
              i2(t3, n3) && b2.point(t3, n3);
            }
            function M2(o3, a4) {
              var u3 = i2(o3, a4);
              if (f2 && s2.push([o3, a4]), y2)
                l2 = o3, h2 = a4, d2 = u3, y2 = false, u3 && (b2.lineStart(), b2.point(o3, a4));
              else if (u3 && g2)
                b2.point(o3, a4);
              else {
                var c4 = [p2 = Math.max(Qc, Math.min(Zc, p2)), v2 = Math.max(Qc, Math.min(Zc, v2))], m3 = [o3 = Math.max(Qc, Math.min(Zc, o3)), a4 = Math.max(Qc, Math.min(Zc, a4))];
                !function(t3, n3, e3, r3, i3, o4) {
                  var a5, u4 = t3[0], c5 = t3[1], f3 = 0, s3 = 1, l3 = n3[0] - u4, h3 = n3[1] - c5;
                  if (a5 = e3 - u4, l3 || !(a5 > 0)) {
                    if (a5 /= l3, l3 < 0) {
                      if (a5 < f3)
                        return;
                      a5 < s3 && (s3 = a5);
                    } else if (l3 > 0) {
                      if (a5 > s3)
                        return;
                      a5 > f3 && (f3 = a5);
                    }
                    if (a5 = i3 - u4, l3 || !(a5 < 0)) {
                      if (a5 /= l3, l3 < 0) {
                        if (a5 > s3)
                          return;
                        a5 > f3 && (f3 = a5);
                      } else if (l3 > 0) {
                        if (a5 < f3)
                          return;
                        a5 < s3 && (s3 = a5);
                      }
                      if (a5 = r3 - c5, h3 || !(a5 > 0)) {
                        if (a5 /= h3, h3 < 0) {
                          if (a5 < f3)
                            return;
                          a5 < s3 && (s3 = a5);
                        } else if (h3 > 0) {
                          if (a5 > s3)
                            return;
                          a5 > f3 && (f3 = a5);
                        }
                        if (a5 = o4 - c5, h3 || !(a5 < 0)) {
                          if (a5 /= h3, h3 < 0) {
                            if (a5 > s3)
                              return;
                            a5 > f3 && (f3 = a5);
                          } else if (h3 > 0) {
                            if (a5 < f3)
                              return;
                            a5 < s3 && (s3 = a5);
                          }
                          return f3 > 0 && (t3[0] = u4 + f3 * l3, t3[1] = c5 + f3 * h3), s3 < 1 && (n3[0] = u4 + s3 * l3, n3[1] = c5 + s3 * h3), true;
                        }
                      }
                    }
                  }
                }(c4, m3, t2, n2, e2, r2) ? u3 && (b2.lineStart(), b2.point(o3, a4), _2 = false) : (g2 || (b2.lineStart(), b2.point(c4[0], c4[1])), b2.point(m3[0], m3[1]), u3 || b2.lineEnd(), _2 = false);
              }
              p2 = o3, v2 = a4, g2 = u3;
            }
            return x2;
          };
        }
        var Kc, tf, nf, ef = Da(), rf = { sphere: uu, point: uu, lineStart: function() {
          rf.point = af, rf.lineEnd = of;
        }, lineEnd: uu, polygonStart: uu, polygonEnd: uu };
        function of() {
          rf.point = rf.lineEnd = uu;
        }
        function af(t2, n2) {
          Kc = t2 *= Xa, tf = tu(n2 *= Xa), nf = Wa(n2), rf.point = uf;
        }
        function uf(t2, n2) {
          t2 *= Xa;
          var e2 = tu(n2 *= Xa), r2 = Wa(n2), i2 = Ga(t2 - Kc), o2 = Wa(i2), a2 = r2 * tu(i2), u2 = nf * e2 - tf * r2 * o2, c2 = tf * e2 + nf * r2 * o2;
          ef.add($a(eu(a2 * a2 + u2 * u2), c2)), Kc = t2, tf = e2, nf = r2;
        }
        function cf(t2) {
          return ef.reset(), du(t2, rf), +ef;
        }
        var ff = [null, null], sf = { type: "LineString", coordinates: ff };
        function lf(t2, n2) {
          return ff[0] = t2, ff[1] = n2, cf(sf);
        }
        var hf = { Feature: function(t2, n2) {
          return pf(t2.geometry, n2);
        }, FeatureCollection: function(t2, n2) {
          for (var e2 = t2.features, r2 = -1, i2 = e2.length; ++r2 < i2; )
            if (pf(e2[r2].geometry, n2))
              return true;
          return false;
        } }, df = { Sphere: function() {
          return true;
        }, Point: function(t2, n2) {
          return vf(t2.coordinates, n2);
        }, MultiPoint: function(t2, n2) {
          for (var e2 = t2.coordinates, r2 = -1, i2 = e2.length; ++r2 < i2; )
            if (vf(e2[r2], n2))
              return true;
          return false;
        }, LineString: function(t2, n2) {
          return gf(t2.coordinates, n2);
        }, MultiLineString: function(t2, n2) {
          for (var e2 = t2.coordinates, r2 = -1, i2 = e2.length; ++r2 < i2; )
            if (gf(e2[r2], n2))
              return true;
          return false;
        }, Polygon: function(t2, n2) {
          return yf(t2.coordinates, n2);
        }, MultiPolygon: function(t2, n2) {
          for (var e2 = t2.coordinates, r2 = -1, i2 = e2.length; ++r2 < i2; )
            if (yf(e2[r2], n2))
              return true;
          return false;
        }, GeometryCollection: function(t2, n2) {
          for (var e2 = t2.geometries, r2 = -1, i2 = e2.length; ++r2 < i2; )
            if (pf(e2[r2], n2))
              return true;
          return false;
        } };
        function pf(t2, n2) {
          return !(!t2 || !df.hasOwnProperty(t2.type)) && df[t2.type](t2, n2);
        }
        function vf(t2, n2) {
          return 0 === lf(t2, n2);
        }
        function gf(t2, n2) {
          var e2 = lf(t2[0], t2[1]);
          return lf(t2[0], n2) + lf(n2, t2[1]) <= e2 + Oa;
        }
        function yf(t2, n2) {
          return !!Hc(t2.map(_f), bf(n2));
        }
        function _f(t2) {
          return (t2 = t2.map(bf)).pop(), t2;
        }
        function bf(t2) {
          return [t2[0] * Xa, t2[1] * Xa];
        }
        function mf(t2, n2, e2) {
          var r2 = g(t2, n2 - Oa, e2).concat(n2);
          return function(t3) {
            return r2.map(function(n3) {
              return [t3, n3];
            });
          };
        }
        function xf(t2, n2, e2) {
          var r2 = g(t2, n2 - Oa, e2).concat(n2);
          return function(t3) {
            return r2.map(function(n3) {
              return [n3, t3];
            });
          };
        }
        function wf() {
          var t2, n2, e2, r2, i2, o2, a2, u2, c2, f2, s2, l2, h2 = 10, d2 = h2, p2 = 90, v2 = 360, y2 = 2.5;
          function _2() {
            return { type: "MultiLineString", coordinates: b2() };
          }
          function b2() {
            return g(Za(r2 / p2) * p2, e2, p2).map(s2).concat(g(Za(u2 / v2) * v2, a2, v2).map(l2)).concat(g(Za(n2 / h2) * h2, t2, h2).filter(function(t3) {
              return Ga(t3 % p2) > Oa;
            }).map(c2)).concat(g(Za(o2 / d2) * d2, i2, d2).filter(function(t3) {
              return Ga(t3 % v2) > Oa;
            }).map(f2));
          }
          return _2.lines = function() {
            return b2().map(function(t3) {
              return { type: "LineString", coordinates: t3 };
            });
          }, _2.outline = function() {
            return { type: "Polygon", coordinates: [s2(r2).concat(l2(a2).slice(1), s2(e2).reverse().slice(1), l2(u2).reverse().slice(1))] };
          }, _2.extent = function(t3) {
            return arguments.length ? _2.extentMajor(t3).extentMinor(t3) : _2.extentMinor();
          }, _2.extentMajor = function(t3) {
            return arguments.length ? (r2 = +t3[0][0], e2 = +t3[1][0], u2 = +t3[0][1], a2 = +t3[1][1], r2 > e2 && (t3 = r2, r2 = e2, e2 = t3), u2 > a2 && (t3 = u2, u2 = a2, a2 = t3), _2.precision(y2)) : [[r2, u2], [e2, a2]];
          }, _2.extentMinor = function(e3) {
            return arguments.length ? (n2 = +e3[0][0], t2 = +e3[1][0], o2 = +e3[0][1], i2 = +e3[1][1], n2 > t2 && (e3 = n2, n2 = t2, t2 = e3), o2 > i2 && (e3 = o2, o2 = i2, i2 = e3), _2.precision(y2)) : [[n2, o2], [t2, i2]];
          }, _2.step = function(t3) {
            return arguments.length ? _2.stepMajor(t3).stepMinor(t3) : _2.stepMinor();
          }, _2.stepMajor = function(t3) {
            return arguments.length ? (p2 = +t3[0], v2 = +t3[1], _2) : [p2, v2];
          }, _2.stepMinor = function(t3) {
            return arguments.length ? (h2 = +t3[0], d2 = +t3[1], _2) : [h2, d2];
          }, _2.precision = function(h3) {
            return arguments.length ? (y2 = +h3, c2 = mf(o2, i2, 90), f2 = xf(n2, t2, y2), s2 = mf(u2, a2, 90), l2 = xf(r2, e2, y2), _2) : y2;
          }, _2.extentMajor([[-180, -90 + Oa], [180, 90 - Oa]]).extentMinor([[-180, -80 - Oa], [180, 80 + Oa]]);
        }
        function Mf(t2) {
          return t2;
        }
        var Nf, Af, Tf, Sf, kf = Da(), Ef = Da(), Cf = { point: uu, lineStart: uu, lineEnd: uu, polygonStart: function() {
          Cf.lineStart = Pf, Cf.lineEnd = Df;
        }, polygonEnd: function() {
          Cf.lineStart = Cf.lineEnd = Cf.point = uu, kf.add(Ga(Ef)), Ef.reset();
        }, result: function() {
          var t2 = kf / 2;
          return kf.reset(), t2;
        } };
        function Pf() {
          Cf.point = zf;
        }
        function zf(t2, n2) {
          Cf.point = Rf, Nf = Tf = t2, Af = Sf = n2;
        }
        function Rf(t2, n2) {
          Ef.add(Sf * t2 - Tf * n2), Tf = t2, Sf = n2;
        }
        function Df() {
          Rf(Nf, Af);
        }
        var qf = 1 / 0, Lf = qf, Uf = -qf, Of = Uf, Bf = { point: function(t2, n2) {
          t2 < qf && (qf = t2);
          t2 > Uf && (Uf = t2);
          n2 < Lf && (Lf = n2);
          n2 > Of && (Of = n2);
        }, lineStart: uu, lineEnd: uu, polygonStart: uu, polygonEnd: uu, result: function() {
          var t2 = [[qf, Lf], [Uf, Of]];
          return Uf = Of = -(Lf = qf = 1 / 0), t2;
        } };
        var Yf, Ff, If, jf, Hf = 0, Xf = 0, Gf = 0, Vf = 0, $f = 0, Wf = 0, Zf = 0, Qf = 0, Jf = 0, Kf = { point: ts, lineStart: ns, lineEnd: is, polygonStart: function() {
          Kf.lineStart = os, Kf.lineEnd = as;
        }, polygonEnd: function() {
          Kf.point = ts, Kf.lineStart = ns, Kf.lineEnd = is;
        }, result: function() {
          var t2 = Jf ? [Zf / Jf, Qf / Jf] : Wf ? [Vf / Wf, $f / Wf] : Gf ? [Hf / Gf, Xf / Gf] : [NaN, NaN];
          return Hf = Xf = Gf = Vf = $f = Wf = Zf = Qf = Jf = 0, t2;
        } };
        function ts(t2, n2) {
          Hf += t2, Xf += n2, ++Gf;
        }
        function ns() {
          Kf.point = es;
        }
        function es(t2, n2) {
          Kf.point = rs, ts(If = t2, jf = n2);
        }
        function rs(t2, n2) {
          var e2 = t2 - If, r2 = n2 - jf, i2 = eu(e2 * e2 + r2 * r2);
          Vf += i2 * (If + t2) / 2, $f += i2 * (jf + n2) / 2, Wf += i2, ts(If = t2, jf = n2);
        }
        function is() {
          Kf.point = ts;
        }
        function os() {
          Kf.point = us;
        }
        function as() {
          cs(Yf, Ff);
        }
        function us(t2, n2) {
          Kf.point = cs, ts(Yf = If = t2, Ff = jf = n2);
        }
        function cs(t2, n2) {
          var e2 = t2 - If, r2 = n2 - jf, i2 = eu(e2 * e2 + r2 * r2);
          Vf += i2 * (If + t2) / 2, $f += i2 * (jf + n2) / 2, Wf += i2, Zf += (i2 = jf * t2 - If * n2) * (If + t2), Qf += i2 * (jf + n2), Jf += 3 * i2, ts(If = t2, jf = n2);
        }
        function fs(t2) {
          this._context = t2;
        }
        fs.prototype = { _radius: 4.5, pointRadius: function(t2) {
          return this._radius = t2, this;
        }, polygonStart: function() {
          this._line = 0;
        }, polygonEnd: function() {
          this._line = NaN;
        }, lineStart: function() {
          this._point = 0;
        }, lineEnd: function() {
          0 === this._line && this._context.closePath(), this._point = NaN;
        }, point: function(t2, n2) {
          switch (this._point) {
            case 0:
              this._context.moveTo(t2, n2), this._point = 1;
              break;
            case 1:
              this._context.lineTo(t2, n2);
              break;
            default:
              this._context.moveTo(t2 + this._radius, n2), this._context.arc(t2, n2, this._radius, 0, ja);
          }
        }, result: uu };
        var ss, ls, hs, ds, ps, vs = Da(), gs = { point: uu, lineStart: function() {
          gs.point = ys;
        }, lineEnd: function() {
          ss && _s(ls, hs), gs.point = uu;
        }, polygonStart: function() {
          ss = true;
        }, polygonEnd: function() {
          ss = null;
        }, result: function() {
          var t2 = +vs;
          return vs.reset(), t2;
        } };
        function ys(t2, n2) {
          gs.point = _s, ls = ds = t2, hs = ps = n2;
        }
        function _s(t2, n2) {
          ds -= t2, ps -= n2, vs.add(eu(ds * ds + ps * ps)), ds = t2, ps = n2;
        }
        function bs() {
          this._string = [];
        }
        function ms(t2) {
          return "m0," + t2 + "a" + t2 + "," + t2 + " 0 1,1 0," + -2 * t2 + "a" + t2 + "," + t2 + " 0 1,1 0," + 2 * t2 + "z";
        }
        function xs(t2) {
          return function(n2) {
            var e2 = new ws();
            for (var r2 in t2)
              e2[r2] = t2[r2];
            return e2.stream = n2, e2;
          };
        }
        function ws() {
        }
        function Ms(t2, n2, e2) {
          var r2 = t2.clipExtent && t2.clipExtent();
          return t2.scale(150).translate([0, 0]), null != r2 && t2.clipExtent(null), du(e2, t2.stream(Bf)), n2(Bf.result()), null != r2 && t2.clipExtent(r2), t2;
        }
        function Ns(t2, n2, e2) {
          return Ms(t2, function(e3) {
            var r2 = n2[1][0] - n2[0][0], i2 = n2[1][1] - n2[0][1], o2 = Math.min(r2 / (e3[1][0] - e3[0][0]), i2 / (e3[1][1] - e3[0][1])), a2 = +n2[0][0] + (r2 - o2 * (e3[1][0] + e3[0][0])) / 2, u2 = +n2[0][1] + (i2 - o2 * (e3[1][1] + e3[0][1])) / 2;
            t2.scale(150 * o2).translate([a2, u2]);
          }, e2);
        }
        function As(t2, n2, e2) {
          return Ns(t2, [[0, 0], n2], e2);
        }
        function Ts(t2, n2, e2) {
          return Ms(t2, function(e3) {
            var r2 = +n2, i2 = r2 / (e3[1][0] - e3[0][0]), o2 = (r2 - i2 * (e3[1][0] + e3[0][0])) / 2, a2 = -i2 * e3[0][1];
            t2.scale(150 * i2).translate([o2, a2]);
          }, e2);
        }
        function Ss(t2, n2, e2) {
          return Ms(t2, function(e3) {
            var r2 = +n2, i2 = r2 / (e3[1][1] - e3[0][1]), o2 = -i2 * e3[0][0], a2 = (r2 - i2 * (e3[1][1] + e3[0][1])) / 2;
            t2.scale(150 * i2).translate([o2, a2]);
          }, e2);
        }
        bs.prototype = { _radius: 4.5, _circle: ms(4.5), pointRadius: function(t2) {
          return (t2 = +t2) !== this._radius && (this._radius = t2, this._circle = null), this;
        }, polygonStart: function() {
          this._line = 0;
        }, polygonEnd: function() {
          this._line = NaN;
        }, lineStart: function() {
          this._point = 0;
        }, lineEnd: function() {
          0 === this._line && this._string.push("Z"), this._point = NaN;
        }, point: function(t2, n2) {
          switch (this._point) {
            case 0:
              this._string.push("M", t2, ",", n2), this._point = 1;
              break;
            case 1:
              this._string.push("L", t2, ",", n2);
              break;
            default:
              null == this._circle && (this._circle = ms(this._radius)), this._string.push("M", t2, ",", n2, this._circle);
          }
        }, result: function() {
          if (this._string.length) {
            var t2 = this._string.join("");
            return this._string = [], t2;
          }
          return null;
        } }, ws.prototype = { constructor: ws, point: function(t2, n2) {
          this.stream.point(t2, n2);
        }, sphere: function() {
          this.stream.sphere();
        }, lineStart: function() {
          this.stream.lineStart();
        }, lineEnd: function() {
          this.stream.lineEnd();
        }, polygonStart: function() {
          this.stream.polygonStart();
        }, polygonEnd: function() {
          this.stream.polygonEnd();
        } };
        var ks = 16, Es = Wa(30 * Xa);
        function Cs(t2, n2) {
          return +n2 ? function(t3, n3) {
            function e2(r2, i2, o2, a2, u2, c2, f2, s2, l2, h2, d2, p2, v2, g2) {
              var y2 = f2 - r2, _2 = s2 - i2, b2 = y2 * y2 + _2 * _2;
              if (b2 > 4 * n3 && v2--) {
                var m2 = a2 + h2, x2 = u2 + d2, w2 = c2 + p2, M2 = eu(m2 * m2 + x2 * x2 + w2 * w2), N2 = ou(w2 /= M2), A2 = Ga(Ga(w2) - 1) < Oa || Ga(o2 - l2) < Oa ? (o2 + l2) / 2 : $a(x2, m2), T2 = t3(A2, N2), S2 = T2[0], k2 = T2[1], E2 = S2 - r2, C2 = k2 - i2, P2 = _2 * E2 - y2 * C2;
                (P2 * P2 / b2 > n3 || Ga((y2 * E2 + _2 * C2) / b2 - 0.5) > 0.3 || a2 * h2 + u2 * d2 + c2 * p2 < Es) && (e2(r2, i2, o2, a2, u2, c2, S2, k2, A2, m2 /= M2, x2 /= M2, w2, v2, g2), g2.point(S2, k2), e2(S2, k2, A2, m2, x2, w2, f2, s2, l2, h2, d2, p2, v2, g2));
              }
            }
            return function(n4) {
              var r2, i2, o2, a2, u2, c2, f2, s2, l2, h2, d2, p2, v2 = { point: g2, lineStart: y2, lineEnd: b2, polygonStart: function() {
                n4.polygonStart(), v2.lineStart = m2;
              }, polygonEnd: function() {
                n4.polygonEnd(), v2.lineStart = y2;
              } };
              function g2(e3, r3) {
                e3 = t3(e3, r3), n4.point(e3[0], e3[1]);
              }
              function y2() {
                s2 = NaN, v2.point = _2, n4.lineStart();
              }
              function _2(r3, i3) {
                var o3 = Su([r3, i3]), a3 = t3(r3, i3);
                e2(s2, l2, f2, h2, d2, p2, s2 = a3[0], l2 = a3[1], f2 = r3, h2 = o3[0], d2 = o3[1], p2 = o3[2], ks, n4), n4.point(s2, l2);
              }
              function b2() {
                v2.point = g2, n4.lineEnd();
              }
              function m2() {
                y2(), v2.point = x2, v2.lineEnd = w2;
              }
              function x2(t4, n5) {
                _2(r2 = t4, n5), i2 = s2, o2 = l2, a2 = h2, u2 = d2, c2 = p2, v2.point = _2;
              }
              function w2() {
                e2(s2, l2, f2, h2, d2, p2, i2, o2, r2, a2, u2, c2, ks, n4), v2.lineEnd = b2, b2();
              }
              return v2;
            };
          }(t2, n2) : function(t3) {
            return xs({ point: function(n3, e2) {
              n3 = t3(n3, e2), this.stream.point(n3[0], n3[1]);
            } });
          }(t2);
        }
        var Ps = xs({ point: function(t2, n2) {
          this.stream.point(t2 * Xa, n2 * Xa);
        } });
        function zs(t2, n2, e2, r2) {
          var i2 = Wa(r2), o2 = tu(r2), a2 = i2 * t2, u2 = o2 * t2, c2 = i2 / t2, f2 = o2 / t2, s2 = (o2 * e2 - i2 * n2) / t2, l2 = (o2 * n2 + i2 * e2) / t2;
          function h2(t3, r3) {
            return [a2 * t3 - u2 * r3 + n2, e2 - u2 * t3 - a2 * r3];
          }
          return h2.invert = function(t3, n3) {
            return [c2 * t3 - f2 * n3 + s2, l2 - f2 * t3 - c2 * n3];
          }, h2;
        }
        function Rs(t2) {
          return Ds(function() {
            return t2;
          })();
        }
        function Ds(t2) {
          var n2, e2, r2, i2, o2, a2, u2, c2, f2, s2, l2 = 150, h2 = 480, d2 = 250, p2 = 0, v2 = 0, g2 = 0, y2 = 0, _2 = 0, b2 = 0, m2 = null, x2 = $c, w2 = null, M2 = Mf, N2 = 0.5;
          function A2(t3) {
            return c2(t3[0] * Xa, t3[1] * Xa);
          }
          function T2(t3) {
            return (t3 = c2.invert(t3[0], t3[1])) && [t3[0] * Ha, t3[1] * Ha];
          }
          function S2() {
            var t3 = zs(l2, 0, 0, b2).apply(null, n2(p2, v2)), r3 = (b2 ? zs : function(t4, n3, e3) {
              function r4(r5, i3) {
                return [n3 + t4 * r5, e3 - t4 * i3];
              }
              return r4.invert = function(r5, i3) {
                return [(r5 - n3) / t4, (e3 - i3) / t4];
              }, r4;
            })(l2, h2 - t3[0], d2 - t3[1], b2);
            return e2 = Pc(g2, y2, _2), u2 = Ec(n2, r3), c2 = Ec(e2, u2), a2 = Cs(u2, N2), k2();
          }
          function k2() {
            return f2 = s2 = null, A2;
          }
          return A2.stream = function(t3) {
            return f2 && s2 === t3 ? f2 : f2 = Ps(function(t4) {
              return xs({ point: function(n3, e3) {
                var r3 = t4(n3, e3);
                return this.stream.point(r3[0], r3[1]);
              } });
            }(e2)(x2(a2(M2(s2 = t3)))));
          }, A2.preclip = function(t3) {
            return arguments.length ? (x2 = t3, m2 = void 0, k2()) : x2;
          }, A2.postclip = function(t3) {
            return arguments.length ? (M2 = t3, w2 = r2 = i2 = o2 = null, k2()) : M2;
          }, A2.clipAngle = function(t3) {
            return arguments.length ? (x2 = +t3 ? Wc(m2 = t3 * Xa) : (m2 = null, $c), k2()) : m2 * Ha;
          }, A2.clipExtent = function(t3) {
            return arguments.length ? (M2 = null == t3 ? (w2 = r2 = i2 = o2 = null, Mf) : Jc(w2 = +t3[0][0], r2 = +t3[0][1], i2 = +t3[1][0], o2 = +t3[1][1]), k2()) : null == w2 ? null : [[w2, r2], [i2, o2]];
          }, A2.scale = function(t3) {
            return arguments.length ? (l2 = +t3, S2()) : l2;
          }, A2.translate = function(t3) {
            return arguments.length ? (h2 = +t3[0], d2 = +t3[1], S2()) : [h2, d2];
          }, A2.center = function(t3) {
            return arguments.length ? (p2 = t3[0] % 360 * Xa, v2 = t3[1] % 360 * Xa, S2()) : [p2 * Ha, v2 * Ha];
          }, A2.rotate = function(t3) {
            return arguments.length ? (g2 = t3[0] % 360 * Xa, y2 = t3[1] % 360 * Xa, _2 = t3.length > 2 ? t3[2] % 360 * Xa : 0, S2()) : [g2 * Ha, y2 * Ha, _2 * Ha];
          }, A2.angle = function(t3) {
            return arguments.length ? (b2 = t3 % 360 * Xa, S2()) : b2 * Ha;
          }, A2.precision = function(t3) {
            return arguments.length ? (a2 = Cs(u2, N2 = t3 * t3), k2()) : eu(N2);
          }, A2.fitExtent = function(t3, n3) {
            return Ns(A2, t3, n3);
          }, A2.fitSize = function(t3, n3) {
            return As(A2, t3, n3);
          }, A2.fitWidth = function(t3, n3) {
            return Ts(A2, t3, n3);
          }, A2.fitHeight = function(t3, n3) {
            return Ss(A2, t3, n3);
          }, function() {
            return n2 = t2.apply(this, arguments), A2.invert = n2.invert && T2, S2();
          };
        }
        function qs(t2) {
          var n2 = 0, e2 = Ya / 3, r2 = Ds(t2), i2 = r2(n2, e2);
          return i2.parallels = function(t3) {
            return arguments.length ? r2(n2 = t3[0] * Xa, e2 = t3[1] * Xa) : [n2 * Ha, e2 * Ha];
          }, i2;
        }
        function Ls(t2, n2) {
          var e2 = tu(t2), r2 = (e2 + tu(n2)) / 2;
          if (Ga(r2) < Oa)
            return function(t3) {
              var n3 = Wa(t3);
              function e3(t4, e4) {
                return [t4 * n3, tu(e4) / n3];
              }
              return e3.invert = function(t4, e4) {
                return [t4 / n3, ou(e4 * n3)];
              }, e3;
            }(t2);
          var i2 = 1 + e2 * (2 * r2 - e2), o2 = eu(i2) / r2;
          function a2(t3, n3) {
            var e3 = eu(i2 - 2 * r2 * tu(n3)) / r2;
            return [e3 * tu(t3 *= r2), o2 - e3 * Wa(t3)];
          }
          return a2.invert = function(t3, n3) {
            var e3 = o2 - n3;
            return [$a(t3, Ga(e3)) / r2 * nu(e3), ou((i2 - (t3 * t3 + e3 * e3) * r2 * r2) / (2 * r2))];
          }, a2;
        }
        function Us() {
          return qs(Ls).scale(155.424).center([0, 33.6442]);
        }
        function Os() {
          return Us().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
        }
        function Bs(t2) {
          return function(n2, e2) {
            var r2 = Wa(n2), i2 = Wa(e2), o2 = t2(r2 * i2);
            return [o2 * i2 * tu(n2), o2 * tu(e2)];
          };
        }
        function Ys(t2) {
          return function(n2, e2) {
            var r2 = eu(n2 * n2 + e2 * e2), i2 = t2(r2), o2 = tu(i2), a2 = Wa(i2);
            return [$a(n2 * o2, r2 * a2), ou(r2 && e2 * o2 / r2)];
          };
        }
        var Fs = Bs(function(t2) {
          return eu(2 / (1 + t2));
        });
        Fs.invert = Ys(function(t2) {
          return 2 * ou(t2 / 2);
        });
        var Is = Bs(function(t2) {
          return (t2 = iu(t2)) && t2 / tu(t2);
        });
        function js(t2, n2) {
          return [t2, Ja(ru((Fa + n2) / 2))];
        }
        function Hs(t2) {
          var n2, e2, r2, i2 = Rs(t2), o2 = i2.center, a2 = i2.scale, u2 = i2.translate, c2 = i2.clipExtent, f2 = null;
          function s2() {
            var o3 = Ya * a2(), u3 = i2(qc(i2.rotate()).invert([0, 0]));
            return c2(null == f2 ? [[u3[0] - o3, u3[1] - o3], [u3[0] + o3, u3[1] + o3]] : t2 === js ? [[Math.max(u3[0] - o3, f2), n2], [Math.min(u3[0] + o3, e2), r2]] : [[f2, Math.max(u3[1] - o3, n2)], [e2, Math.min(u3[1] + o3, r2)]]);
          }
          return i2.scale = function(t3) {
            return arguments.length ? (a2(t3), s2()) : a2();
          }, i2.translate = function(t3) {
            return arguments.length ? (u2(t3), s2()) : u2();
          }, i2.center = function(t3) {
            return arguments.length ? (o2(t3), s2()) : o2();
          }, i2.clipExtent = function(t3) {
            return arguments.length ? (null == t3 ? f2 = n2 = e2 = r2 = null : (f2 = +t3[0][0], n2 = +t3[0][1], e2 = +t3[1][0], r2 = +t3[1][1]), s2()) : null == f2 ? null : [[f2, n2], [e2, r2]];
          }, s2();
        }
        function Xs(t2) {
          return ru((Fa + t2) / 2);
        }
        function Gs(t2, n2) {
          var e2 = Wa(t2), r2 = t2 === n2 ? tu(t2) : Ja(e2 / Wa(n2)) / Ja(Xs(n2) / Xs(t2)), i2 = e2 * Ka(Xs(t2), r2) / r2;
          if (!r2)
            return js;
          function o2(t3, n3) {
            i2 > 0 ? n3 < -Fa + Oa && (n3 = -Fa + Oa) : n3 > Fa - Oa && (n3 = Fa - Oa);
            var e3 = i2 / Ka(Xs(n3), r2);
            return [e3 * tu(r2 * t3), i2 - e3 * Wa(r2 * t3)];
          }
          return o2.invert = function(t3, n3) {
            var e3 = i2 - n3, o3 = nu(r2) * eu(t3 * t3 + e3 * e3);
            return [$a(t3, Ga(e3)) / r2 * nu(e3), 2 * Va(Ka(i2 / o3, 1 / r2)) - Fa];
          }, o2;
        }
        function Vs(t2, n2) {
          return [t2, n2];
        }
        function $s(t2, n2) {
          var e2 = Wa(t2), r2 = t2 === n2 ? tu(t2) : (e2 - Wa(n2)) / (n2 - t2), i2 = e2 / r2 + t2;
          if (Ga(r2) < Oa)
            return Vs;
          function o2(t3, n3) {
            var e3 = i2 - n3, o3 = r2 * t3;
            return [e3 * tu(o3), i2 - e3 * Wa(o3)];
          }
          return o2.invert = function(t3, n3) {
            var e3 = i2 - n3;
            return [$a(t3, Ga(e3)) / r2 * nu(e3), i2 - nu(r2) * eu(t3 * t3 + e3 * e3)];
          }, o2;
        }
        Is.invert = Ys(function(t2) {
          return t2;
        }), js.invert = function(t2, n2) {
          return [t2, 2 * Va(Qa(n2)) - Fa];
        }, Vs.invert = Vs;
        var Ws = 1.340264, Zs = -0.081106, Qs = 893e-6, Js = 3796e-6, Ks = eu(3) / 2;
        function tl(t2, n2) {
          var e2 = ou(Ks * tu(n2)), r2 = e2 * e2, i2 = r2 * r2 * r2;
          return [t2 * Wa(e2) / (Ks * (Ws + 3 * Zs * r2 + i2 * (7 * Qs + 9 * Js * r2))), e2 * (Ws + Zs * r2 + i2 * (Qs + Js * r2))];
        }
        function nl(t2, n2) {
          var e2 = Wa(n2), r2 = Wa(t2) * e2;
          return [e2 * tu(t2) / r2, tu(n2) / r2];
        }
        function el(t2, n2, e2, r2) {
          return 1 === t2 && 1 === n2 && 0 === e2 && 0 === r2 ? Mf : xs({ point: function(i2, o2) {
            this.stream.point(i2 * t2 + e2, o2 * n2 + r2);
          } });
        }
        function rl(t2, n2) {
          var e2 = n2 * n2, r2 = e2 * e2;
          return [t2 * (0.8707 - 0.131979 * e2 + r2 * (r2 * (3971e-6 * e2 - 1529e-6 * r2) - 0.013791)), n2 * (1.007226 + e2 * (0.015085 + r2 * (0.028874 * e2 - 0.044475 - 5916e-6 * r2)))];
        }
        function il(t2, n2) {
          return [Wa(n2) * tu(t2), tu(n2)];
        }
        function ol(t2, n2) {
          var e2 = Wa(n2), r2 = 1 + Wa(t2) * e2;
          return [e2 * tu(t2) / r2, tu(n2) / r2];
        }
        function al(t2, n2) {
          return [Ja(ru((Fa + n2) / 2)), -t2];
        }
        function ul(t2, n2) {
          return t2.parent === n2.parent ? 1 : 2;
        }
        function cl(t2, n2) {
          return t2 + n2.x;
        }
        function fl(t2, n2) {
          return Math.max(t2, n2.y);
        }
        function sl(t2) {
          var n2 = 0, e2 = t2.children, r2 = e2 && e2.length;
          if (r2)
            for (; --r2 >= 0; )
              n2 += e2[r2].value;
          else
            n2 = 1;
          t2.value = n2;
        }
        function ll(t2, n2) {
          var e2, r2, i2, o2, a2, u2 = new vl(t2), c2 = +t2.value && (u2.value = t2.value), f2 = [u2];
          for (null == n2 && (n2 = hl); e2 = f2.pop(); )
            if (c2 && (e2.value = +e2.data.value), (i2 = n2(e2.data)) && (a2 = i2.length))
              for (e2.children = new Array(a2), o2 = a2 - 1; o2 >= 0; --o2)
                f2.push(r2 = e2.children[o2] = new vl(i2[o2])), r2.parent = e2, r2.depth = e2.depth + 1;
          return u2.eachBefore(pl);
        }
        function hl(t2) {
          return t2.children;
        }
        function dl(t2) {
          t2.data = t2.data.data;
        }
        function pl(t2) {
          var n2 = 0;
          do {
            t2.height = n2;
          } while ((t2 = t2.parent) && t2.height < ++n2);
        }
        function vl(t2) {
          this.data = t2, this.depth = this.height = 0, this.parent = null;
        }
        tl.invert = function(t2, n2) {
          for (var e2, r2 = n2, i2 = r2 * r2, o2 = i2 * i2 * i2, a2 = 0; a2 < 12 && (o2 = (i2 = (r2 -= e2 = (r2 * (Ws + Zs * i2 + o2 * (Qs + Js * i2)) - n2) / (Ws + 3 * Zs * i2 + o2 * (7 * Qs + 9 * Js * i2))) * r2) * i2 * i2, !(Ga(e2) < Ba)); ++a2)
            ;
          return [Ks * t2 * (Ws + 3 * Zs * i2 + o2 * (7 * Qs + 9 * Js * i2)) / Wa(r2), ou(tu(r2) / Ks)];
        }, nl.invert = Ys(Va), rl.invert = function(t2, n2) {
          var e2, r2 = n2, i2 = 25;
          do {
            var o2 = r2 * r2, a2 = o2 * o2;
            r2 -= e2 = (r2 * (1.007226 + o2 * (0.015085 + a2 * (0.028874 * o2 - 0.044475 - 5916e-6 * a2))) - n2) / (1.007226 + o2 * (0.045255 + a2 * (0.259866 * o2 - 0.311325 - 5916e-6 * 11 * a2)));
          } while (Ga(e2) > Oa && --i2 > 0);
          return [t2 / (0.8707 + (o2 = r2 * r2) * (o2 * (o2 * o2 * o2 * (3971e-6 - 1529e-6 * o2) - 0.013791) - 0.131979)), r2];
        }, il.invert = Ys(ou), ol.invert = Ys(function(t2) {
          return 2 * Va(t2);
        }), al.invert = function(t2, n2) {
          return [-n2, 2 * Va(Qa(t2)) - Fa];
        }, vl.prototype = ll.prototype = { constructor: vl, count: function() {
          return this.eachAfter(sl);
        }, each: function(t2) {
          var n2, e2, r2, i2, o2 = this, a2 = [o2];
          do {
            for (n2 = a2.reverse(), a2 = []; o2 = n2.pop(); )
              if (t2(o2), e2 = o2.children)
                for (r2 = 0, i2 = e2.length; r2 < i2; ++r2)
                  a2.push(e2[r2]);
          } while (a2.length);
          return this;
        }, eachAfter: function(t2) {
          for (var n2, e2, r2, i2 = this, o2 = [i2], a2 = []; i2 = o2.pop(); )
            if (a2.push(i2), n2 = i2.children)
              for (e2 = 0, r2 = n2.length; e2 < r2; ++e2)
                o2.push(n2[e2]);
          for (; i2 = a2.pop(); )
            t2(i2);
          return this;
        }, eachBefore: function(t2) {
          for (var n2, e2, r2 = this, i2 = [r2]; r2 = i2.pop(); )
            if (t2(r2), n2 = r2.children)
              for (e2 = n2.length - 1; e2 >= 0; --e2)
                i2.push(n2[e2]);
          return this;
        }, sum: function(t2) {
          return this.eachAfter(function(n2) {
            for (var e2 = +t2(n2.data) || 0, r2 = n2.children, i2 = r2 && r2.length; --i2 >= 0; )
              e2 += r2[i2].value;
            n2.value = e2;
          });
        }, sort: function(t2) {
          return this.eachBefore(function(n2) {
            n2.children && n2.children.sort(t2);
          });
        }, path: function(t2) {
          for (var n2 = this, e2 = function(t3, n3) {
            if (t3 === n3)
              return t3;
            var e3 = t3.ancestors(), r3 = n3.ancestors(), i3 = null;
            for (t3 = e3.pop(), n3 = r3.pop(); t3 === n3; )
              i3 = t3, t3 = e3.pop(), n3 = r3.pop();
            return i3;
          }(n2, t2), r2 = [n2]; n2 !== e2; )
            n2 = n2.parent, r2.push(n2);
          for (var i2 = r2.length; t2 !== e2; )
            r2.splice(i2, 0, t2), t2 = t2.parent;
          return r2;
        }, ancestors: function() {
          for (var t2 = this, n2 = [t2]; t2 = t2.parent; )
            n2.push(t2);
          return n2;
        }, descendants: function() {
          var t2 = [];
          return this.each(function(n2) {
            t2.push(n2);
          }), t2;
        }, leaves: function() {
          var t2 = [];
          return this.eachBefore(function(n2) {
            n2.children || t2.push(n2);
          }), t2;
        }, links: function() {
          var t2 = this, n2 = [];
          return t2.each(function(e2) {
            e2 !== t2 && n2.push({ source: e2.parent, target: e2 });
          }), n2;
        }, copy: function() {
          return ll(this).eachBefore(dl);
        } };
        var gl = Array.prototype.slice;
        function yl(t2) {
          for (var n2, e2, r2 = 0, i2 = (t2 = function(t3) {
            for (var n3, e3, r3 = t3.length; r3; )
              e3 = Math.random() * r3-- | 0, n3 = t3[r3], t3[r3] = t3[e3], t3[e3] = n3;
            return t3;
          }(gl.call(t2))).length, o2 = []; r2 < i2; )
            n2 = t2[r2], e2 && ml(e2, n2) ? ++r2 : (e2 = wl(o2 = _l(o2, n2)), r2 = 0);
          return e2;
        }
        function _l(t2, n2) {
          var e2, r2;
          if (xl(n2, t2))
            return [n2];
          for (e2 = 0; e2 < t2.length; ++e2)
            if (bl(n2, t2[e2]) && xl(Ml(t2[e2], n2), t2))
              return [t2[e2], n2];
          for (e2 = 0; e2 < t2.length - 1; ++e2)
            for (r2 = e2 + 1; r2 < t2.length; ++r2)
              if (bl(Ml(t2[e2], t2[r2]), n2) && bl(Ml(t2[e2], n2), t2[r2]) && bl(Ml(t2[r2], n2), t2[e2]) && xl(Nl(t2[e2], t2[r2], n2), t2))
                return [t2[e2], t2[r2], n2];
          throw new Error();
        }
        function bl(t2, n2) {
          var e2 = t2.r - n2.r, r2 = n2.x - t2.x, i2 = n2.y - t2.y;
          return e2 < 0 || e2 * e2 < r2 * r2 + i2 * i2;
        }
        function ml(t2, n2) {
          var e2 = t2.r - n2.r + 1e-6, r2 = n2.x - t2.x, i2 = n2.y - t2.y;
          return e2 > 0 && e2 * e2 > r2 * r2 + i2 * i2;
        }
        function xl(t2, n2) {
          for (var e2 = 0; e2 < n2.length; ++e2)
            if (!ml(t2, n2[e2]))
              return false;
          return true;
        }
        function wl(t2) {
          switch (t2.length) {
            case 1:
              return { x: (n2 = t2[0]).x, y: n2.y, r: n2.r };
            case 2:
              return Ml(t2[0], t2[1]);
            case 3:
              return Nl(t2[0], t2[1], t2[2]);
          }
          var n2;
        }
        function Ml(t2, n2) {
          var e2 = t2.x, r2 = t2.y, i2 = t2.r, o2 = n2.x, a2 = n2.y, u2 = n2.r, c2 = o2 - e2, f2 = a2 - r2, s2 = u2 - i2, l2 = Math.sqrt(c2 * c2 + f2 * f2);
          return { x: (e2 + o2 + c2 / l2 * s2) / 2, y: (r2 + a2 + f2 / l2 * s2) / 2, r: (l2 + i2 + u2) / 2 };
        }
        function Nl(t2, n2, e2) {
          var r2 = t2.x, i2 = t2.y, o2 = t2.r, a2 = n2.x, u2 = n2.y, c2 = n2.r, f2 = e2.x, s2 = e2.y, l2 = e2.r, h2 = r2 - a2, d2 = r2 - f2, p2 = i2 - u2, v2 = i2 - s2, g2 = c2 - o2, y2 = l2 - o2, _2 = r2 * r2 + i2 * i2 - o2 * o2, b2 = _2 - a2 * a2 - u2 * u2 + c2 * c2, m2 = _2 - f2 * f2 - s2 * s2 + l2 * l2, x2 = d2 * p2 - h2 * v2, w2 = (p2 * m2 - v2 * b2) / (2 * x2) - r2, M2 = (v2 * g2 - p2 * y2) / x2, N2 = (d2 * b2 - h2 * m2) / (2 * x2) - i2, A2 = (h2 * y2 - d2 * g2) / x2, T2 = M2 * M2 + A2 * A2 - 1, S2 = 2 * (o2 + w2 * M2 + N2 * A2), k2 = w2 * w2 + N2 * N2 - o2 * o2, E2 = -(T2 ? (S2 + Math.sqrt(S2 * S2 - 4 * T2 * k2)) / (2 * T2) : k2 / S2);
          return { x: r2 + w2 + M2 * E2, y: i2 + N2 + A2 * E2, r: E2 };
        }
        function Al(t2, n2, e2) {
          var r2, i2, o2, a2, u2 = t2.x - n2.x, c2 = t2.y - n2.y, f2 = u2 * u2 + c2 * c2;
          f2 ? (i2 = n2.r + e2.r, i2 *= i2, a2 = t2.r + e2.r, i2 > (a2 *= a2) ? (r2 = (f2 + a2 - i2) / (2 * f2), o2 = Math.sqrt(Math.max(0, a2 / f2 - r2 * r2)), e2.x = t2.x - r2 * u2 - o2 * c2, e2.y = t2.y - r2 * c2 + o2 * u2) : (r2 = (f2 + i2 - a2) / (2 * f2), o2 = Math.sqrt(Math.max(0, i2 / f2 - r2 * r2)), e2.x = n2.x + r2 * u2 - o2 * c2, e2.y = n2.y + r2 * c2 + o2 * u2)) : (e2.x = n2.x + e2.r, e2.y = n2.y);
        }
        function Tl(t2, n2) {
          var e2 = t2.r + n2.r - 1e-6, r2 = n2.x - t2.x, i2 = n2.y - t2.y;
          return e2 > 0 && e2 * e2 > r2 * r2 + i2 * i2;
        }
        function Sl(t2) {
          var n2 = t2._, e2 = t2.next._, r2 = n2.r + e2.r, i2 = (n2.x * e2.r + e2.x * n2.r) / r2, o2 = (n2.y * e2.r + e2.y * n2.r) / r2;
          return i2 * i2 + o2 * o2;
        }
        function kl(t2) {
          this._ = t2, this.next = null, this.previous = null;
        }
        function El(t2) {
          if (!(i2 = t2.length))
            return 0;
          var n2, e2, r2, i2, o2, a2, u2, c2, f2, s2, l2;
          if ((n2 = t2[0]).x = 0, n2.y = 0, !(i2 > 1))
            return n2.r;
          if (e2 = t2[1], n2.x = -e2.r, e2.x = n2.r, e2.y = 0, !(i2 > 2))
            return n2.r + e2.r;
          Al(e2, n2, r2 = t2[2]), n2 = new kl(n2), e2 = new kl(e2), r2 = new kl(r2), n2.next = r2.previous = e2, e2.next = n2.previous = r2, r2.next = e2.previous = n2;
          t:
            for (u2 = 3; u2 < i2; ++u2) {
              Al(n2._, e2._, r2 = t2[u2]), r2 = new kl(r2), c2 = e2.next, f2 = n2.previous, s2 = e2._.r, l2 = n2._.r;
              do {
                if (s2 <= l2) {
                  if (Tl(c2._, r2._)) {
                    e2 = c2, n2.next = e2, e2.previous = n2, --u2;
                    continue t;
                  }
                  s2 += c2._.r, c2 = c2.next;
                } else {
                  if (Tl(f2._, r2._)) {
                    (n2 = f2).next = e2, e2.previous = n2, --u2;
                    continue t;
                  }
                  l2 += f2._.r, f2 = f2.previous;
                }
              } while (c2 !== f2.next);
              for (r2.previous = n2, r2.next = e2, n2.next = e2.previous = e2 = r2, o2 = Sl(n2); (r2 = r2.next) !== e2; )
                (a2 = Sl(r2)) < o2 && (n2 = r2, o2 = a2);
              e2 = n2.next;
            }
          for (n2 = [e2._], r2 = e2; (r2 = r2.next) !== e2; )
            n2.push(r2._);
          for (r2 = yl(n2), u2 = 0; u2 < i2; ++u2)
            (n2 = t2[u2]).x -= r2.x, n2.y -= r2.y;
          return r2.r;
        }
        function Cl(t2) {
          if ("function" != typeof t2)
            throw new Error();
          return t2;
        }
        function Pl() {
          return 0;
        }
        function zl(t2) {
          return function() {
            return t2;
          };
        }
        function Rl(t2) {
          return Math.sqrt(t2.value);
        }
        function Dl(t2) {
          return function(n2) {
            n2.children || (n2.r = Math.max(0, +t2(n2) || 0));
          };
        }
        function ql(t2, n2) {
          return function(e2) {
            if (r2 = e2.children) {
              var r2, i2, o2, a2 = r2.length, u2 = t2(e2) * n2 || 0;
              if (u2)
                for (i2 = 0; i2 < a2; ++i2)
                  r2[i2].r += u2;
              if (o2 = El(r2), u2)
                for (i2 = 0; i2 < a2; ++i2)
                  r2[i2].r -= u2;
              e2.r = o2 + u2;
            }
          };
        }
        function Ll(t2) {
          return function(n2) {
            var e2 = n2.parent;
            n2.r *= t2, e2 && (n2.x = e2.x + t2 * n2.x, n2.y = e2.y + t2 * n2.y);
          };
        }
        function Ul(t2) {
          t2.x0 = Math.round(t2.x0), t2.y0 = Math.round(t2.y0), t2.x1 = Math.round(t2.x1), t2.y1 = Math.round(t2.y1);
        }
        function Ol(t2, n2, e2, r2, i2) {
          for (var o2, a2 = t2.children, u2 = -1, c2 = a2.length, f2 = t2.value && (r2 - n2) / t2.value; ++u2 < c2; )
            (o2 = a2[u2]).y0 = e2, o2.y1 = i2, o2.x0 = n2, o2.x1 = n2 += o2.value * f2;
        }
        var Bl = "$", Yl = { depth: -1 }, Fl = {};
        function Il(t2) {
          return t2.id;
        }
        function jl(t2) {
          return t2.parentId;
        }
        function Hl(t2, n2) {
          return t2.parent === n2.parent ? 1 : 2;
        }
        function Xl(t2) {
          var n2 = t2.children;
          return n2 ? n2[0] : t2.t;
        }
        function Gl(t2) {
          var n2 = t2.children;
          return n2 ? n2[n2.length - 1] : t2.t;
        }
        function Vl(t2, n2, e2) {
          var r2 = e2 / (n2.i - t2.i);
          n2.c -= r2, n2.s += e2, t2.c += r2, n2.z += e2, n2.m += e2;
        }
        function $l(t2, n2, e2) {
          return t2.a.parent === n2.parent ? t2.a : e2;
        }
        function Wl(t2, n2) {
          this._ = t2, this.parent = null, this.children = null, this.A = null, this.a = this, this.z = 0, this.m = 0, this.c = 0, this.s = 0, this.t = null, this.i = n2;
        }
        function Zl(t2, n2, e2, r2, i2) {
          for (var o2, a2 = t2.children, u2 = -1, c2 = a2.length, f2 = t2.value && (i2 - e2) / t2.value; ++u2 < c2; )
            (o2 = a2[u2]).x0 = n2, o2.x1 = r2, o2.y0 = e2, o2.y1 = e2 += o2.value * f2;
        }
        Wl.prototype = Object.create(vl.prototype);
        var Ql = (1 + Math.sqrt(5)) / 2;
        function Jl(t2, n2, e2, r2, i2, o2) {
          for (var a2, u2, c2, f2, s2, l2, h2, d2, p2, v2, g2, y2 = [], _2 = n2.children, b2 = 0, m2 = 0, x2 = _2.length, w2 = n2.value; b2 < x2; ) {
            c2 = i2 - e2, f2 = o2 - r2;
            do {
              s2 = _2[m2++].value;
            } while (!s2 && m2 < x2);
            for (l2 = h2 = s2, g2 = s2 * s2 * (v2 = Math.max(f2 / c2, c2 / f2) / (w2 * t2)), p2 = Math.max(h2 / g2, g2 / l2); m2 < x2; ++m2) {
              if (s2 += u2 = _2[m2].value, u2 < l2 && (l2 = u2), u2 > h2 && (h2 = u2), g2 = s2 * s2 * v2, (d2 = Math.max(h2 / g2, g2 / l2)) > p2) {
                s2 -= u2;
                break;
              }
              p2 = d2;
            }
            y2.push(a2 = { value: s2, dice: c2 < f2, children: _2.slice(b2, m2) }), a2.dice ? Ol(a2, e2, r2, i2, w2 ? r2 += f2 * s2 / w2 : o2) : Zl(a2, e2, r2, w2 ? e2 += c2 * s2 / w2 : i2, o2), w2 -= s2, b2 = m2;
          }
          return y2;
        }
        var Kl = function t2(n2) {
          function e2(t3, e3, r2, i2, o2) {
            Jl(n2, t3, e3, r2, i2, o2);
          }
          return e2.ratio = function(n3) {
            return t2((n3 = +n3) > 1 ? n3 : 1);
          }, e2;
        }(Ql);
        var th = function t2(n2) {
          function e2(t3, e3, r2, i2, o2) {
            if ((a2 = t3._squarify) && a2.ratio === n2)
              for (var a2, u2, c2, f2, s2, l2 = -1, h2 = a2.length, d2 = t3.value; ++l2 < h2; ) {
                for (c2 = (u2 = a2[l2]).children, f2 = u2.value = 0, s2 = c2.length; f2 < s2; ++f2)
                  u2.value += c2[f2].value;
                u2.dice ? Ol(u2, e3, r2, i2, r2 += (o2 - r2) * u2.value / d2) : Zl(u2, e3, r2, e3 += (i2 - e3) * u2.value / d2, o2), d2 -= u2.value;
              }
            else
              t3._squarify = a2 = Jl(n2, t3, e3, r2, i2, o2), a2.ratio = n2;
          }
          return e2.ratio = function(n3) {
            return t2((n3 = +n3) > 1 ? n3 : 1);
          }, e2;
        }(Ql);
        function nh(t2, n2) {
          return t2[0] - n2[0] || t2[1] - n2[1];
        }
        function eh(t2) {
          for (var n2, e2, r2, i2 = t2.length, o2 = [0, 1], a2 = 2, u2 = 2; u2 < i2; ++u2) {
            for (; a2 > 1 && (n2 = t2[o2[a2 - 2]], e2 = t2[o2[a2 - 1]], r2 = t2[u2], (e2[0] - n2[0]) * (r2[1] - n2[1]) - (e2[1] - n2[1]) * (r2[0] - n2[0]) <= 0); )
              --a2;
            o2[a2++] = u2;
          }
          return o2.slice(0, a2);
        }
        function rh() {
          return Math.random();
        }
        var ih = function t2(n2) {
          function e2(t3, e3) {
            return t3 = null == t3 ? 0 : +t3, e3 = null == e3 ? 1 : +e3, 1 === arguments.length ? (e3 = t3, t3 = 0) : e3 -= t3, function() {
              return n2() * e3 + t3;
            };
          }
          return e2.source = t2, e2;
        }(rh), oh = function t2(n2) {
          function e2(t3, e3) {
            var r2, i2;
            return t3 = null == t3 ? 0 : +t3, e3 = null == e3 ? 1 : +e3, function() {
              var o2;
              if (null != r2)
                o2 = r2, r2 = null;
              else
                do {
                  r2 = 2 * n2() - 1, o2 = 2 * n2() - 1, i2 = r2 * r2 + o2 * o2;
                } while (!i2 || i2 > 1);
              return t3 + e3 * o2 * Math.sqrt(-2 * Math.log(i2) / i2);
            };
          }
          return e2.source = t2, e2;
        }(rh), ah = function t2(n2) {
          function e2() {
            var t3 = oh.source(n2).apply(this, arguments);
            return function() {
              return Math.exp(t3());
            };
          }
          return e2.source = t2, e2;
        }(rh), uh = function t2(n2) {
          function e2(t3) {
            return function() {
              for (var e3 = 0, r2 = 0; r2 < t3; ++r2)
                e3 += n2();
              return e3;
            };
          }
          return e2.source = t2, e2;
        }(rh), ch = function t2(n2) {
          function e2(t3) {
            var e3 = uh.source(n2)(t3);
            return function() {
              return e3() / t3;
            };
          }
          return e2.source = t2, e2;
        }(rh), fh = function t2(n2) {
          function e2(t3) {
            return function() {
              return -Math.log(1 - n2()) / t3;
            };
          }
          return e2.source = t2, e2;
        }(rh);
        function sh(t2, n2) {
          switch (arguments.length) {
            case 0:
              break;
            case 1:
              this.range(t2);
              break;
            default:
              this.range(n2).domain(t2);
          }
          return this;
        }
        function lh(t2, n2) {
          switch (arguments.length) {
            case 0:
              break;
            case 1:
              this.interpolator(t2);
              break;
            default:
              this.interpolator(n2).domain(t2);
          }
          return this;
        }
        var hh = Array.prototype, dh = hh.map, ph = hh.slice, vh = { name: "implicit" };
        function gh() {
          var t2 = Qi(), n2 = [], e2 = [], r2 = vh;
          function i2(i3) {
            var o2 = i3 + "", a2 = t2.get(o2);
            if (!a2) {
              if (r2 !== vh)
                return r2;
              t2.set(o2, a2 = n2.push(i3));
            }
            return e2[(a2 - 1) % e2.length];
          }
          return i2.domain = function(e3) {
            if (!arguments.length)
              return n2.slice();
            n2 = [], t2 = Qi();
            for (var r3, o2, a2 = -1, u2 = e3.length; ++a2 < u2; )
              t2.has(o2 = (r3 = e3[a2]) + "") || t2.set(o2, n2.push(r3));
            return i2;
          }, i2.range = function(t3) {
            return arguments.length ? (e2 = ph.call(t3), i2) : e2.slice();
          }, i2.unknown = function(t3) {
            return arguments.length ? (r2 = t3, i2) : r2;
          }, i2.copy = function() {
            return gh(n2, e2).unknown(r2);
          }, sh.apply(i2, arguments), i2;
        }
        function yh() {
          var t2, n2, e2 = gh().unknown(void 0), r2 = e2.domain, i2 = e2.range, o2 = [0, 1], a2 = false, u2 = 0, c2 = 0, f2 = 0.5;
          function s2() {
            var e3 = r2().length, s3 = o2[1] < o2[0], l2 = o2[s3 - 0], h2 = o2[1 - s3];
            t2 = (h2 - l2) / Math.max(1, e3 - u2 + 2 * c2), a2 && (t2 = Math.floor(t2)), l2 += (h2 - l2 - t2 * (e3 - u2)) * f2, n2 = t2 * (1 - u2), a2 && (l2 = Math.round(l2), n2 = Math.round(n2));
            var d2 = g(e3).map(function(n3) {
              return l2 + t2 * n3;
            });
            return i2(s3 ? d2.reverse() : d2);
          }
          return delete e2.unknown, e2.domain = function(t3) {
            return arguments.length ? (r2(t3), s2()) : r2();
          }, e2.range = function(t3) {
            return arguments.length ? (o2 = [+t3[0], +t3[1]], s2()) : o2.slice();
          }, e2.rangeRound = function(t3) {
            return o2 = [+t3[0], +t3[1]], a2 = true, s2();
          }, e2.bandwidth = function() {
            return n2;
          }, e2.step = function() {
            return t2;
          }, e2.round = function(t3) {
            return arguments.length ? (a2 = !!t3, s2()) : a2;
          }, e2.padding = function(t3) {
            return arguments.length ? (u2 = Math.min(1, c2 = +t3), s2()) : u2;
          }, e2.paddingInner = function(t3) {
            return arguments.length ? (u2 = Math.min(1, t3), s2()) : u2;
          }, e2.paddingOuter = function(t3) {
            return arguments.length ? (c2 = +t3, s2()) : c2;
          }, e2.align = function(t3) {
            return arguments.length ? (f2 = Math.max(0, Math.min(1, t3)), s2()) : f2;
          }, e2.copy = function() {
            return yh(r2(), o2).round(a2).paddingInner(u2).paddingOuter(c2).align(f2);
          }, sh.apply(s2(), arguments);
        }
        function _h(t2) {
          return +t2;
        }
        var bh = [0, 1];
        function mh(t2) {
          return t2;
        }
        function xh(t2, n2) {
          return (n2 -= t2 = +t2) ? function(e3) {
            return (e3 - t2) / n2;
          } : (e2 = isNaN(n2) ? NaN : 0.5, function() {
            return e2;
          });
          var e2;
        }
        function wh(t2) {
          var n2, e2 = t2[0], r2 = t2[t2.length - 1];
          return e2 > r2 && (n2 = e2, e2 = r2, r2 = n2), function(t3) {
            return Math.max(e2, Math.min(r2, t3));
          };
        }
        function Mh(t2, n2, e2) {
          var r2 = t2[0], i2 = t2[1], o2 = n2[0], a2 = n2[1];
          return i2 < r2 ? (r2 = xh(i2, r2), o2 = e2(a2, o2)) : (r2 = xh(r2, i2), o2 = e2(o2, a2)), function(t3) {
            return o2(r2(t3));
          };
        }
        function Nh(t2, n2, e2) {
          var r2 = Math.min(t2.length, n2.length) - 1, o2 = new Array(r2), a2 = new Array(r2), u2 = -1;
          for (t2[r2] < t2[0] && (t2 = t2.slice().reverse(), n2 = n2.slice().reverse()); ++u2 < r2; )
            o2[u2] = xh(t2[u2], t2[u2 + 1]), a2[u2] = e2(n2[u2], n2[u2 + 1]);
          return function(n3) {
            var e3 = i(t2, n3, 1, r2) - 1;
            return a2[e3](o2[e3](n3));
          };
        }
        function Ah(t2, n2) {
          return n2.domain(t2.domain()).range(t2.range()).interpolate(t2.interpolate()).clamp(t2.clamp()).unknown(t2.unknown());
        }
        function Th() {
          var t2, n2, e2, r2, i2, o2, a2 = bh, u2 = bh, c2 = ye, f2 = mh;
          function s2() {
            return r2 = Math.min(a2.length, u2.length) > 2 ? Nh : Mh, i2 = o2 = null, l2;
          }
          function l2(n3) {
            return isNaN(n3 = +n3) ? e2 : (i2 || (i2 = r2(a2.map(t2), u2, c2)))(t2(f2(n3)));
          }
          return l2.invert = function(e3) {
            return f2(n2((o2 || (o2 = r2(u2, a2.map(t2), he)))(e3)));
          }, l2.domain = function(t3) {
            return arguments.length ? (a2 = dh.call(t3, _h), f2 === mh || (f2 = wh(a2)), s2()) : a2.slice();
          }, l2.range = function(t3) {
            return arguments.length ? (u2 = ph.call(t3), s2()) : u2.slice();
          }, l2.rangeRound = function(t3) {
            return u2 = ph.call(t3), c2 = _e, s2();
          }, l2.clamp = function(t3) {
            return arguments.length ? (f2 = t3 ? wh(a2) : mh, l2) : f2 !== mh;
          }, l2.interpolate = function(t3) {
            return arguments.length ? (c2 = t3, s2()) : c2;
          }, l2.unknown = function(t3) {
            return arguments.length ? (e2 = t3, l2) : e2;
          }, function(e3, r3) {
            return t2 = e3, n2 = r3, s2();
          };
        }
        function Sh(t2, n2) {
          return Th()(t2, n2);
        }
        function kh(n2, e2, r2, i2) {
          var o2, a2 = w(n2, e2, r2);
          switch ((i2 = wa(null == i2 ? ",f" : i2)).type) {
            case "s":
              var u2 = Math.max(Math.abs(n2), Math.abs(e2));
              return null != i2.precision || isNaN(o2 = za(a2, u2)) || (i2.precision = o2), t.formatPrefix(i2, u2);
            case "":
            case "e":
            case "g":
            case "p":
            case "r":
              null != i2.precision || isNaN(o2 = Ra(a2, Math.max(Math.abs(n2), Math.abs(e2)))) || (i2.precision = o2 - ("e" === i2.type));
              break;
            case "f":
            case "%":
              null != i2.precision || isNaN(o2 = Pa(a2)) || (i2.precision = o2 - 2 * ("%" === i2.type));
          }
          return t.format(i2);
        }
        function Eh(t2) {
          var n2 = t2.domain;
          return t2.ticks = function(t3) {
            var e2 = n2();
            return m(e2[0], e2[e2.length - 1], null == t3 ? 10 : t3);
          }, t2.tickFormat = function(t3, e2) {
            var r2 = n2();
            return kh(r2[0], r2[r2.length - 1], null == t3 ? 10 : t3, e2);
          }, t2.nice = function(e2) {
            null == e2 && (e2 = 10);
            var r2, i2 = n2(), o2 = 0, a2 = i2.length - 1, u2 = i2[o2], c2 = i2[a2];
            return c2 < u2 && (r2 = u2, u2 = c2, c2 = r2, r2 = o2, o2 = a2, a2 = r2), (r2 = x(u2, c2, e2)) > 0 ? r2 = x(u2 = Math.floor(u2 / r2) * r2, c2 = Math.ceil(c2 / r2) * r2, e2) : r2 < 0 && (r2 = x(u2 = Math.ceil(u2 * r2) / r2, c2 = Math.floor(c2 * r2) / r2, e2)), r2 > 0 ? (i2[o2] = Math.floor(u2 / r2) * r2, i2[a2] = Math.ceil(c2 / r2) * r2, n2(i2)) : r2 < 0 && (i2[o2] = Math.ceil(u2 * r2) / r2, i2[a2] = Math.floor(c2 * r2) / r2, n2(i2)), t2;
          }, t2;
        }
        function Ch(t2, n2) {
          var e2, r2 = 0, i2 = (t2 = t2.slice()).length - 1, o2 = t2[r2], a2 = t2[i2];
          return a2 < o2 && (e2 = r2, r2 = i2, i2 = e2, e2 = o2, o2 = a2, a2 = e2), t2[r2] = n2.floor(o2), t2[i2] = n2.ceil(a2), t2;
        }
        function Ph(t2) {
          return Math.log(t2);
        }
        function zh(t2) {
          return Math.exp(t2);
        }
        function Rh(t2) {
          return -Math.log(-t2);
        }
        function Dh(t2) {
          return -Math.exp(-t2);
        }
        function qh(t2) {
          return isFinite(t2) ? +("1e" + t2) : t2 < 0 ? 0 : t2;
        }
        function Lh(t2) {
          return function(n2) {
            return -t2(-n2);
          };
        }
        function Uh(n2) {
          var e2, r2, i2 = n2(Ph, zh), o2 = i2.domain, a2 = 10;
          function u2() {
            return e2 = function(t2) {
              return t2 === Math.E ? Math.log : 10 === t2 && Math.log10 || 2 === t2 && Math.log2 || (t2 = Math.log(t2), function(n3) {
                return Math.log(n3) / t2;
              });
            }(a2), r2 = function(t2) {
              return 10 === t2 ? qh : t2 === Math.E ? Math.exp : function(n3) {
                return Math.pow(t2, n3);
              };
            }(a2), o2()[0] < 0 ? (e2 = Lh(e2), r2 = Lh(r2), n2(Rh, Dh)) : n2(Ph, zh), i2;
          }
          return i2.base = function(t2) {
            return arguments.length ? (a2 = +t2, u2()) : a2;
          }, i2.domain = function(t2) {
            return arguments.length ? (o2(t2), u2()) : o2();
          }, i2.ticks = function(t2) {
            var n3, i3 = o2(), u3 = i3[0], c2 = i3[i3.length - 1];
            (n3 = c2 < u3) && (h2 = u3, u3 = c2, c2 = h2);
            var f2, s2, l2, h2 = e2(u3), d2 = e2(c2), p2 = null == t2 ? 10 : +t2, v2 = [];
            if (!(a2 % 1) && d2 - h2 < p2) {
              if (h2 = Math.round(h2) - 1, d2 = Math.round(d2) + 1, u3 > 0) {
                for (; h2 < d2; ++h2)
                  for (s2 = 1, f2 = r2(h2); s2 < a2; ++s2)
                    if (!((l2 = f2 * s2) < u3)) {
                      if (l2 > c2)
                        break;
                      v2.push(l2);
                    }
              } else
                for (; h2 < d2; ++h2)
                  for (s2 = a2 - 1, f2 = r2(h2); s2 >= 1; --s2)
                    if (!((l2 = f2 * s2) < u3)) {
                      if (l2 > c2)
                        break;
                      v2.push(l2);
                    }
            } else
              v2 = m(h2, d2, Math.min(d2 - h2, p2)).map(r2);
            return n3 ? v2.reverse() : v2;
          }, i2.tickFormat = function(n3, o3) {
            if (null == o3 && (o3 = 10 === a2 ? ".0e" : ","), "function" != typeof o3 && (o3 = t.format(o3)), n3 === 1 / 0)
              return o3;
            null == n3 && (n3 = 10);
            var u3 = Math.max(1, a2 * n3 / i2.ticks().length);
            return function(t2) {
              var n4 = t2 / r2(Math.round(e2(t2)));
              return n4 * a2 < a2 - 0.5 && (n4 *= a2), n4 <= u3 ? o3(t2) : "";
            };
          }, i2.nice = function() {
            return o2(Ch(o2(), { floor: function(t2) {
              return r2(Math.floor(e2(t2)));
            }, ceil: function(t2) {
              return r2(Math.ceil(e2(t2)));
            } }));
          }, i2;
        }
        function Oh(t2) {
          return function(n2) {
            return Math.sign(n2) * Math.log1p(Math.abs(n2 / t2));
          };
        }
        function Bh(t2) {
          return function(n2) {
            return Math.sign(n2) * Math.expm1(Math.abs(n2)) * t2;
          };
        }
        function Yh(t2) {
          var n2 = 1, e2 = t2(Oh(n2), Bh(n2));
          return e2.constant = function(e3) {
            return arguments.length ? t2(Oh(n2 = +e3), Bh(n2)) : n2;
          }, Eh(e2);
        }
        function Fh(t2) {
          return function(n2) {
            return n2 < 0 ? -Math.pow(-n2, t2) : Math.pow(n2, t2);
          };
        }
        function Ih(t2) {
          return t2 < 0 ? -Math.sqrt(-t2) : Math.sqrt(t2);
        }
        function jh(t2) {
          return t2 < 0 ? -t2 * t2 : t2 * t2;
        }
        function Hh(t2) {
          var n2 = t2(mh, mh), e2 = 1;
          return n2.exponent = function(n3) {
            return arguments.length ? 1 === (e2 = +n3) ? t2(mh, mh) : 0.5 === e2 ? t2(Ih, jh) : t2(Fh(e2), Fh(1 / e2)) : e2;
          }, Eh(n2);
        }
        function Xh() {
          var t2 = Hh(Th());
          return t2.copy = function() {
            return Ah(t2, Xh()).exponent(t2.exponent());
          }, sh.apply(t2, arguments), t2;
        }
        var Gh = /* @__PURE__ */ new Date(), Vh = /* @__PURE__ */ new Date();
        function $h(t2, n2, e2, r2) {
          function i2(n3) {
            return t2(n3 = /* @__PURE__ */ new Date(+n3)), n3;
          }
          return i2.floor = i2, i2.ceil = function(e3) {
            return t2(e3 = new Date(e3 - 1)), n2(e3, 1), t2(e3), e3;
          }, i2.round = function(t3) {
            var n3 = i2(t3), e3 = i2.ceil(t3);
            return t3 - n3 < e3 - t3 ? n3 : e3;
          }, i2.offset = function(t3, e3) {
            return n2(t3 = /* @__PURE__ */ new Date(+t3), null == e3 ? 1 : Math.floor(e3)), t3;
          }, i2.range = function(e3, r3, o2) {
            var a2, u2 = [];
            if (e3 = i2.ceil(e3), o2 = null == o2 ? 1 : Math.floor(o2), !(e3 < r3 && o2 > 0))
              return u2;
            do {
              u2.push(a2 = /* @__PURE__ */ new Date(+e3)), n2(e3, o2), t2(e3);
            } while (a2 < e3 && e3 < r3);
            return u2;
          }, i2.filter = function(e3) {
            return $h(function(n3) {
              if (n3 >= n3)
                for (; t2(n3), !e3(n3); )
                  n3.setTime(n3 - 1);
            }, function(t3, r3) {
              if (t3 >= t3)
                if (r3 < 0)
                  for (; ++r3 <= 0; )
                    for (; n2(t3, -1), !e3(t3); )
                      ;
                else
                  for (; --r3 >= 0; )
                    for (; n2(t3, 1), !e3(t3); )
                      ;
            });
          }, e2 && (i2.count = function(n3, r3) {
            return Gh.setTime(+n3), Vh.setTime(+r3), t2(Gh), t2(Vh), Math.floor(e2(Gh, Vh));
          }, i2.every = function(t3) {
            return t3 = Math.floor(t3), isFinite(t3) && t3 > 0 ? t3 > 1 ? i2.filter(r2 ? function(n3) {
              return r2(n3) % t3 == 0;
            } : function(n3) {
              return i2.count(0, n3) % t3 == 0;
            }) : i2 : null;
          }), i2;
        }
        var Wh = $h(function() {
        }, function(t2, n2) {
          t2.setTime(+t2 + n2);
        }, function(t2, n2) {
          return n2 - t2;
        });
        Wh.every = function(t2) {
          return t2 = Math.floor(t2), isFinite(t2) && t2 > 0 ? t2 > 1 ? $h(function(n2) {
            n2.setTime(Math.floor(n2 / t2) * t2);
          }, function(n2, e2) {
            n2.setTime(+n2 + e2 * t2);
          }, function(n2, e2) {
            return (e2 - n2) / t2;
          }) : Wh : null;
        };
        var Zh = Wh.range, Qh = 6e4, Jh = 6048e5, Kh = $h(function(t2) {
          t2.setTime(t2 - t2.getMilliseconds());
        }, function(t2, n2) {
          t2.setTime(+t2 + 1e3 * n2);
        }, function(t2, n2) {
          return (n2 - t2) / 1e3;
        }, function(t2) {
          return t2.getUTCSeconds();
        }), td = Kh.range, nd = $h(function(t2) {
          t2.setTime(t2 - t2.getMilliseconds() - 1e3 * t2.getSeconds());
        }, function(t2, n2) {
          t2.setTime(+t2 + n2 * Qh);
        }, function(t2, n2) {
          return (n2 - t2) / Qh;
        }, function(t2) {
          return t2.getMinutes();
        }), ed = nd.range, rd = $h(function(t2) {
          t2.setTime(t2 - t2.getMilliseconds() - 1e3 * t2.getSeconds() - t2.getMinutes() * Qh);
        }, function(t2, n2) {
          t2.setTime(+t2 + 36e5 * n2);
        }, function(t2, n2) {
          return (n2 - t2) / 36e5;
        }, function(t2) {
          return t2.getHours();
        }), id = rd.range, od = $h(function(t2) {
          t2.setHours(0, 0, 0, 0);
        }, function(t2, n2) {
          t2.setDate(t2.getDate() + n2);
        }, function(t2, n2) {
          return (n2 - t2 - (n2.getTimezoneOffset() - t2.getTimezoneOffset()) * Qh) / 864e5;
        }, function(t2) {
          return t2.getDate() - 1;
        }), ad = od.range;
        function ud(t2) {
          return $h(function(n2) {
            n2.setDate(n2.getDate() - (n2.getDay() + 7 - t2) % 7), n2.setHours(0, 0, 0, 0);
          }, function(t3, n2) {
            t3.setDate(t3.getDate() + 7 * n2);
          }, function(t3, n2) {
            return (n2 - t3 - (n2.getTimezoneOffset() - t3.getTimezoneOffset()) * Qh) / Jh;
          });
        }
        var cd = ud(0), fd = ud(1), sd = ud(2), ld = ud(3), hd = ud(4), dd = ud(5), pd = ud(6), vd = cd.range, gd = fd.range, yd = sd.range, _d = ld.range, bd = hd.range, md = dd.range, xd = pd.range, wd = $h(function(t2) {
          t2.setDate(1), t2.setHours(0, 0, 0, 0);
        }, function(t2, n2) {
          t2.setMonth(t2.getMonth() + n2);
        }, function(t2, n2) {
          return n2.getMonth() - t2.getMonth() + 12 * (n2.getFullYear() - t2.getFullYear());
        }, function(t2) {
          return t2.getMonth();
        }), Md = wd.range, Nd = $h(function(t2) {
          t2.setMonth(0, 1), t2.setHours(0, 0, 0, 0);
        }, function(t2, n2) {
          t2.setFullYear(t2.getFullYear() + n2);
        }, function(t2, n2) {
          return n2.getFullYear() - t2.getFullYear();
        }, function(t2) {
          return t2.getFullYear();
        });
        Nd.every = function(t2) {
          return isFinite(t2 = Math.floor(t2)) && t2 > 0 ? $h(function(n2) {
            n2.setFullYear(Math.floor(n2.getFullYear() / t2) * t2), n2.setMonth(0, 1), n2.setHours(0, 0, 0, 0);
          }, function(n2, e2) {
            n2.setFullYear(n2.getFullYear() + e2 * t2);
          }) : null;
        };
        var Ad = Nd.range, Td = $h(function(t2) {
          t2.setUTCSeconds(0, 0);
        }, function(t2, n2) {
          t2.setTime(+t2 + n2 * Qh);
        }, function(t2, n2) {
          return (n2 - t2) / Qh;
        }, function(t2) {
          return t2.getUTCMinutes();
        }), Sd = Td.range, kd = $h(function(t2) {
          t2.setUTCMinutes(0, 0, 0);
        }, function(t2, n2) {
          t2.setTime(+t2 + 36e5 * n2);
        }, function(t2, n2) {
          return (n2 - t2) / 36e5;
        }, function(t2) {
          return t2.getUTCHours();
        }), Ed = kd.range, Cd = $h(function(t2) {
          t2.setUTCHours(0, 0, 0, 0);
        }, function(t2, n2) {
          t2.setUTCDate(t2.getUTCDate() + n2);
        }, function(t2, n2) {
          return (n2 - t2) / 864e5;
        }, function(t2) {
          return t2.getUTCDate() - 1;
        }), Pd = Cd.range;
        function zd(t2) {
          return $h(function(n2) {
            n2.setUTCDate(n2.getUTCDate() - (n2.getUTCDay() + 7 - t2) % 7), n2.setUTCHours(0, 0, 0, 0);
          }, function(t3, n2) {
            t3.setUTCDate(t3.getUTCDate() + 7 * n2);
          }, function(t3, n2) {
            return (n2 - t3) / Jh;
          });
        }
        var Rd = zd(0), Dd = zd(1), qd = zd(2), Ld = zd(3), Ud = zd(4), Od = zd(5), Bd = zd(6), Yd = Rd.range, Fd = Dd.range, Id = qd.range, jd = Ld.range, Hd = Ud.range, Xd = Od.range, Gd = Bd.range, Vd = $h(function(t2) {
          t2.setUTCDate(1), t2.setUTCHours(0, 0, 0, 0);
        }, function(t2, n2) {
          t2.setUTCMonth(t2.getUTCMonth() + n2);
        }, function(t2, n2) {
          return n2.getUTCMonth() - t2.getUTCMonth() + 12 * (n2.getUTCFullYear() - t2.getUTCFullYear());
        }, function(t2) {
          return t2.getUTCMonth();
        }), $d = Vd.range, Wd = $h(function(t2) {
          t2.setUTCMonth(0, 1), t2.setUTCHours(0, 0, 0, 0);
        }, function(t2, n2) {
          t2.setUTCFullYear(t2.getUTCFullYear() + n2);
        }, function(t2, n2) {
          return n2.getUTCFullYear() - t2.getUTCFullYear();
        }, function(t2) {
          return t2.getUTCFullYear();
        });
        Wd.every = function(t2) {
          return isFinite(t2 = Math.floor(t2)) && t2 > 0 ? $h(function(n2) {
            n2.setUTCFullYear(Math.floor(n2.getUTCFullYear() / t2) * t2), n2.setUTCMonth(0, 1), n2.setUTCHours(0, 0, 0, 0);
          }, function(n2, e2) {
            n2.setUTCFullYear(n2.getUTCFullYear() + e2 * t2);
          }) : null;
        };
        var Zd = Wd.range;
        function Qd(t2) {
          if (0 <= t2.y && t2.y < 100) {
            var n2 = new Date(-1, t2.m, t2.d, t2.H, t2.M, t2.S, t2.L);
            return n2.setFullYear(t2.y), n2;
          }
          return new Date(t2.y, t2.m, t2.d, t2.H, t2.M, t2.S, t2.L);
        }
        function Jd(t2) {
          if (0 <= t2.y && t2.y < 100) {
            var n2 = new Date(Date.UTC(-1, t2.m, t2.d, t2.H, t2.M, t2.S, t2.L));
            return n2.setUTCFullYear(t2.y), n2;
          }
          return new Date(Date.UTC(t2.y, t2.m, t2.d, t2.H, t2.M, t2.S, t2.L));
        }
        function Kd(t2) {
          return { y: t2, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0 };
        }
        function tp(t2) {
          var n2 = t2.dateTime, e2 = t2.date, r2 = t2.time, i2 = t2.periods, o2 = t2.days, a2 = t2.shortDays, u2 = t2.months, c2 = t2.shortMonths, f2 = cp(i2), s2 = fp(i2), l2 = cp(o2), h2 = fp(o2), d2 = cp(a2), p2 = fp(a2), v2 = cp(u2), g2 = fp(u2), y2 = cp(c2), _2 = fp(c2), b2 = { a: function(t3) {
            return a2[t3.getDay()];
          }, A: function(t3) {
            return o2[t3.getDay()];
          }, b: function(t3) {
            return c2[t3.getMonth()];
          }, B: function(t3) {
            return u2[t3.getMonth()];
          }, c: null, d: Ep, e: Ep, f: Dp, H: Cp, I: Pp, j: zp, L: Rp, m: qp, M: Lp, p: function(t3) {
            return i2[+(t3.getHours() >= 12)];
          }, Q: sv, s: lv, S: Up, u: Op, U: Bp, V: Yp, w: Fp, W: Ip, x: null, X: null, y: jp, Y: Hp, Z: Xp, "%": fv }, m2 = { a: function(t3) {
            return a2[t3.getUTCDay()];
          }, A: function(t3) {
            return o2[t3.getUTCDay()];
          }, b: function(t3) {
            return c2[t3.getUTCMonth()];
          }, B: function(t3) {
            return u2[t3.getUTCMonth()];
          }, c: null, d: Gp, e: Gp, f: Qp, H: Vp, I: $p, j: Wp, L: Zp, m: Jp, M: Kp, p: function(t3) {
            return i2[+(t3.getUTCHours() >= 12)];
          }, Q: sv, s: lv, S: tv, u: nv, U: ev, V: rv, w: iv, W: ov, x: null, X: null, y: av, Y: uv, Z: cv, "%": fv }, x2 = { a: function(t3, n3, e3) {
            var r3 = d2.exec(n3.slice(e3));
            return r3 ? (t3.w = p2[r3[0].toLowerCase()], e3 + r3[0].length) : -1;
          }, A: function(t3, n3, e3) {
            var r3 = l2.exec(n3.slice(e3));
            return r3 ? (t3.w = h2[r3[0].toLowerCase()], e3 + r3[0].length) : -1;
          }, b: function(t3, n3, e3) {
            var r3 = y2.exec(n3.slice(e3));
            return r3 ? (t3.m = _2[r3[0].toLowerCase()], e3 + r3[0].length) : -1;
          }, B: function(t3, n3, e3) {
            var r3 = v2.exec(n3.slice(e3));
            return r3 ? (t3.m = g2[r3[0].toLowerCase()], e3 + r3[0].length) : -1;
          }, c: function(t3, e3, r3) {
            return N2(t3, n2, e3, r3);
          }, d: bp, e: bp, f: Ap, H: xp, I: xp, j: mp, L: Np, m: _p, M: wp, p: function(t3, n3, e3) {
            var r3 = f2.exec(n3.slice(e3));
            return r3 ? (t3.p = s2[r3[0].toLowerCase()], e3 + r3[0].length) : -1;
          }, Q: Sp, s: kp, S: Mp, u: lp, U: hp, V: dp, w: sp, W: pp, x: function(t3, n3, r3) {
            return N2(t3, e2, n3, r3);
          }, X: function(t3, n3, e3) {
            return N2(t3, r2, n3, e3);
          }, y: gp, Y: vp, Z: yp, "%": Tp };
          function w2(t3, n3) {
            return function(e3) {
              var r3, i3, o3, a3 = [], u3 = -1, c3 = 0, f3 = t3.length;
              for (e3 instanceof Date || (e3 = /* @__PURE__ */ new Date(+e3)); ++u3 < f3; )
                37 === t3.charCodeAt(u3) && (a3.push(t3.slice(c3, u3)), null != (i3 = ep[r3 = t3.charAt(++u3)]) ? r3 = t3.charAt(++u3) : i3 = "e" === r3 ? " " : "0", (o3 = n3[r3]) && (r3 = o3(e3, i3)), a3.push(r3), c3 = u3 + 1);
              return a3.push(t3.slice(c3, u3)), a3.join("");
            };
          }
          function M2(t3, n3) {
            return function(e3) {
              var r3, i3, o3 = Kd(1900);
              if (N2(o3, t3, e3 += "", 0) != e3.length)
                return null;
              if ("Q" in o3)
                return new Date(o3.Q);
              if ("p" in o3 && (o3.H = o3.H % 12 + 12 * o3.p), "V" in o3) {
                if (o3.V < 1 || o3.V > 53)
                  return null;
                "w" in o3 || (o3.w = 1), "Z" in o3 ? (i3 = (r3 = Jd(Kd(o3.y))).getUTCDay(), r3 = i3 > 4 || 0 === i3 ? Dd.ceil(r3) : Dd(r3), r3 = Cd.offset(r3, 7 * (o3.V - 1)), o3.y = r3.getUTCFullYear(), o3.m = r3.getUTCMonth(), o3.d = r3.getUTCDate() + (o3.w + 6) % 7) : (i3 = (r3 = n3(Kd(o3.y))).getDay(), r3 = i3 > 4 || 0 === i3 ? fd.ceil(r3) : fd(r3), r3 = od.offset(r3, 7 * (o3.V - 1)), o3.y = r3.getFullYear(), o3.m = r3.getMonth(), o3.d = r3.getDate() + (o3.w + 6) % 7);
              } else
                ("W" in o3 || "U" in o3) && ("w" in o3 || (o3.w = "u" in o3 ? o3.u % 7 : "W" in o3 ? 1 : 0), i3 = "Z" in o3 ? Jd(Kd(o3.y)).getUTCDay() : n3(Kd(o3.y)).getDay(), o3.m = 0, o3.d = "W" in o3 ? (o3.w + 6) % 7 + 7 * o3.W - (i3 + 5) % 7 : o3.w + 7 * o3.U - (i3 + 6) % 7);
              return "Z" in o3 ? (o3.H += o3.Z / 100 | 0, o3.M += o3.Z % 100, Jd(o3)) : n3(o3);
            };
          }
          function N2(t3, n3, e3, r3) {
            for (var i3, o3, a3 = 0, u3 = n3.length, c3 = e3.length; a3 < u3; ) {
              if (r3 >= c3)
                return -1;
              if (37 === (i3 = n3.charCodeAt(a3++))) {
                if (i3 = n3.charAt(a3++), !(o3 = x2[i3 in ep ? n3.charAt(a3++) : i3]) || (r3 = o3(t3, e3, r3)) < 0)
                  return -1;
              } else if (i3 != e3.charCodeAt(r3++))
                return -1;
            }
            return r3;
          }
          return b2.x = w2(e2, b2), b2.X = w2(r2, b2), b2.c = w2(n2, b2), m2.x = w2(e2, m2), m2.X = w2(r2, m2), m2.c = w2(n2, m2), { format: function(t3) {
            var n3 = w2(t3 += "", b2);
            return n3.toString = function() {
              return t3;
            }, n3;
          }, parse: function(t3) {
            var n3 = M2(t3 += "", Qd);
            return n3.toString = function() {
              return t3;
            }, n3;
          }, utcFormat: function(t3) {
            var n3 = w2(t3 += "", m2);
            return n3.toString = function() {
              return t3;
            }, n3;
          }, utcParse: function(t3) {
            var n3 = M2(t3, Jd);
            return n3.toString = function() {
              return t3;
            }, n3;
          } };
        }
        var np, ep = { "-": "", _: " ", 0: "0" }, rp = /^\s*\d+/, ip = /^%/, op = /[\\^$*+?|[\]().{}]/g;
        function ap(t2, n2, e2) {
          var r2 = t2 < 0 ? "-" : "", i2 = (r2 ? -t2 : t2) + "", o2 = i2.length;
          return r2 + (o2 < e2 ? new Array(e2 - o2 + 1).join(n2) + i2 : i2);
        }
        function up(t2) {
          return t2.replace(op, "\\$&");
        }
        function cp(t2) {
          return new RegExp("^(?:" + t2.map(up).join("|") + ")", "i");
        }
        function fp(t2) {
          for (var n2 = {}, e2 = -1, r2 = t2.length; ++e2 < r2; )
            n2[t2[e2].toLowerCase()] = e2;
          return n2;
        }
        function sp(t2, n2, e2) {
          var r2 = rp.exec(n2.slice(e2, e2 + 1));
          return r2 ? (t2.w = +r2[0], e2 + r2[0].length) : -1;
        }
        function lp(t2, n2, e2) {
          var r2 = rp.exec(n2.slice(e2, e2 + 1));
          return r2 ? (t2.u = +r2[0], e2 + r2[0].length) : -1;
        }
        function hp(t2, n2, e2) {
          var r2 = rp.exec(n2.slice(e2, e2 + 2));
          return r2 ? (t2.U = +r2[0], e2 + r2[0].length) : -1;
        }
        function dp(t2, n2, e2) {
          var r2 = rp.exec(n2.slice(e2, e2 + 2));
          return r2 ? (t2.V = +r2[0], e2 + r2[0].length) : -1;
        }
        function pp(t2, n2, e2) {
          var r2 = rp.exec(n2.slice(e2, e2 + 2));
          return r2 ? (t2.W = +r2[0], e2 + r2[0].length) : -1;
        }
        function vp(t2, n2, e2) {
          var r2 = rp.exec(n2.slice(e2, e2 + 4));
          return r2 ? (t2.y = +r2[0], e2 + r2[0].length) : -1;
        }
        function gp(t2, n2, e2) {
          var r2 = rp.exec(n2.slice(e2, e2 + 2));
          return r2 ? (t2.y = +r2[0] + (+r2[0] > 68 ? 1900 : 2e3), e2 + r2[0].length) : -1;
        }
        function yp(t2, n2, e2) {
          var r2 = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(n2.slice(e2, e2 + 6));
          return r2 ? (t2.Z = r2[1] ? 0 : -(r2[2] + (r2[3] || "00")), e2 + r2[0].length) : -1;
        }
        function _p(t2, n2, e2) {
          var r2 = rp.exec(n2.slice(e2, e2 + 2));
          return r2 ? (t2.m = r2[0] - 1, e2 + r2[0].length) : -1;
        }
        function bp(t2, n2, e2) {
          var r2 = rp.exec(n2.slice(e2, e2 + 2));
          return r2 ? (t2.d = +r2[0], e2 + r2[0].length) : -1;
        }
        function mp(t2, n2, e2) {
          var r2 = rp.exec(n2.slice(e2, e2 + 3));
          return r2 ? (t2.m = 0, t2.d = +r2[0], e2 + r2[0].length) : -1;
        }
        function xp(t2, n2, e2) {
          var r2 = rp.exec(n2.slice(e2, e2 + 2));
          return r2 ? (t2.H = +r2[0], e2 + r2[0].length) : -1;
        }
        function wp(t2, n2, e2) {
          var r2 = rp.exec(n2.slice(e2, e2 + 2));
          return r2 ? (t2.M = +r2[0], e2 + r2[0].length) : -1;
        }
        function Mp(t2, n2, e2) {
          var r2 = rp.exec(n2.slice(e2, e2 + 2));
          return r2 ? (t2.S = +r2[0], e2 + r2[0].length) : -1;
        }
        function Np(t2, n2, e2) {
          var r2 = rp.exec(n2.slice(e2, e2 + 3));
          return r2 ? (t2.L = +r2[0], e2 + r2[0].length) : -1;
        }
        function Ap(t2, n2, e2) {
          var r2 = rp.exec(n2.slice(e2, e2 + 6));
          return r2 ? (t2.L = Math.floor(r2[0] / 1e3), e2 + r2[0].length) : -1;
        }
        function Tp(t2, n2, e2) {
          var r2 = ip.exec(n2.slice(e2, e2 + 1));
          return r2 ? e2 + r2[0].length : -1;
        }
        function Sp(t2, n2, e2) {
          var r2 = rp.exec(n2.slice(e2));
          return r2 ? (t2.Q = +r2[0], e2 + r2[0].length) : -1;
        }
        function kp(t2, n2, e2) {
          var r2 = rp.exec(n2.slice(e2));
          return r2 ? (t2.Q = 1e3 * +r2[0], e2 + r2[0].length) : -1;
        }
        function Ep(t2, n2) {
          return ap(t2.getDate(), n2, 2);
        }
        function Cp(t2, n2) {
          return ap(t2.getHours(), n2, 2);
        }
        function Pp(t2, n2) {
          return ap(t2.getHours() % 12 || 12, n2, 2);
        }
        function zp(t2, n2) {
          return ap(1 + od.count(Nd(t2), t2), n2, 3);
        }
        function Rp(t2, n2) {
          return ap(t2.getMilliseconds(), n2, 3);
        }
        function Dp(t2, n2) {
          return Rp(t2, n2) + "000";
        }
        function qp(t2, n2) {
          return ap(t2.getMonth() + 1, n2, 2);
        }
        function Lp(t2, n2) {
          return ap(t2.getMinutes(), n2, 2);
        }
        function Up(t2, n2) {
          return ap(t2.getSeconds(), n2, 2);
        }
        function Op(t2) {
          var n2 = t2.getDay();
          return 0 === n2 ? 7 : n2;
        }
        function Bp(t2, n2) {
          return ap(cd.count(Nd(t2), t2), n2, 2);
        }
        function Yp(t2, n2) {
          var e2 = t2.getDay();
          return t2 = e2 >= 4 || 0 === e2 ? hd(t2) : hd.ceil(t2), ap(hd.count(Nd(t2), t2) + (4 === Nd(t2).getDay()), n2, 2);
        }
        function Fp(t2) {
          return t2.getDay();
        }
        function Ip(t2, n2) {
          return ap(fd.count(Nd(t2), t2), n2, 2);
        }
        function jp(t2, n2) {
          return ap(t2.getFullYear() % 100, n2, 2);
        }
        function Hp(t2, n2) {
          return ap(t2.getFullYear() % 1e4, n2, 4);
        }
        function Xp(t2) {
          var n2 = t2.getTimezoneOffset();
          return (n2 > 0 ? "-" : (n2 *= -1, "+")) + ap(n2 / 60 | 0, "0", 2) + ap(n2 % 60, "0", 2);
        }
        function Gp(t2, n2) {
          return ap(t2.getUTCDate(), n2, 2);
        }
        function Vp(t2, n2) {
          return ap(t2.getUTCHours(), n2, 2);
        }
        function $p(t2, n2) {
          return ap(t2.getUTCHours() % 12 || 12, n2, 2);
        }
        function Wp(t2, n2) {
          return ap(1 + Cd.count(Wd(t2), t2), n2, 3);
        }
        function Zp(t2, n2) {
          return ap(t2.getUTCMilliseconds(), n2, 3);
        }
        function Qp(t2, n2) {
          return Zp(t2, n2) + "000";
        }
        function Jp(t2, n2) {
          return ap(t2.getUTCMonth() + 1, n2, 2);
        }
        function Kp(t2, n2) {
          return ap(t2.getUTCMinutes(), n2, 2);
        }
        function tv(t2, n2) {
          return ap(t2.getUTCSeconds(), n2, 2);
        }
        function nv(t2) {
          var n2 = t2.getUTCDay();
          return 0 === n2 ? 7 : n2;
        }
        function ev(t2, n2) {
          return ap(Rd.count(Wd(t2), t2), n2, 2);
        }
        function rv(t2, n2) {
          var e2 = t2.getUTCDay();
          return t2 = e2 >= 4 || 0 === e2 ? Ud(t2) : Ud.ceil(t2), ap(Ud.count(Wd(t2), t2) + (4 === Wd(t2).getUTCDay()), n2, 2);
        }
        function iv(t2) {
          return t2.getUTCDay();
        }
        function ov(t2, n2) {
          return ap(Dd.count(Wd(t2), t2), n2, 2);
        }
        function av(t2, n2) {
          return ap(t2.getUTCFullYear() % 100, n2, 2);
        }
        function uv(t2, n2) {
          return ap(t2.getUTCFullYear() % 1e4, n2, 4);
        }
        function cv() {
          return "+0000";
        }
        function fv() {
          return "%";
        }
        function sv(t2) {
          return +t2;
        }
        function lv(t2) {
          return Math.floor(+t2 / 1e3);
        }
        function hv(n2) {
          return np = tp(n2), t.timeFormat = np.format, t.timeParse = np.parse, t.utcFormat = np.utcFormat, t.utcParse = np.utcParse, np;
        }
        hv({ dateTime: "%x, %X", date: "%-m/%-d/%Y", time: "%-I:%M:%S %p", periods: ["AM", "PM"], days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"] });
        var dv = Date.prototype.toISOString ? function(t2) {
          return t2.toISOString();
        } : t.utcFormat("%Y-%m-%dT%H:%M:%S.%LZ");
        var pv = +/* @__PURE__ */ new Date("2000-01-01T00:00:00.000Z") ? function(t2) {
          var n2 = new Date(t2);
          return isNaN(n2) ? null : n2;
        } : t.utcParse("%Y-%m-%dT%H:%M:%S.%LZ"), vv = 1e3, gv = 60 * vv, yv = 60 * gv, _v = 24 * yv, bv = 7 * _v, mv = 30 * _v, xv = 365 * _v;
        function wv(t2) {
          return new Date(t2);
        }
        function Mv(t2) {
          return t2 instanceof Date ? +t2 : +/* @__PURE__ */ new Date(+t2);
        }
        function Nv(t2, n2, r2, i2, o2, a2, u2, c2, f2) {
          var s2 = Sh(mh, mh), l2 = s2.invert, h2 = s2.domain, d2 = f2(".%L"), p2 = f2(":%S"), v2 = f2("%I:%M"), g2 = f2("%I %p"), y2 = f2("%a %d"), _2 = f2("%b %d"), b2 = f2("%B"), m2 = f2("%Y"), x2 = [[u2, 1, vv], [u2, 5, 5 * vv], [u2, 15, 15 * vv], [u2, 30, 30 * vv], [a2, 1, gv], [a2, 5, 5 * gv], [a2, 15, 15 * gv], [a2, 30, 30 * gv], [o2, 1, yv], [o2, 3, 3 * yv], [o2, 6, 6 * yv], [o2, 12, 12 * yv], [i2, 1, _v], [i2, 2, 2 * _v], [r2, 1, bv], [n2, 1, mv], [n2, 3, 3 * mv], [t2, 1, xv]];
          function M2(e2) {
            return (u2(e2) < e2 ? d2 : a2(e2) < e2 ? p2 : o2(e2) < e2 ? v2 : i2(e2) < e2 ? g2 : n2(e2) < e2 ? r2(e2) < e2 ? y2 : _2 : t2(e2) < e2 ? b2 : m2)(e2);
          }
          function N2(n3, r3, i3, o3) {
            if (null == n3 && (n3 = 10), "number" == typeof n3) {
              var a3 = Math.abs(i3 - r3) / n3, u3 = e(function(t3) {
                return t3[2];
              }).right(x2, a3);
              u3 === x2.length ? (o3 = w(r3 / xv, i3 / xv, n3), n3 = t2) : u3 ? (o3 = (u3 = x2[a3 / x2[u3 - 1][2] < x2[u3][2] / a3 ? u3 - 1 : u3])[1], n3 = u3[0]) : (o3 = Math.max(w(r3, i3, n3), 1), n3 = c2);
            }
            return null == o3 ? n3 : n3.every(o3);
          }
          return s2.invert = function(t3) {
            return new Date(l2(t3));
          }, s2.domain = function(t3) {
            return arguments.length ? h2(dh.call(t3, Mv)) : h2().map(wv);
          }, s2.ticks = function(t3, n3) {
            var e2, r3 = h2(), i3 = r3[0], o3 = r3[r3.length - 1], a3 = o3 < i3;
            return a3 && (e2 = i3, i3 = o3, o3 = e2), e2 = (e2 = N2(t3, i3, o3, n3)) ? e2.range(i3, o3 + 1) : [], a3 ? e2.reverse() : e2;
          }, s2.tickFormat = function(t3, n3) {
            return null == n3 ? M2 : f2(n3);
          }, s2.nice = function(t3, n3) {
            var e2 = h2();
            return (t3 = N2(t3, e2[0], e2[e2.length - 1], n3)) ? h2(Ch(e2, t3)) : s2;
          }, s2.copy = function() {
            return Ah(s2, Nv(t2, n2, r2, i2, o2, a2, u2, c2, f2));
          }, s2;
        }
        function Av() {
          var t2, n2, e2, r2, i2, o2 = 0, a2 = 1, u2 = mh, c2 = false;
          function f2(n3) {
            return isNaN(n3 = +n3) ? i2 : u2(0 === e2 ? 0.5 : (n3 = (r2(n3) - t2) * e2, c2 ? Math.max(0, Math.min(1, n3)) : n3));
          }
          return f2.domain = function(i3) {
            return arguments.length ? (t2 = r2(o2 = +i3[0]), n2 = r2(a2 = +i3[1]), e2 = t2 === n2 ? 0 : 1 / (n2 - t2), f2) : [o2, a2];
          }, f2.clamp = function(t3) {
            return arguments.length ? (c2 = !!t3, f2) : c2;
          }, f2.interpolator = function(t3) {
            return arguments.length ? (u2 = t3, f2) : u2;
          }, f2.unknown = function(t3) {
            return arguments.length ? (i2 = t3, f2) : i2;
          }, function(i3) {
            return r2 = i3, t2 = i3(o2), n2 = i3(a2), e2 = t2 === n2 ? 0 : 1 / (n2 - t2), f2;
          };
        }
        function Tv(t2, n2) {
          return n2.domain(t2.domain()).interpolator(t2.interpolator()).clamp(t2.clamp()).unknown(t2.unknown());
        }
        function Sv() {
          var t2 = Hh(Av());
          return t2.copy = function() {
            return Tv(t2, Sv()).exponent(t2.exponent());
          }, lh.apply(t2, arguments);
        }
        function kv() {
          var t2, n2, e2, r2, i2, o2, a2, u2 = 0, c2 = 0.5, f2 = 1, s2 = mh, l2 = false;
          function h2(t3) {
            return isNaN(t3 = +t3) ? a2 : (t3 = 0.5 + ((t3 = +o2(t3)) - n2) * (t3 < n2 ? r2 : i2), s2(l2 ? Math.max(0, Math.min(1, t3)) : t3));
          }
          return h2.domain = function(a3) {
            return arguments.length ? (t2 = o2(u2 = +a3[0]), n2 = o2(c2 = +a3[1]), e2 = o2(f2 = +a3[2]), r2 = t2 === n2 ? 0 : 0.5 / (n2 - t2), i2 = n2 === e2 ? 0 : 0.5 / (e2 - n2), h2) : [u2, c2, f2];
          }, h2.clamp = function(t3) {
            return arguments.length ? (l2 = !!t3, h2) : l2;
          }, h2.interpolator = function(t3) {
            return arguments.length ? (s2 = t3, h2) : s2;
          }, h2.unknown = function(t3) {
            return arguments.length ? (a2 = t3, h2) : a2;
          }, function(a3) {
            return o2 = a3, t2 = a3(u2), n2 = a3(c2), e2 = a3(f2), r2 = t2 === n2 ? 0 : 0.5 / (n2 - t2), i2 = n2 === e2 ? 0 : 0.5 / (e2 - n2), h2;
          };
        }
        function Ev() {
          var t2 = Hh(kv());
          return t2.copy = function() {
            return Tv(t2, Ev()).exponent(t2.exponent());
          }, lh.apply(t2, arguments);
        }
        function Cv(t2) {
          for (var n2 = t2.length / 6 | 0, e2 = new Array(n2), r2 = 0; r2 < n2; )
            e2[r2] = "#" + t2.slice(6 * r2, 6 * ++r2);
          return e2;
        }
        var Pv = Cv("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf"), zv = Cv("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666"), Rv = Cv("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666"), Dv = Cv("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928"), qv = Cv("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2"), Lv = Cv("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc"), Uv = Cv("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999"), Ov = Cv("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3"), Bv = Cv("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");
        function Yv(t2) {
          return ce(t2[t2.length - 1]);
        }
        var Fv = new Array(3).concat("d8b365f5f5f55ab4ac", "a6611adfc27d80cdc1018571", "a6611adfc27df5f5f580cdc1018571", "8c510ad8b365f6e8c3c7eae55ab4ac01665e", "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e", "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e", "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e", "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30", "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30").map(Cv), Iv = Yv(Fv), jv = new Array(3).concat("af8dc3f7f7f77fbf7b", "7b3294c2a5cfa6dba0008837", "7b3294c2a5cff7f7f7a6dba0008837", "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837", "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837", "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837", "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837", "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b", "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b").map(Cv), Hv = Yv(jv), Xv = new Array(3).concat("e9a3c9f7f7f7a1d76a", "d01c8bf1b6dab8e1864dac26", "d01c8bf1b6daf7f7f7b8e1864dac26", "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221", "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221", "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221", "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221", "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419", "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419").map(Cv), Gv = Yv(Xv), Vv = new Array(3).concat("998ec3f7f7f7f1a340", "5e3c99b2abd2fdb863e66101", "5e3c99b2abd2f7f7f7fdb863e66101", "542788998ec3d8daebfee0b6f1a340b35806", "542788998ec3d8daebf7f7f7fee0b6f1a340b35806", "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806", "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806", "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08", "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08").map(Cv), $v = Yv(Vv), Wv = new Array(3).concat("ef8a62f7f7f767a9cf", "ca0020f4a58292c5de0571b0", "ca0020f4a582f7f7f792c5de0571b0", "b2182bef8a62fddbc7d1e5f067a9cf2166ac", "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac", "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac", "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac", "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061", "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061").map(Cv), Zv = Yv(Wv), Qv = new Array(3).concat("ef8a62ffffff999999", "ca0020f4a582bababa404040", "ca0020f4a582ffffffbababa404040", "b2182bef8a62fddbc7e0e0e09999994d4d4d", "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d", "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d", "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d", "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a", "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a").map(Cv), Jv = Yv(Qv), Kv = new Array(3).concat("fc8d59ffffbf91bfdb", "d7191cfdae61abd9e92c7bb6", "d7191cfdae61ffffbfabd9e92c7bb6", "d73027fc8d59fee090e0f3f891bfdb4575b4", "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4", "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4", "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4", "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695", "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695").map(Cv), tg = Yv(Kv), ng = new Array(3).concat("fc8d59ffffbf91cf60", "d7191cfdae61a6d96a1a9641", "d7191cfdae61ffffbfa6d96a1a9641", "d73027fc8d59fee08bd9ef8b91cf601a9850", "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850", "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850", "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850", "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837", "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837").map(Cv), eg = Yv(ng), rg = new Array(3).concat("fc8d59ffffbf99d594", "d7191cfdae61abdda42b83ba", "d7191cfdae61ffffbfabdda42b83ba", "d53e4ffc8d59fee08be6f59899d5943288bd", "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd", "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd", "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd", "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2", "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2").map(Cv), ig = Yv(rg), og = new Array(3).concat("e5f5f999d8c92ca25f", "edf8fbb2e2e266c2a4238b45", "edf8fbb2e2e266c2a42ca25f006d2c", "edf8fbccece699d8c966c2a42ca25f006d2c", "edf8fbccece699d8c966c2a441ae76238b45005824", "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824", "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b").map(Cv), ag = Yv(og), ug = new Array(3).concat("e0ecf49ebcda8856a7", "edf8fbb3cde38c96c688419d", "edf8fbb3cde38c96c68856a7810f7c", "edf8fbbfd3e69ebcda8c96c68856a7810f7c", "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b", "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b", "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b").map(Cv), cg = Yv(ug), fg = new Array(3).concat("e0f3dba8ddb543a2ca", "f0f9e8bae4bc7bccc42b8cbe", "f0f9e8bae4bc7bccc443a2ca0868ac", "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac", "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e", "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e", "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081").map(Cv), sg = Yv(fg), lg = new Array(3).concat("fee8c8fdbb84e34a33", "fef0d9fdcc8afc8d59d7301f", "fef0d9fdcc8afc8d59e34a33b30000", "fef0d9fdd49efdbb84fc8d59e34a33b30000", "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000", "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000", "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000").map(Cv), hg = Yv(lg), dg = new Array(3).concat("ece2f0a6bddb1c9099", "f6eff7bdc9e167a9cf02818a", "f6eff7bdc9e167a9cf1c9099016c59", "f6eff7d0d1e6a6bddb67a9cf1c9099016c59", "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450", "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450", "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636").map(Cv), pg = Yv(dg), vg = new Array(3).concat("ece7f2a6bddb2b8cbe", "f1eef6bdc9e174a9cf0570b0", "f1eef6bdc9e174a9cf2b8cbe045a8d", "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d", "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b", "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b", "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858").map(Cv), gg = Yv(vg), yg = new Array(3).concat("e7e1efc994c7dd1c77", "f1eef6d7b5d8df65b0ce1256", "f1eef6d7b5d8df65b0dd1c77980043", "f1eef6d4b9dac994c7df65b0dd1c77980043", "f1eef6d4b9dac994c7df65b0e7298ace125691003f", "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f", "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f").map(Cv), _g = Yv(yg), bg = new Array(3).concat("fde0ddfa9fb5c51b8a", "feebe2fbb4b9f768a1ae017e", "feebe2fbb4b9f768a1c51b8a7a0177", "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177", "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177", "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177", "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a").map(Cv), mg = Yv(bg), xg = new Array(3).concat("edf8b17fcdbb2c7fb8", "ffffcca1dab441b6c4225ea8", "ffffcca1dab441b6c42c7fb8253494", "ffffccc7e9b47fcdbb41b6c42c7fb8253494", "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84", "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84", "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58").map(Cv), wg = Yv(xg), Mg = new Array(3).concat("f7fcb9addd8e31a354", "ffffccc2e69978c679238443", "ffffccc2e69978c67931a354006837", "ffffccd9f0a3addd8e78c67931a354006837", "ffffccd9f0a3addd8e78c67941ab5d238443005a32", "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32", "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529").map(Cv), Ng = Yv(Mg), Ag = new Array(3).concat("fff7bcfec44fd95f0e", "ffffd4fed98efe9929cc4c02", "ffffd4fed98efe9929d95f0e993404", "ffffd4fee391fec44ffe9929d95f0e993404", "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04", "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04", "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506").map(Cv), Tg = Yv(Ag), Sg = new Array(3).concat("ffeda0feb24cf03b20", "ffffb2fecc5cfd8d3ce31a1c", "ffffb2fecc5cfd8d3cf03b20bd0026", "ffffb2fed976feb24cfd8d3cf03b20bd0026", "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026", "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026", "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026").map(Cv), kg = Yv(Sg), Eg = new Array(3).concat("deebf79ecae13182bd", "eff3ffbdd7e76baed62171b5", "eff3ffbdd7e76baed63182bd08519c", "eff3ffc6dbef9ecae16baed63182bd08519c", "eff3ffc6dbef9ecae16baed64292c62171b5084594", "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594", "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b").map(Cv), Cg = Yv(Eg), Pg = new Array(3).concat("e5f5e0a1d99b31a354", "edf8e9bae4b374c476238b45", "edf8e9bae4b374c47631a354006d2c", "edf8e9c7e9c0a1d99b74c47631a354006d2c", "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32", "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32", "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b").map(Cv), zg = Yv(Pg), Rg = new Array(3).concat("f0f0f0bdbdbd636363", "f7f7f7cccccc969696525252", "f7f7f7cccccc969696636363252525", "f7f7f7d9d9d9bdbdbd969696636363252525", "f7f7f7d9d9d9bdbdbd969696737373525252252525", "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525", "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000").map(Cv), Dg = Yv(Rg), qg = new Array(3).concat("efedf5bcbddc756bb1", "f2f0f7cbc9e29e9ac86a51a3", "f2f0f7cbc9e29e9ac8756bb154278f", "f2f0f7dadaebbcbddc9e9ac8756bb154278f", "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486", "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486", "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d").map(Cv), Lg = Yv(qg), Ug = new Array(3).concat("fee0d2fc9272de2d26", "fee5d9fcae91fb6a4acb181d", "fee5d9fcae91fb6a4ade2d26a50f15", "fee5d9fcbba1fc9272fb6a4ade2d26a50f15", "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d", "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d", "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d").map(Cv), Og = Yv(Ug), Bg = new Array(3).concat("fee6cefdae6be6550d", "feeddefdbe85fd8d3cd94701", "feeddefdbe85fd8d3ce6550da63603", "feeddefdd0a2fdae6bfd8d3ce6550da63603", "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04", "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04", "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704").map(Cv), Yg = Yv(Bg), Fg = je(Zn(300, 0.5, 0), Zn(-240, 0.5, 1)), Ig = je(Zn(-100, 0.75, 0.35), Zn(80, 1.5, 0.8)), jg = je(Zn(260, 0.75, 0.35), Zn(80, 1.5, 0.8)), Hg = Zn();
        var Xg = gn(), Gg = Math.PI / 3, Vg = 2 * Math.PI / 3;
        function $g(t2) {
          var n2 = t2.length;
          return function(e2) {
            return t2[Math.max(0, Math.min(n2 - 1, Math.floor(e2 * n2)))];
          };
        }
        var Wg = $g(Cv("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725")), Zg = $g(Cv("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf")), Qg = $g(Cv("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4")), Jg = $g(Cv("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));
        function Kg(t2) {
          return function() {
            return t2;
          };
        }
        var ty = Math.abs, ny = Math.atan2, ey = Math.cos, ry = Math.max, iy = Math.min, oy = Math.sin, ay = Math.sqrt, uy = 1e-12, cy = Math.PI, fy = cy / 2, sy = 2 * cy;
        function ly(t2) {
          return t2 >= 1 ? fy : t2 <= -1 ? -fy : Math.asin(t2);
        }
        function hy(t2) {
          return t2.innerRadius;
        }
        function dy(t2) {
          return t2.outerRadius;
        }
        function py(t2) {
          return t2.startAngle;
        }
        function vy(t2) {
          return t2.endAngle;
        }
        function gy(t2) {
          return t2 && t2.padAngle;
        }
        function yy(t2, n2, e2, r2, i2, o2, a2) {
          var u2 = t2 - e2, c2 = n2 - r2, f2 = (a2 ? o2 : -o2) / ay(u2 * u2 + c2 * c2), s2 = f2 * c2, l2 = -f2 * u2, h2 = t2 + s2, d2 = n2 + l2, p2 = e2 + s2, v2 = r2 + l2, g2 = (h2 + p2) / 2, y2 = (d2 + v2) / 2, _2 = p2 - h2, b2 = v2 - d2, m2 = _2 * _2 + b2 * b2, x2 = i2 - o2, w2 = h2 * v2 - p2 * d2, M2 = (b2 < 0 ? -1 : 1) * ay(ry(0, x2 * x2 * m2 - w2 * w2)), N2 = (w2 * b2 - _2 * M2) / m2, A2 = (-w2 * _2 - b2 * M2) / m2, T2 = (w2 * b2 + _2 * M2) / m2, S2 = (-w2 * _2 + b2 * M2) / m2, k2 = N2 - g2, E2 = A2 - y2, C2 = T2 - g2, P2 = S2 - y2;
          return k2 * k2 + E2 * E2 > C2 * C2 + P2 * P2 && (N2 = T2, A2 = S2), { cx: N2, cy: A2, x01: -s2, y01: -l2, x11: N2 * (i2 / x2 - 1), y11: A2 * (i2 / x2 - 1) };
        }
        function _y(t2) {
          this._context = t2;
        }
        function by(t2) {
          return new _y(t2);
        }
        function my(t2) {
          return t2[0];
        }
        function xy(t2) {
          return t2[1];
        }
        function wy() {
          var t2 = my, n2 = xy, e2 = Kg(true), r2 = null, i2 = by, o2 = null;
          function a2(a3) {
            var u2, c2, f2, s2 = a3.length, l2 = false;
            for (null == r2 && (o2 = i2(f2 = Hi())), u2 = 0; u2 <= s2; ++u2)
              !(u2 < s2 && e2(c2 = a3[u2], u2, a3)) === l2 && ((l2 = !l2) ? o2.lineStart() : o2.lineEnd()), l2 && o2.point(+t2(c2, u2, a3), +n2(c2, u2, a3));
            if (f2)
              return o2 = null, f2 + "" || null;
          }
          return a2.x = function(n3) {
            return arguments.length ? (t2 = "function" == typeof n3 ? n3 : Kg(+n3), a2) : t2;
          }, a2.y = function(t3) {
            return arguments.length ? (n2 = "function" == typeof t3 ? t3 : Kg(+t3), a2) : n2;
          }, a2.defined = function(t3) {
            return arguments.length ? (e2 = "function" == typeof t3 ? t3 : Kg(!!t3), a2) : e2;
          }, a2.curve = function(t3) {
            return arguments.length ? (i2 = t3, null != r2 && (o2 = i2(r2)), a2) : i2;
          }, a2.context = function(t3) {
            return arguments.length ? (null == t3 ? r2 = o2 = null : o2 = i2(r2 = t3), a2) : r2;
          }, a2;
        }
        function My() {
          var t2 = my, n2 = null, e2 = Kg(0), r2 = xy, i2 = Kg(true), o2 = null, a2 = by, u2 = null;
          function c2(c3) {
            var f3, s2, l2, h2, d2, p2 = c3.length, v2 = false, g2 = new Array(p2), y2 = new Array(p2);
            for (null == o2 && (u2 = a2(d2 = Hi())), f3 = 0; f3 <= p2; ++f3) {
              if (!(f3 < p2 && i2(h2 = c3[f3], f3, c3)) === v2)
                if (v2 = !v2)
                  s2 = f3, u2.areaStart(), u2.lineStart();
                else {
                  for (u2.lineEnd(), u2.lineStart(), l2 = f3 - 1; l2 >= s2; --l2)
                    u2.point(g2[l2], y2[l2]);
                  u2.lineEnd(), u2.areaEnd();
                }
              v2 && (g2[f3] = +t2(h2, f3, c3), y2[f3] = +e2(h2, f3, c3), u2.point(n2 ? +n2(h2, f3, c3) : g2[f3], r2 ? +r2(h2, f3, c3) : y2[f3]));
            }
            if (d2)
              return u2 = null, d2 + "" || null;
          }
          function f2() {
            return wy().defined(i2).curve(a2).context(o2);
          }
          return c2.x = function(e3) {
            return arguments.length ? (t2 = "function" == typeof e3 ? e3 : Kg(+e3), n2 = null, c2) : t2;
          }, c2.x0 = function(n3) {
            return arguments.length ? (t2 = "function" == typeof n3 ? n3 : Kg(+n3), c2) : t2;
          }, c2.x1 = function(t3) {
            return arguments.length ? (n2 = null == t3 ? null : "function" == typeof t3 ? t3 : Kg(+t3), c2) : n2;
          }, c2.y = function(t3) {
            return arguments.length ? (e2 = "function" == typeof t3 ? t3 : Kg(+t3), r2 = null, c2) : e2;
          }, c2.y0 = function(t3) {
            return arguments.length ? (e2 = "function" == typeof t3 ? t3 : Kg(+t3), c2) : e2;
          }, c2.y1 = function(t3) {
            return arguments.length ? (r2 = null == t3 ? null : "function" == typeof t3 ? t3 : Kg(+t3), c2) : r2;
          }, c2.lineX0 = c2.lineY0 = function() {
            return f2().x(t2).y(e2);
          }, c2.lineY1 = function() {
            return f2().x(t2).y(r2);
          }, c2.lineX1 = function() {
            return f2().x(n2).y(e2);
          }, c2.defined = function(t3) {
            return arguments.length ? (i2 = "function" == typeof t3 ? t3 : Kg(!!t3), c2) : i2;
          }, c2.curve = function(t3) {
            return arguments.length ? (a2 = t3, null != o2 && (u2 = a2(o2)), c2) : a2;
          }, c2.context = function(t3) {
            return arguments.length ? (null == t3 ? o2 = u2 = null : u2 = a2(o2 = t3), c2) : o2;
          }, c2;
        }
        function Ny(t2, n2) {
          return n2 < t2 ? -1 : n2 > t2 ? 1 : n2 >= t2 ? 0 : NaN;
        }
        function Ay(t2) {
          return t2;
        }
        _y.prototype = { areaStart: function() {
          this._line = 0;
        }, areaEnd: function() {
          this._line = NaN;
        }, lineStart: function() {
          this._point = 0;
        }, lineEnd: function() {
          (this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line;
        }, point: function(t2, n2) {
          switch (t2 = +t2, n2 = +n2, this._point) {
            case 0:
              this._point = 1, this._line ? this._context.lineTo(t2, n2) : this._context.moveTo(t2, n2);
              break;
            case 1:
              this._point = 2;
            default:
              this._context.lineTo(t2, n2);
          }
        } };
        var Ty = ky(by);
        function Sy(t2) {
          this._curve = t2;
        }
        function ky(t2) {
          function n2(n3) {
            return new Sy(t2(n3));
          }
          return n2._curve = t2, n2;
        }
        function Ey(t2) {
          var n2 = t2.curve;
          return t2.angle = t2.x, delete t2.x, t2.radius = t2.y, delete t2.y, t2.curve = function(t3) {
            return arguments.length ? n2(ky(t3)) : n2()._curve;
          }, t2;
        }
        function Cy() {
          return Ey(wy().curve(Ty));
        }
        function Py() {
          var t2 = My().curve(Ty), n2 = t2.curve, e2 = t2.lineX0, r2 = t2.lineX1, i2 = t2.lineY0, o2 = t2.lineY1;
          return t2.angle = t2.x, delete t2.x, t2.startAngle = t2.x0, delete t2.x0, t2.endAngle = t2.x1, delete t2.x1, t2.radius = t2.y, delete t2.y, t2.innerRadius = t2.y0, delete t2.y0, t2.outerRadius = t2.y1, delete t2.y1, t2.lineStartAngle = function() {
            return Ey(e2());
          }, delete t2.lineX0, t2.lineEndAngle = function() {
            return Ey(r2());
          }, delete t2.lineX1, t2.lineInnerRadius = function() {
            return Ey(i2());
          }, delete t2.lineY0, t2.lineOuterRadius = function() {
            return Ey(o2());
          }, delete t2.lineY1, t2.curve = function(t3) {
            return arguments.length ? n2(ky(t3)) : n2()._curve;
          }, t2;
        }
        function zy(t2, n2) {
          return [(n2 = +n2) * Math.cos(t2 -= Math.PI / 2), n2 * Math.sin(t2)];
        }
        Sy.prototype = { areaStart: function() {
          this._curve.areaStart();
        }, areaEnd: function() {
          this._curve.areaEnd();
        }, lineStart: function() {
          this._curve.lineStart();
        }, lineEnd: function() {
          this._curve.lineEnd();
        }, point: function(t2, n2) {
          this._curve.point(n2 * Math.sin(t2), n2 * -Math.cos(t2));
        } };
        var Ry = Array.prototype.slice;
        function Dy(t2) {
          return t2.source;
        }
        function qy(t2) {
          return t2.target;
        }
        function Ly(t2) {
          var n2 = Dy, e2 = qy, r2 = my, i2 = xy, o2 = null;
          function a2() {
            var a3, u2 = Ry.call(arguments), c2 = n2.apply(this, u2), f2 = e2.apply(this, u2);
            if (o2 || (o2 = a3 = Hi()), t2(o2, +r2.apply(this, (u2[0] = c2, u2)), +i2.apply(this, u2), +r2.apply(this, (u2[0] = f2, u2)), +i2.apply(this, u2)), a3)
              return o2 = null, a3 + "" || null;
          }
          return a2.source = function(t3) {
            return arguments.length ? (n2 = t3, a2) : n2;
          }, a2.target = function(t3) {
            return arguments.length ? (e2 = t3, a2) : e2;
          }, a2.x = function(t3) {
            return arguments.length ? (r2 = "function" == typeof t3 ? t3 : Kg(+t3), a2) : r2;
          }, a2.y = function(t3) {
            return arguments.length ? (i2 = "function" == typeof t3 ? t3 : Kg(+t3), a2) : i2;
          }, a2.context = function(t3) {
            return arguments.length ? (o2 = null == t3 ? null : t3, a2) : o2;
          }, a2;
        }
        function Uy(t2, n2, e2, r2, i2) {
          t2.moveTo(n2, e2), t2.bezierCurveTo(n2 = (n2 + r2) / 2, e2, n2, i2, r2, i2);
        }
        function Oy(t2, n2, e2, r2, i2) {
          t2.moveTo(n2, e2), t2.bezierCurveTo(n2, e2 = (e2 + i2) / 2, r2, e2, r2, i2);
        }
        function By(t2, n2, e2, r2, i2) {
          var o2 = zy(n2, e2), a2 = zy(n2, e2 = (e2 + i2) / 2), u2 = zy(r2, e2), c2 = zy(r2, i2);
          t2.moveTo(o2[0], o2[1]), t2.bezierCurveTo(a2[0], a2[1], u2[0], u2[1], c2[0], c2[1]);
        }
        var Yy = { draw: function(t2, n2) {
          var e2 = Math.sqrt(n2 / cy);
          t2.moveTo(e2, 0), t2.arc(0, 0, e2, 0, sy);
        } }, Fy = { draw: function(t2, n2) {
          var e2 = Math.sqrt(n2 / 5) / 2;
          t2.moveTo(-3 * e2, -e2), t2.lineTo(-e2, -e2), t2.lineTo(-e2, -3 * e2), t2.lineTo(e2, -3 * e2), t2.lineTo(e2, -e2), t2.lineTo(3 * e2, -e2), t2.lineTo(3 * e2, e2), t2.lineTo(e2, e2), t2.lineTo(e2, 3 * e2), t2.lineTo(-e2, 3 * e2), t2.lineTo(-e2, e2), t2.lineTo(-3 * e2, e2), t2.closePath();
        } }, Iy = Math.sqrt(1 / 3), jy = 2 * Iy, Hy = { draw: function(t2, n2) {
          var e2 = Math.sqrt(n2 / jy), r2 = e2 * Iy;
          t2.moveTo(0, -e2), t2.lineTo(r2, 0), t2.lineTo(0, e2), t2.lineTo(-r2, 0), t2.closePath();
        } }, Xy = Math.sin(cy / 10) / Math.sin(7 * cy / 10), Gy = Math.sin(sy / 10) * Xy, Vy = -Math.cos(sy / 10) * Xy, $y = { draw: function(t2, n2) {
          var e2 = Math.sqrt(0.8908130915292852 * n2), r2 = Gy * e2, i2 = Vy * e2;
          t2.moveTo(0, -e2), t2.lineTo(r2, i2);
          for (var o2 = 1; o2 < 5; ++o2) {
            var a2 = sy * o2 / 5, u2 = Math.cos(a2), c2 = Math.sin(a2);
            t2.lineTo(c2 * e2, -u2 * e2), t2.lineTo(u2 * r2 - c2 * i2, c2 * r2 + u2 * i2);
          }
          t2.closePath();
        } }, Wy = { draw: function(t2, n2) {
          var e2 = Math.sqrt(n2), r2 = -e2 / 2;
          t2.rect(r2, r2, e2, e2);
        } }, Zy = Math.sqrt(3), Qy = { draw: function(t2, n2) {
          var e2 = -Math.sqrt(n2 / (3 * Zy));
          t2.moveTo(0, 2 * e2), t2.lineTo(-Zy * e2, -e2), t2.lineTo(Zy * e2, -e2), t2.closePath();
        } }, Jy = Math.sqrt(3) / 2, Ky = 1 / Math.sqrt(12), t_ = 3 * (Ky / 2 + 1), n_ = { draw: function(t2, n2) {
          var e2 = Math.sqrt(n2 / t_), r2 = e2 / 2, i2 = e2 * Ky, o2 = r2, a2 = e2 * Ky + e2, u2 = -o2, c2 = a2;
          t2.moveTo(r2, i2), t2.lineTo(o2, a2), t2.lineTo(u2, c2), t2.lineTo(-0.5 * r2 - Jy * i2, Jy * r2 + -0.5 * i2), t2.lineTo(-0.5 * o2 - Jy * a2, Jy * o2 + -0.5 * a2), t2.lineTo(-0.5 * u2 - Jy * c2, Jy * u2 + -0.5 * c2), t2.lineTo(-0.5 * r2 + Jy * i2, -0.5 * i2 - Jy * r2), t2.lineTo(-0.5 * o2 + Jy * a2, -0.5 * a2 - Jy * o2), t2.lineTo(-0.5 * u2 + Jy * c2, -0.5 * c2 - Jy * u2), t2.closePath();
        } }, e_ = [Yy, Fy, Hy, Wy, $y, Qy, n_];
        function r_() {
        }
        function i_(t2, n2, e2) {
          t2._context.bezierCurveTo((2 * t2._x0 + t2._x1) / 3, (2 * t2._y0 + t2._y1) / 3, (t2._x0 + 2 * t2._x1) / 3, (t2._y0 + 2 * t2._y1) / 3, (t2._x0 + 4 * t2._x1 + n2) / 6, (t2._y0 + 4 * t2._y1 + e2) / 6);
        }
        function o_(t2) {
          this._context = t2;
        }
        function a_(t2) {
          this._context = t2;
        }
        function u_(t2) {
          this._context = t2;
        }
        function c_(t2, n2) {
          this._basis = new o_(t2), this._beta = n2;
        }
        o_.prototype = { areaStart: function() {
          this._line = 0;
        }, areaEnd: function() {
          this._line = NaN;
        }, lineStart: function() {
          this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
        }, lineEnd: function() {
          switch (this._point) {
            case 3:
              i_(this, this._x1, this._y1);
            case 2:
              this._context.lineTo(this._x1, this._y1);
          }
          (this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line;
        }, point: function(t2, n2) {
          switch (t2 = +t2, n2 = +n2, this._point) {
            case 0:
              this._point = 1, this._line ? this._context.lineTo(t2, n2) : this._context.moveTo(t2, n2);
              break;
            case 1:
              this._point = 2;
              break;
            case 2:
              this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
            default:
              i_(this, t2, n2);
          }
          this._x0 = this._x1, this._x1 = t2, this._y0 = this._y1, this._y1 = n2;
        } }, a_.prototype = { areaStart: r_, areaEnd: r_, lineStart: function() {
          this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
        }, lineEnd: function() {
          switch (this._point) {
            case 1:
              this._context.moveTo(this._x2, this._y2), this._context.closePath();
              break;
            case 2:
              this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
              break;
            case 3:
              this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
          }
        }, point: function(t2, n2) {
          switch (t2 = +t2, n2 = +n2, this._point) {
            case 0:
              this._point = 1, this._x2 = t2, this._y2 = n2;
              break;
            case 1:
              this._point = 2, this._x3 = t2, this._y3 = n2;
              break;
            case 2:
              this._point = 3, this._x4 = t2, this._y4 = n2, this._context.moveTo((this._x0 + 4 * this._x1 + t2) / 6, (this._y0 + 4 * this._y1 + n2) / 6);
              break;
            default:
              i_(this, t2, n2);
          }
          this._x0 = this._x1, this._x1 = t2, this._y0 = this._y1, this._y1 = n2;
        } }, u_.prototype = { areaStart: function() {
          this._line = 0;
        }, areaEnd: function() {
          this._line = NaN;
        }, lineStart: function() {
          this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
        }, lineEnd: function() {
          (this._line || 0 !== this._line && 3 === this._point) && this._context.closePath(), this._line = 1 - this._line;
        }, point: function(t2, n2) {
          switch (t2 = +t2, n2 = +n2, this._point) {
            case 0:
              this._point = 1;
              break;
            case 1:
              this._point = 2;
              break;
            case 2:
              this._point = 3;
              var e2 = (this._x0 + 4 * this._x1 + t2) / 6, r2 = (this._y0 + 4 * this._y1 + n2) / 6;
              this._line ? this._context.lineTo(e2, r2) : this._context.moveTo(e2, r2);
              break;
            case 3:
              this._point = 4;
            default:
              i_(this, t2, n2);
          }
          this._x0 = this._x1, this._x1 = t2, this._y0 = this._y1, this._y1 = n2;
        } }, c_.prototype = { lineStart: function() {
          this._x = [], this._y = [], this._basis.lineStart();
        }, lineEnd: function() {
          var t2 = this._x, n2 = this._y, e2 = t2.length - 1;
          if (e2 > 0)
            for (var r2, i2 = t2[0], o2 = n2[0], a2 = t2[e2] - i2, u2 = n2[e2] - o2, c2 = -1; ++c2 <= e2; )
              r2 = c2 / e2, this._basis.point(this._beta * t2[c2] + (1 - this._beta) * (i2 + r2 * a2), this._beta * n2[c2] + (1 - this._beta) * (o2 + r2 * u2));
          this._x = this._y = null, this._basis.lineEnd();
        }, point: function(t2, n2) {
          this._x.push(+t2), this._y.push(+n2);
        } };
        var f_ = function t2(n2) {
          function e2(t3) {
            return 1 === n2 ? new o_(t3) : new c_(t3, n2);
          }
          return e2.beta = function(n3) {
            return t2(+n3);
          }, e2;
        }(0.85);
        function s_(t2, n2, e2) {
          t2._context.bezierCurveTo(t2._x1 + t2._k * (t2._x2 - t2._x0), t2._y1 + t2._k * (t2._y2 - t2._y0), t2._x2 + t2._k * (t2._x1 - n2), t2._y2 + t2._k * (t2._y1 - e2), t2._x2, t2._y2);
        }
        function l_(t2, n2) {
          this._context = t2, this._k = (1 - n2) / 6;
        }
        l_.prototype = { areaStart: function() {
          this._line = 0;
        }, areaEnd: function() {
          this._line = NaN;
        }, lineStart: function() {
          this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
        }, lineEnd: function() {
          switch (this._point) {
            case 2:
              this._context.lineTo(this._x2, this._y2);
              break;
            case 3:
              s_(this, this._x1, this._y1);
          }
          (this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line;
        }, point: function(t2, n2) {
          switch (t2 = +t2, n2 = +n2, this._point) {
            case 0:
              this._point = 1, this._line ? this._context.lineTo(t2, n2) : this._context.moveTo(t2, n2);
              break;
            case 1:
              this._point = 2, this._x1 = t2, this._y1 = n2;
              break;
            case 2:
              this._point = 3;
            default:
              s_(this, t2, n2);
          }
          this._x0 = this._x1, this._x1 = this._x2, this._x2 = t2, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n2;
        } };
        var h_ = function t2(n2) {
          function e2(t3) {
            return new l_(t3, n2);
          }
          return e2.tension = function(n3) {
            return t2(+n3);
          }, e2;
        }(0);
        function d_(t2, n2) {
          this._context = t2, this._k = (1 - n2) / 6;
        }
        d_.prototype = { areaStart: r_, areaEnd: r_, lineStart: function() {
          this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;
        }, lineEnd: function() {
          switch (this._point) {
            case 1:
              this._context.moveTo(this._x3, this._y3), this._context.closePath();
              break;
            case 2:
              this._context.lineTo(this._x3, this._y3), this._context.closePath();
              break;
            case 3:
              this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
          }
        }, point: function(t2, n2) {
          switch (t2 = +t2, n2 = +n2, this._point) {
            case 0:
              this._point = 1, this._x3 = t2, this._y3 = n2;
              break;
            case 1:
              this._point = 2, this._context.moveTo(this._x4 = t2, this._y4 = n2);
              break;
            case 2:
              this._point = 3, this._x5 = t2, this._y5 = n2;
              break;
            default:
              s_(this, t2, n2);
          }
          this._x0 = this._x1, this._x1 = this._x2, this._x2 = t2, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n2;
        } };
        var p_ = function t2(n2) {
          function e2(t3) {
            return new d_(t3, n2);
          }
          return e2.tension = function(n3) {
            return t2(+n3);
          }, e2;
        }(0);
        function v_(t2, n2) {
          this._context = t2, this._k = (1 - n2) / 6;
        }
        v_.prototype = { areaStart: function() {
          this._line = 0;
        }, areaEnd: function() {
          this._line = NaN;
        }, lineStart: function() {
          this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
        }, lineEnd: function() {
          (this._line || 0 !== this._line && 3 === this._point) && this._context.closePath(), this._line = 1 - this._line;
        }, point: function(t2, n2) {
          switch (t2 = +t2, n2 = +n2, this._point) {
            case 0:
              this._point = 1;
              break;
            case 1:
              this._point = 2;
              break;
            case 2:
              this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
              break;
            case 3:
              this._point = 4;
            default:
              s_(this, t2, n2);
          }
          this._x0 = this._x1, this._x1 = this._x2, this._x2 = t2, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n2;
        } };
        var g_ = function t2(n2) {
          function e2(t3) {
            return new v_(t3, n2);
          }
          return e2.tension = function(n3) {
            return t2(+n3);
          }, e2;
        }(0);
        function y_(t2, n2, e2) {
          var r2 = t2._x1, i2 = t2._y1, o2 = t2._x2, a2 = t2._y2;
          if (t2._l01_a > uy) {
            var u2 = 2 * t2._l01_2a + 3 * t2._l01_a * t2._l12_a + t2._l12_2a, c2 = 3 * t2._l01_a * (t2._l01_a + t2._l12_a);
            r2 = (r2 * u2 - t2._x0 * t2._l12_2a + t2._x2 * t2._l01_2a) / c2, i2 = (i2 * u2 - t2._y0 * t2._l12_2a + t2._y2 * t2._l01_2a) / c2;
          }
          if (t2._l23_a > uy) {
            var f2 = 2 * t2._l23_2a + 3 * t2._l23_a * t2._l12_a + t2._l12_2a, s2 = 3 * t2._l23_a * (t2._l23_a + t2._l12_a);
            o2 = (o2 * f2 + t2._x1 * t2._l23_2a - n2 * t2._l12_2a) / s2, a2 = (a2 * f2 + t2._y1 * t2._l23_2a - e2 * t2._l12_2a) / s2;
          }
          t2._context.bezierCurveTo(r2, i2, o2, a2, t2._x2, t2._y2);
        }
        function __(t2, n2) {
          this._context = t2, this._alpha = n2;
        }
        __.prototype = { areaStart: function() {
          this._line = 0;
        }, areaEnd: function() {
          this._line = NaN;
        }, lineStart: function() {
          this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
        }, lineEnd: function() {
          switch (this._point) {
            case 2:
              this._context.lineTo(this._x2, this._y2);
              break;
            case 3:
              this.point(this._x2, this._y2);
          }
          (this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line;
        }, point: function(t2, n2) {
          if (t2 = +t2, n2 = +n2, this._point) {
            var e2 = this._x2 - t2, r2 = this._y2 - n2;
            this._l23_a = Math.sqrt(this._l23_2a = Math.pow(e2 * e2 + r2 * r2, this._alpha));
          }
          switch (this._point) {
            case 0:
              this._point = 1, this._line ? this._context.lineTo(t2, n2) : this._context.moveTo(t2, n2);
              break;
            case 1:
              this._point = 2;
              break;
            case 2:
              this._point = 3;
            default:
              y_(this, t2, n2);
          }
          this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t2, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n2;
        } };
        var b_ = function t2(n2) {
          function e2(t3) {
            return n2 ? new __(t3, n2) : new l_(t3, 0);
          }
          return e2.alpha = function(n3) {
            return t2(+n3);
          }, e2;
        }(0.5);
        function m_(t2, n2) {
          this._context = t2, this._alpha = n2;
        }
        m_.prototype = { areaStart: r_, areaEnd: r_, lineStart: function() {
          this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
        }, lineEnd: function() {
          switch (this._point) {
            case 1:
              this._context.moveTo(this._x3, this._y3), this._context.closePath();
              break;
            case 2:
              this._context.lineTo(this._x3, this._y3), this._context.closePath();
              break;
            case 3:
              this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
          }
        }, point: function(t2, n2) {
          if (t2 = +t2, n2 = +n2, this._point) {
            var e2 = this._x2 - t2, r2 = this._y2 - n2;
            this._l23_a = Math.sqrt(this._l23_2a = Math.pow(e2 * e2 + r2 * r2, this._alpha));
          }
          switch (this._point) {
            case 0:
              this._point = 1, this._x3 = t2, this._y3 = n2;
              break;
            case 1:
              this._point = 2, this._context.moveTo(this._x4 = t2, this._y4 = n2);
              break;
            case 2:
              this._point = 3, this._x5 = t2, this._y5 = n2;
              break;
            default:
              y_(this, t2, n2);
          }
          this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t2, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n2;
        } };
        var x_ = function t2(n2) {
          function e2(t3) {
            return n2 ? new m_(t3, n2) : new d_(t3, 0);
          }
          return e2.alpha = function(n3) {
            return t2(+n3);
          }, e2;
        }(0.5);
        function w_(t2, n2) {
          this._context = t2, this._alpha = n2;
        }
        w_.prototype = { areaStart: function() {
          this._line = 0;
        }, areaEnd: function() {
          this._line = NaN;
        }, lineStart: function() {
          this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
        }, lineEnd: function() {
          (this._line || 0 !== this._line && 3 === this._point) && this._context.closePath(), this._line = 1 - this._line;
        }, point: function(t2, n2) {
          if (t2 = +t2, n2 = +n2, this._point) {
            var e2 = this._x2 - t2, r2 = this._y2 - n2;
            this._l23_a = Math.sqrt(this._l23_2a = Math.pow(e2 * e2 + r2 * r2, this._alpha));
          }
          switch (this._point) {
            case 0:
              this._point = 1;
              break;
            case 1:
              this._point = 2;
              break;
            case 2:
              this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
              break;
            case 3:
              this._point = 4;
            default:
              y_(this, t2, n2);
          }
          this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t2, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n2;
        } };
        var M_ = function t2(n2) {
          function e2(t3) {
            return n2 ? new w_(t3, n2) : new v_(t3, 0);
          }
          return e2.alpha = function(n3) {
            return t2(+n3);
          }, e2;
        }(0.5);
        function N_(t2) {
          this._context = t2;
        }
        function A_(t2) {
          return t2 < 0 ? -1 : 1;
        }
        function T_(t2, n2, e2) {
          var r2 = t2._x1 - t2._x0, i2 = n2 - t2._x1, o2 = (t2._y1 - t2._y0) / (r2 || i2 < 0 && -0), a2 = (e2 - t2._y1) / (i2 || r2 < 0 && -0), u2 = (o2 * i2 + a2 * r2) / (r2 + i2);
          return (A_(o2) + A_(a2)) * Math.min(Math.abs(o2), Math.abs(a2), 0.5 * Math.abs(u2)) || 0;
        }
        function S_(t2, n2) {
          var e2 = t2._x1 - t2._x0;
          return e2 ? (3 * (t2._y1 - t2._y0) / e2 - n2) / 2 : n2;
        }
        function k_(t2, n2, e2) {
          var r2 = t2._x0, i2 = t2._y0, o2 = t2._x1, a2 = t2._y1, u2 = (o2 - r2) / 3;
          t2._context.bezierCurveTo(r2 + u2, i2 + u2 * n2, o2 - u2, a2 - u2 * e2, o2, a2);
        }
        function E_(t2) {
          this._context = t2;
        }
        function C_(t2) {
          this._context = new P_(t2);
        }
        function P_(t2) {
          this._context = t2;
        }
        function z_(t2) {
          this._context = t2;
        }
        function R_(t2) {
          var n2, e2, r2 = t2.length - 1, i2 = new Array(r2), o2 = new Array(r2), a2 = new Array(r2);
          for (i2[0] = 0, o2[0] = 2, a2[0] = t2[0] + 2 * t2[1], n2 = 1; n2 < r2 - 1; ++n2)
            i2[n2] = 1, o2[n2] = 4, a2[n2] = 4 * t2[n2] + 2 * t2[n2 + 1];
          for (i2[r2 - 1] = 2, o2[r2 - 1] = 7, a2[r2 - 1] = 8 * t2[r2 - 1] + t2[r2], n2 = 1; n2 < r2; ++n2)
            e2 = i2[n2] / o2[n2 - 1], o2[n2] -= e2, a2[n2] -= e2 * a2[n2 - 1];
          for (i2[r2 - 1] = a2[r2 - 1] / o2[r2 - 1], n2 = r2 - 2; n2 >= 0; --n2)
            i2[n2] = (a2[n2] - i2[n2 + 1]) / o2[n2];
          for (o2[r2 - 1] = (t2[r2] + i2[r2 - 1]) / 2, n2 = 0; n2 < r2 - 1; ++n2)
            o2[n2] = 2 * t2[n2 + 1] - i2[n2 + 1];
          return [i2, o2];
        }
        function D_(t2, n2) {
          this._context = t2, this._t = n2;
        }
        function q_(t2, n2) {
          if ((i2 = t2.length) > 1)
            for (var e2, r2, i2, o2 = 1, a2 = t2[n2[0]], u2 = a2.length; o2 < i2; ++o2)
              for (r2 = a2, a2 = t2[n2[o2]], e2 = 0; e2 < u2; ++e2)
                a2[e2][1] += a2[e2][0] = isNaN(r2[e2][1]) ? r2[e2][0] : r2[e2][1];
        }
        function L_(t2) {
          for (var n2 = t2.length, e2 = new Array(n2); --n2 >= 0; )
            e2[n2] = n2;
          return e2;
        }
        function U_(t2, n2) {
          return t2[n2];
        }
        function O_(t2) {
          var n2 = t2.map(B_);
          return L_(t2).sort(function(t3, e2) {
            return n2[t3] - n2[e2];
          });
        }
        function B_(t2) {
          for (var n2, e2 = -1, r2 = 0, i2 = t2.length, o2 = -1 / 0; ++e2 < i2; )
            (n2 = +t2[e2][1]) > o2 && (o2 = n2, r2 = e2);
          return r2;
        }
        function Y_(t2) {
          var n2 = t2.map(F_);
          return L_(t2).sort(function(t3, e2) {
            return n2[t3] - n2[e2];
          });
        }
        function F_(t2) {
          for (var n2, e2 = 0, r2 = -1, i2 = t2.length; ++r2 < i2; )
            (n2 = +t2[r2][1]) && (e2 += n2);
          return e2;
        }
        function I_(t2) {
          return function() {
            return t2;
          };
        }
        function j_(t2) {
          return t2[0];
        }
        function H_(t2) {
          return t2[1];
        }
        function X_() {
          this._ = null;
        }
        function G_(t2) {
          t2.U = t2.C = t2.L = t2.R = t2.P = t2.N = null;
        }
        function V_(t2, n2) {
          var e2 = n2, r2 = n2.R, i2 = e2.U;
          i2 ? i2.L === e2 ? i2.L = r2 : i2.R = r2 : t2._ = r2, r2.U = i2, e2.U = r2, e2.R = r2.L, e2.R && (e2.R.U = e2), r2.L = e2;
        }
        function $_(t2, n2) {
          var e2 = n2, r2 = n2.L, i2 = e2.U;
          i2 ? i2.L === e2 ? i2.L = r2 : i2.R = r2 : t2._ = r2, r2.U = i2, e2.U = r2, e2.L = r2.R, e2.L && (e2.L.U = e2), r2.R = e2;
        }
        function W_(t2) {
          for (; t2.L; )
            t2 = t2.L;
          return t2;
        }
        function Z_(t2, n2, e2, r2) {
          var i2 = [null, null], o2 = mb.push(i2) - 1;
          return i2.left = t2, i2.right = n2, e2 && J_(i2, t2, n2, e2), r2 && J_(i2, n2, t2, r2), _b[t2.index].halfedges.push(o2), _b[n2.index].halfedges.push(o2), i2;
        }
        function Q_(t2, n2, e2) {
          var r2 = [n2, e2];
          return r2.left = t2, r2;
        }
        function J_(t2, n2, e2, r2) {
          t2[0] || t2[1] ? t2.left === e2 ? t2[1] = r2 : t2[0] = r2 : (t2[0] = r2, t2.left = n2, t2.right = e2);
        }
        function K_(t2, n2, e2, r2, i2) {
          var o2, a2 = t2[0], u2 = t2[1], c2 = a2[0], f2 = a2[1], s2 = 0, l2 = 1, h2 = u2[0] - c2, d2 = u2[1] - f2;
          if (o2 = n2 - c2, h2 || !(o2 > 0)) {
            if (o2 /= h2, h2 < 0) {
              if (o2 < s2)
                return;
              o2 < l2 && (l2 = o2);
            } else if (h2 > 0) {
              if (o2 > l2)
                return;
              o2 > s2 && (s2 = o2);
            }
            if (o2 = r2 - c2, h2 || !(o2 < 0)) {
              if (o2 /= h2, h2 < 0) {
                if (o2 > l2)
                  return;
                o2 > s2 && (s2 = o2);
              } else if (h2 > 0) {
                if (o2 < s2)
                  return;
                o2 < l2 && (l2 = o2);
              }
              if (o2 = e2 - f2, d2 || !(o2 > 0)) {
                if (o2 /= d2, d2 < 0) {
                  if (o2 < s2)
                    return;
                  o2 < l2 && (l2 = o2);
                } else if (d2 > 0) {
                  if (o2 > l2)
                    return;
                  o2 > s2 && (s2 = o2);
                }
                if (o2 = i2 - f2, d2 || !(o2 < 0)) {
                  if (o2 /= d2, d2 < 0) {
                    if (o2 > l2)
                      return;
                    o2 > s2 && (s2 = o2);
                  } else if (d2 > 0) {
                    if (o2 < s2)
                      return;
                    o2 < l2 && (l2 = o2);
                  }
                  return !(s2 > 0 || l2 < 1) || (s2 > 0 && (t2[0] = [c2 + s2 * h2, f2 + s2 * d2]), l2 < 1 && (t2[1] = [c2 + l2 * h2, f2 + l2 * d2]), true);
                }
              }
            }
          }
        }
        function tb(t2, n2, e2, r2, i2) {
          var o2 = t2[1];
          if (o2)
            return true;
          var a2, u2, c2 = t2[0], f2 = t2.left, s2 = t2.right, l2 = f2[0], h2 = f2[1], d2 = s2[0], p2 = s2[1], v2 = (l2 + d2) / 2, g2 = (h2 + p2) / 2;
          if (p2 === h2) {
            if (v2 < n2 || v2 >= r2)
              return;
            if (l2 > d2) {
              if (c2) {
                if (c2[1] >= i2)
                  return;
              } else
                c2 = [v2, e2];
              o2 = [v2, i2];
            } else {
              if (c2) {
                if (c2[1] < e2)
                  return;
              } else
                c2 = [v2, i2];
              o2 = [v2, e2];
            }
          } else if (u2 = g2 - (a2 = (l2 - d2) / (p2 - h2)) * v2, a2 < -1 || a2 > 1)
            if (l2 > d2) {
              if (c2) {
                if (c2[1] >= i2)
                  return;
              } else
                c2 = [(e2 - u2) / a2, e2];
              o2 = [(i2 - u2) / a2, i2];
            } else {
              if (c2) {
                if (c2[1] < e2)
                  return;
              } else
                c2 = [(i2 - u2) / a2, i2];
              o2 = [(e2 - u2) / a2, e2];
            }
          else if (h2 < p2) {
            if (c2) {
              if (c2[0] >= r2)
                return;
            } else
              c2 = [n2, a2 * n2 + u2];
            o2 = [r2, a2 * r2 + u2];
          } else {
            if (c2) {
              if (c2[0] < n2)
                return;
            } else
              c2 = [r2, a2 * r2 + u2];
            o2 = [n2, a2 * n2 + u2];
          }
          return t2[0] = c2, t2[1] = o2, true;
        }
        function nb(t2, n2) {
          var e2 = t2.site, r2 = n2.left, i2 = n2.right;
          return e2 === i2 && (i2 = r2, r2 = e2), i2 ? Math.atan2(i2[1] - r2[1], i2[0] - r2[0]) : (e2 === r2 ? (r2 = n2[1], i2 = n2[0]) : (r2 = n2[0], i2 = n2[1]), Math.atan2(r2[0] - i2[0], i2[1] - r2[1]));
        }
        function eb(t2, n2) {
          return n2[+(n2.left !== t2.site)];
        }
        function rb(t2, n2) {
          return n2[+(n2.left === t2.site)];
        }
        N_.prototype = { areaStart: r_, areaEnd: r_, lineStart: function() {
          this._point = 0;
        }, lineEnd: function() {
          this._point && this._context.closePath();
        }, point: function(t2, n2) {
          t2 = +t2, n2 = +n2, this._point ? this._context.lineTo(t2, n2) : (this._point = 1, this._context.moveTo(t2, n2));
        } }, E_.prototype = { areaStart: function() {
          this._line = 0;
        }, areaEnd: function() {
          this._line = NaN;
        }, lineStart: function() {
          this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
        }, lineEnd: function() {
          switch (this._point) {
            case 2:
              this._context.lineTo(this._x1, this._y1);
              break;
            case 3:
              k_(this, this._t0, S_(this, this._t0));
          }
          (this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line;
        }, point: function(t2, n2) {
          var e2 = NaN;
          if (n2 = +n2, (t2 = +t2) !== this._x1 || n2 !== this._y1) {
            switch (this._point) {
              case 0:
                this._point = 1, this._line ? this._context.lineTo(t2, n2) : this._context.moveTo(t2, n2);
                break;
              case 1:
                this._point = 2;
                break;
              case 2:
                this._point = 3, k_(this, S_(this, e2 = T_(this, t2, n2)), e2);
                break;
              default:
                k_(this, this._t0, e2 = T_(this, t2, n2));
            }
            this._x0 = this._x1, this._x1 = t2, this._y0 = this._y1, this._y1 = n2, this._t0 = e2;
          }
        } }, (C_.prototype = Object.create(E_.prototype)).point = function(t2, n2) {
          E_.prototype.point.call(this, n2, t2);
        }, P_.prototype = { moveTo: function(t2, n2) {
          this._context.moveTo(n2, t2);
        }, closePath: function() {
          this._context.closePath();
        }, lineTo: function(t2, n2) {
          this._context.lineTo(n2, t2);
        }, bezierCurveTo: function(t2, n2, e2, r2, i2, o2) {
          this._context.bezierCurveTo(n2, t2, r2, e2, o2, i2);
        } }, z_.prototype = { areaStart: function() {
          this._line = 0;
        }, areaEnd: function() {
          this._line = NaN;
        }, lineStart: function() {
          this._x = [], this._y = [];
        }, lineEnd: function() {
          var t2 = this._x, n2 = this._y, e2 = t2.length;
          if (e2)
            if (this._line ? this._context.lineTo(t2[0], n2[0]) : this._context.moveTo(t2[0], n2[0]), 2 === e2)
              this._context.lineTo(t2[1], n2[1]);
            else
              for (var r2 = R_(t2), i2 = R_(n2), o2 = 0, a2 = 1; a2 < e2; ++o2, ++a2)
                this._context.bezierCurveTo(r2[0][o2], i2[0][o2], r2[1][o2], i2[1][o2], t2[a2], n2[a2]);
          (this._line || 0 !== this._line && 1 === e2) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
        }, point: function(t2, n2) {
          this._x.push(+t2), this._y.push(+n2);
        } }, D_.prototype = { areaStart: function() {
          this._line = 0;
        }, areaEnd: function() {
          this._line = NaN;
        }, lineStart: function() {
          this._x = this._y = NaN, this._point = 0;
        }, lineEnd: function() {
          0 < this._t && this._t < 1 && 2 === this._point && this._context.lineTo(this._x, this._y), (this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
        }, point: function(t2, n2) {
          switch (t2 = +t2, n2 = +n2, this._point) {
            case 0:
              this._point = 1, this._line ? this._context.lineTo(t2, n2) : this._context.moveTo(t2, n2);
              break;
            case 1:
              this._point = 2;
            default:
              if (this._t <= 0)
                this._context.lineTo(this._x, n2), this._context.lineTo(t2, n2);
              else {
                var e2 = this._x * (1 - this._t) + t2 * this._t;
                this._context.lineTo(e2, this._y), this._context.lineTo(e2, n2);
              }
          }
          this._x = t2, this._y = n2;
        } }, X_.prototype = { constructor: X_, insert: function(t2, n2) {
          var e2, r2, i2;
          if (t2) {
            if (n2.P = t2, n2.N = t2.N, t2.N && (t2.N.P = n2), t2.N = n2, t2.R) {
              for (t2 = t2.R; t2.L; )
                t2 = t2.L;
              t2.L = n2;
            } else
              t2.R = n2;
            e2 = t2;
          } else
            this._ ? (t2 = W_(this._), n2.P = null, n2.N = t2, t2.P = t2.L = n2, e2 = t2) : (n2.P = n2.N = null, this._ = n2, e2 = null);
          for (n2.L = n2.R = null, n2.U = e2, n2.C = true, t2 = n2; e2 && e2.C; )
            e2 === (r2 = e2.U).L ? (i2 = r2.R) && i2.C ? (e2.C = i2.C = false, r2.C = true, t2 = r2) : (t2 === e2.R && (V_(this, e2), e2 = (t2 = e2).U), e2.C = false, r2.C = true, $_(this, r2)) : (i2 = r2.L) && i2.C ? (e2.C = i2.C = false, r2.C = true, t2 = r2) : (t2 === e2.L && ($_(this, e2), e2 = (t2 = e2).U), e2.C = false, r2.C = true, V_(this, r2)), e2 = t2.U;
          this._.C = false;
        }, remove: function(t2) {
          t2.N && (t2.N.P = t2.P), t2.P && (t2.P.N = t2.N), t2.N = t2.P = null;
          var n2, e2, r2, i2 = t2.U, o2 = t2.L, a2 = t2.R;
          if (e2 = o2 ? a2 ? W_(a2) : o2 : a2, i2 ? i2.L === t2 ? i2.L = e2 : i2.R = e2 : this._ = e2, o2 && a2 ? (r2 = e2.C, e2.C = t2.C, e2.L = o2, o2.U = e2, e2 !== a2 ? (i2 = e2.U, e2.U = t2.U, t2 = e2.R, i2.L = t2, e2.R = a2, a2.U = e2) : (e2.U = i2, i2 = e2, t2 = e2.R)) : (r2 = t2.C, t2 = e2), t2 && (t2.U = i2), !r2)
            if (t2 && t2.C)
              t2.C = false;
            else {
              do {
                if (t2 === this._)
                  break;
                if (t2 === i2.L) {
                  if ((n2 = i2.R).C && (n2.C = false, i2.C = true, V_(this, i2), n2 = i2.R), n2.L && n2.L.C || n2.R && n2.R.C) {
                    n2.R && n2.R.C || (n2.L.C = false, n2.C = true, $_(this, n2), n2 = i2.R), n2.C = i2.C, i2.C = n2.R.C = false, V_(this, i2), t2 = this._;
                    break;
                  }
                } else if ((n2 = i2.L).C && (n2.C = false, i2.C = true, $_(this, i2), n2 = i2.L), n2.L && n2.L.C || n2.R && n2.R.C) {
                  n2.L && n2.L.C || (n2.R.C = false, n2.C = true, V_(this, n2), n2 = i2.L), n2.C = i2.C, i2.C = n2.L.C = false, $_(this, i2), t2 = this._;
                  break;
                }
                n2.C = true, t2 = i2, i2 = i2.U;
              } while (!t2.C);
              t2 && (t2.C = false);
            }
        } };
        var ib, ob = [];
        function ab() {
          G_(this), this.x = this.y = this.arc = this.site = this.cy = null;
        }
        function ub(t2) {
          var n2 = t2.P, e2 = t2.N;
          if (n2 && e2) {
            var r2 = n2.site, i2 = t2.site, o2 = e2.site;
            if (r2 !== o2) {
              var a2 = i2[0], u2 = i2[1], c2 = r2[0] - a2, f2 = r2[1] - u2, s2 = o2[0] - a2, l2 = o2[1] - u2, h2 = 2 * (c2 * l2 - f2 * s2);
              if (!(h2 >= -wb)) {
                var d2 = c2 * c2 + f2 * f2, p2 = s2 * s2 + l2 * l2, v2 = (l2 * d2 - f2 * p2) / h2, g2 = (c2 * p2 - s2 * d2) / h2, y2 = ob.pop() || new ab();
                y2.arc = t2, y2.site = i2, y2.x = v2 + a2, y2.y = (y2.cy = g2 + u2) + Math.sqrt(v2 * v2 + g2 * g2), t2.circle = y2;
                for (var _2 = null, b2 = bb._; b2; )
                  if (y2.y < b2.y || y2.y === b2.y && y2.x <= b2.x) {
                    if (!b2.L) {
                      _2 = b2.P;
                      break;
                    }
                    b2 = b2.L;
                  } else {
                    if (!b2.R) {
                      _2 = b2;
                      break;
                    }
                    b2 = b2.R;
                  }
                bb.insert(_2, y2), _2 || (ib = y2);
              }
            }
          }
        }
        function cb(t2) {
          var n2 = t2.circle;
          n2 && (n2.P || (ib = n2.N), bb.remove(n2), ob.push(n2), G_(n2), t2.circle = null);
        }
        var fb = [];
        function sb() {
          G_(this), this.edge = this.site = this.circle = null;
        }
        function lb(t2) {
          var n2 = fb.pop() || new sb();
          return n2.site = t2, n2;
        }
        function hb(t2) {
          cb(t2), yb.remove(t2), fb.push(t2), G_(t2);
        }
        function db(t2) {
          var n2 = t2.circle, e2 = n2.x, r2 = n2.cy, i2 = [e2, r2], o2 = t2.P, a2 = t2.N, u2 = [t2];
          hb(t2);
          for (var c2 = o2; c2.circle && Math.abs(e2 - c2.circle.x) < xb && Math.abs(r2 - c2.circle.cy) < xb; )
            o2 = c2.P, u2.unshift(c2), hb(c2), c2 = o2;
          u2.unshift(c2), cb(c2);
          for (var f2 = a2; f2.circle && Math.abs(e2 - f2.circle.x) < xb && Math.abs(r2 - f2.circle.cy) < xb; )
            a2 = f2.N, u2.push(f2), hb(f2), f2 = a2;
          u2.push(f2), cb(f2);
          var s2, l2 = u2.length;
          for (s2 = 1; s2 < l2; ++s2)
            f2 = u2[s2], c2 = u2[s2 - 1], J_(f2.edge, c2.site, f2.site, i2);
          c2 = u2[0], (f2 = u2[l2 - 1]).edge = Z_(c2.site, f2.site, null, i2), ub(c2), ub(f2);
        }
        function pb(t2) {
          for (var n2, e2, r2, i2, o2 = t2[0], a2 = t2[1], u2 = yb._; u2; )
            if ((r2 = vb(u2, a2) - o2) > xb)
              u2 = u2.L;
            else {
              if (!((i2 = o2 - gb(u2, a2)) > xb)) {
                r2 > -xb ? (n2 = u2.P, e2 = u2) : i2 > -xb ? (n2 = u2, e2 = u2.N) : n2 = e2 = u2;
                break;
              }
              if (!u2.R) {
                n2 = u2;
                break;
              }
              u2 = u2.R;
            }
          !function(t3) {
            _b[t3.index] = { site: t3, halfedges: [] };
          }(t2);
          var c2 = lb(t2);
          if (yb.insert(n2, c2), n2 || e2) {
            if (n2 === e2)
              return cb(n2), e2 = lb(n2.site), yb.insert(c2, e2), c2.edge = e2.edge = Z_(n2.site, c2.site), ub(n2), void ub(e2);
            if (e2) {
              cb(n2), cb(e2);
              var f2 = n2.site, s2 = f2[0], l2 = f2[1], h2 = t2[0] - s2, d2 = t2[1] - l2, p2 = e2.site, v2 = p2[0] - s2, g2 = p2[1] - l2, y2 = 2 * (h2 * g2 - d2 * v2), _2 = h2 * h2 + d2 * d2, b2 = v2 * v2 + g2 * g2, m2 = [(g2 * _2 - d2 * b2) / y2 + s2, (h2 * b2 - v2 * _2) / y2 + l2];
              J_(e2.edge, f2, p2, m2), c2.edge = Z_(f2, t2, null, m2), e2.edge = Z_(t2, p2, null, m2), ub(n2), ub(e2);
            } else
              c2.edge = Z_(n2.site, c2.site);
          }
        }
        function vb(t2, n2) {
          var e2 = t2.site, r2 = e2[0], i2 = e2[1], o2 = i2 - n2;
          if (!o2)
            return r2;
          var a2 = t2.P;
          if (!a2)
            return -1 / 0;
          var u2 = (e2 = a2.site)[0], c2 = e2[1], f2 = c2 - n2;
          if (!f2)
            return u2;
          var s2 = u2 - r2, l2 = 1 / o2 - 1 / f2, h2 = s2 / f2;
          return l2 ? (-h2 + Math.sqrt(h2 * h2 - 2 * l2 * (s2 * s2 / (-2 * f2) - c2 + f2 / 2 + i2 - o2 / 2))) / l2 + r2 : (r2 + u2) / 2;
        }
        function gb(t2, n2) {
          var e2 = t2.N;
          if (e2)
            return vb(e2, n2);
          var r2 = t2.site;
          return r2[1] === n2 ? r2[0] : 1 / 0;
        }
        var yb, _b, bb, mb, xb = 1e-6, wb = 1e-12;
        function Mb(t2, n2) {
          return n2[1] - t2[1] || n2[0] - t2[0];
        }
        function Nb(t2, n2) {
          var e2, r2, i2, o2 = t2.sort(Mb).pop();
          for (mb = [], _b = new Array(t2.length), yb = new X_(), bb = new X_(); ; )
            if (i2 = ib, o2 && (!i2 || o2[1] < i2.y || o2[1] === i2.y && o2[0] < i2.x))
              o2[0] === e2 && o2[1] === r2 || (pb(o2), e2 = o2[0], r2 = o2[1]), o2 = t2.pop();
            else {
              if (!i2)
                break;
              db(i2.arc);
            }
          if (function() {
            for (var t3, n3, e3, r3, i3 = 0, o3 = _b.length; i3 < o3; ++i3)
              if ((t3 = _b[i3]) && (r3 = (n3 = t3.halfedges).length)) {
                var a3 = new Array(r3), u3 = new Array(r3);
                for (e3 = 0; e3 < r3; ++e3)
                  a3[e3] = e3, u3[e3] = nb(t3, mb[n3[e3]]);
                for (a3.sort(function(t4, n4) {
                  return u3[n4] - u3[t4];
                }), e3 = 0; e3 < r3; ++e3)
                  u3[e3] = n3[a3[e3]];
                for (e3 = 0; e3 < r3; ++e3)
                  n3[e3] = u3[e3];
              }
          }(), n2) {
            var a2 = +n2[0][0], u2 = +n2[0][1], c2 = +n2[1][0], f2 = +n2[1][1];
            !function(t3, n3, e3, r3) {
              for (var i3, o3 = mb.length; o3--; )
                tb(i3 = mb[o3], t3, n3, e3, r3) && K_(i3, t3, n3, e3, r3) && (Math.abs(i3[0][0] - i3[1][0]) > xb || Math.abs(i3[0][1] - i3[1][1]) > xb) || delete mb[o3];
            }(a2, u2, c2, f2), function(t3, n3, e3, r3) {
              var i3, o3, a3, u3, c3, f3, s2, l2, h2, d2, p2, v2, g2 = _b.length, y2 = true;
              for (i3 = 0; i3 < g2; ++i3)
                if (o3 = _b[i3]) {
                  for (a3 = o3.site, u3 = (c3 = o3.halfedges).length; u3--; )
                    mb[c3[u3]] || c3.splice(u3, 1);
                  for (u3 = 0, f3 = c3.length; u3 < f3; )
                    p2 = (d2 = rb(o3, mb[c3[u3]]))[0], v2 = d2[1], l2 = (s2 = eb(o3, mb[c3[++u3 % f3]]))[0], h2 = s2[1], (Math.abs(p2 - l2) > xb || Math.abs(v2 - h2) > xb) && (c3.splice(u3, 0, mb.push(Q_(a3, d2, Math.abs(p2 - t3) < xb && r3 - v2 > xb ? [t3, Math.abs(l2 - t3) < xb ? h2 : r3] : Math.abs(v2 - r3) < xb && e3 - p2 > xb ? [Math.abs(h2 - r3) < xb ? l2 : e3, r3] : Math.abs(p2 - e3) < xb && v2 - n3 > xb ? [e3, Math.abs(l2 - e3) < xb ? h2 : n3] : Math.abs(v2 - n3) < xb && p2 - t3 > xb ? [Math.abs(h2 - n3) < xb ? l2 : t3, n3] : null)) - 1), ++f3);
                  f3 && (y2 = false);
                }
              if (y2) {
                var _2, b2, m2, x2 = 1 / 0;
                for (i3 = 0, y2 = null; i3 < g2; ++i3)
                  (o3 = _b[i3]) && (m2 = (_2 = (a3 = o3.site)[0] - t3) * _2 + (b2 = a3[1] - n3) * b2) < x2 && (x2 = m2, y2 = o3);
                if (y2) {
                  var w2 = [t3, n3], M2 = [t3, r3], N2 = [e3, r3], A2 = [e3, n3];
                  y2.halfedges.push(mb.push(Q_(a3 = y2.site, w2, M2)) - 1, mb.push(Q_(a3, M2, N2)) - 1, mb.push(Q_(a3, N2, A2)) - 1, mb.push(Q_(a3, A2, w2)) - 1);
                }
              }
              for (i3 = 0; i3 < g2; ++i3)
                (o3 = _b[i3]) && (o3.halfedges.length || delete _b[i3]);
            }(a2, u2, c2, f2);
          }
          this.edges = mb, this.cells = _b, yb = bb = mb = _b = null;
        }
        function Ab(t2) {
          return function() {
            return t2;
          };
        }
        function Tb(t2, n2, e2) {
          this.target = t2, this.type = n2, this.transform = e2;
        }
        function Sb(t2, n2, e2) {
          this.k = t2, this.x = n2, this.y = e2;
        }
        Nb.prototype = { constructor: Nb, polygons: function() {
          var t2 = this.edges;
          return this.cells.map(function(n2) {
            var e2 = n2.halfedges.map(function(e3) {
              return eb(n2, t2[e3]);
            });
            return e2.data = n2.site.data, e2;
          });
        }, triangles: function() {
          var t2 = [], n2 = this.edges;
          return this.cells.forEach(function(e2, r2) {
            if (o2 = (i2 = e2.halfedges).length)
              for (var i2, o2, a2, u2, c2, f2, s2 = e2.site, l2 = -1, h2 = n2[i2[o2 - 1]], d2 = h2.left === s2 ? h2.right : h2.left; ++l2 < o2; )
                a2 = d2, d2 = (h2 = n2[i2[l2]]).left === s2 ? h2.right : h2.left, a2 && d2 && r2 < a2.index && r2 < d2.index && (c2 = a2, f2 = d2, ((u2 = s2)[0] - f2[0]) * (c2[1] - u2[1]) - (u2[0] - c2[0]) * (f2[1] - u2[1]) < 0) && t2.push([s2.data, a2.data, d2.data]);
          }), t2;
        }, links: function() {
          return this.edges.filter(function(t2) {
            return t2.right;
          }).map(function(t2) {
            return { source: t2.left.data, target: t2.right.data };
          });
        }, find: function(t2, n2, e2) {
          for (var r2, i2, o2 = this, a2 = o2._found || 0, u2 = o2.cells.length; !(i2 = o2.cells[a2]); )
            if (++a2 >= u2)
              return null;
          var c2 = t2 - i2.site[0], f2 = n2 - i2.site[1], s2 = c2 * c2 + f2 * f2;
          do {
            i2 = o2.cells[r2 = a2], a2 = null, i2.halfedges.forEach(function(e3) {
              var r3 = o2.edges[e3], u3 = r3.left;
              if (u3 !== i2.site && u3 || (u3 = r3.right)) {
                var c3 = t2 - u3[0], f3 = n2 - u3[1], l2 = c3 * c3 + f3 * f3;
                l2 < s2 && (s2 = l2, a2 = u3.index);
              }
            });
          } while (null !== a2);
          return o2._found = r2, null == e2 || s2 <= e2 * e2 ? i2.site : null;
        } }, Sb.prototype = { constructor: Sb, scale: function(t2) {
          return 1 === t2 ? this : new Sb(this.k * t2, this.x, this.y);
        }, translate: function(t2, n2) {
          return 0 === t2 & 0 === n2 ? this : new Sb(this.k, this.x + this.k * t2, this.y + this.k * n2);
        }, apply: function(t2) {
          return [t2[0] * this.k + this.x, t2[1] * this.k + this.y];
        }, applyX: function(t2) {
          return t2 * this.k + this.x;
        }, applyY: function(t2) {
          return t2 * this.k + this.y;
        }, invert: function(t2) {
          return [(t2[0] - this.x) / this.k, (t2[1] - this.y) / this.k];
        }, invertX: function(t2) {
          return (t2 - this.x) / this.k;
        }, invertY: function(t2) {
          return (t2 - this.y) / this.k;
        }, rescaleX: function(t2) {
          return t2.copy().domain(t2.range().map(this.invertX, this).map(t2.invert, t2));
        }, rescaleY: function(t2) {
          return t2.copy().domain(t2.range().map(this.invertY, this).map(t2.invert, t2));
        }, toString: function() {
          return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
        } };
        var kb = new Sb(1, 0, 0);
        function Eb(t2) {
          return t2.__zoom || kb;
        }
        function Cb() {
          t.event.stopImmediatePropagation();
        }
        function Pb() {
          t.event.preventDefault(), t.event.stopImmediatePropagation();
        }
        function zb() {
          return !t.event.button;
        }
        function Rb() {
          var t2, n2, e2 = this;
          return e2 instanceof window.SVGElement ? (t2 = (e2 = e2.ownerSVGElement || e2).width.baseVal.value, n2 = e2.height.baseVal.value) : (t2 = e2.clientWidth, n2 = e2.clientHeight), [[0, 0], [t2, n2]];
        }
        function Db() {
          return this.__zoom || kb;
        }
        function qb() {
          return -t.event.deltaY * (t.event.deltaMode ? 120 : 1) / 500;
        }
        function Lb() {
          return "ontouchstart" in this;
        }
        function Ub(t2, n2, e2) {
          var r2 = t2.invertX(n2[0][0]) - e2[0][0], i2 = t2.invertX(n2[1][0]) - e2[1][0], o2 = t2.invertY(n2[0][1]) - e2[0][1], a2 = t2.invertY(n2[1][1]) - e2[1][1];
          return t2.translate(i2 > r2 ? (r2 + i2) / 2 : Math.min(0, r2) || Math.max(0, i2), a2 > o2 ? (o2 + a2) / 2 : Math.min(0, o2) || Math.max(0, a2));
        }
        Eb.prototype = Sb.prototype, t.version = "5.9.1", t.bisect = i, t.bisectRight = i, t.bisectLeft = o, t.ascending = n, t.bisector = e, t.cross = function(t2, n2, e2) {
          var r2, i2, o2, u2, c2 = t2.length, f2 = n2.length, s2 = new Array(c2 * f2);
          for (null == e2 && (e2 = a), r2 = o2 = 0; r2 < c2; ++r2)
            for (u2 = t2[r2], i2 = 0; i2 < f2; ++i2, ++o2)
              s2[o2] = e2(u2, n2[i2]);
          return s2;
        }, t.descending = function(t2, n2) {
          return n2 < t2 ? -1 : n2 > t2 ? 1 : n2 >= t2 ? 0 : NaN;
        }, t.deviation = f, t.extent = s, t.histogram = function() {
          var t2 = v, n2 = s, e2 = M;
          function r2(r3) {
            var o2, a2, u2 = r3.length, c2 = new Array(u2);
            for (o2 = 0; o2 < u2; ++o2)
              c2[o2] = t2(r3[o2], o2, r3);
            var f2 = n2(c2), s2 = f2[0], l2 = f2[1], h2 = e2(c2, s2, l2);
            Array.isArray(h2) || (h2 = w(s2, l2, h2), h2 = g(Math.ceil(s2 / h2) * h2, l2, h2));
            for (var d2 = h2.length; h2[0] <= s2; )
              h2.shift(), --d2;
            for (; h2[d2 - 1] > l2; )
              h2.pop(), --d2;
            var p2, v2 = new Array(d2 + 1);
            for (o2 = 0; o2 <= d2; ++o2)
              (p2 = v2[o2] = []).x0 = o2 > 0 ? h2[o2 - 1] : s2, p2.x1 = o2 < d2 ? h2[o2] : l2;
            for (o2 = 0; o2 < u2; ++o2)
              s2 <= (a2 = c2[o2]) && a2 <= l2 && v2[i(h2, a2, 0, d2)].push(r3[o2]);
            return v2;
          }
          return r2.value = function(n3) {
            return arguments.length ? (t2 = "function" == typeof n3 ? n3 : p(n3), r2) : t2;
          }, r2.domain = function(t3) {
            return arguments.length ? (n2 = "function" == typeof t3 ? t3 : p([t3[0], t3[1]]), r2) : n2;
          }, r2.thresholds = function(t3) {
            return arguments.length ? (e2 = "function" == typeof t3 ? t3 : Array.isArray(t3) ? p(h.call(t3)) : p(t3), r2) : e2;
          }, r2;
        }, t.thresholdFreedmanDiaconis = function(t2, e2, r2) {
          return t2 = d.call(t2, u).sort(n), Math.ceil((r2 - e2) / (2 * (N(t2, 0.75) - N(t2, 0.25)) * Math.pow(t2.length, -1 / 3)));
        }, t.thresholdScott = function(t2, n2, e2) {
          return Math.ceil((e2 - n2) / (3.5 * f(t2) * Math.pow(t2.length, -1 / 3)));
        }, t.thresholdSturges = M, t.max = A, t.mean = function(t2, n2) {
          var e2, r2 = t2.length, i2 = r2, o2 = -1, a2 = 0;
          if (null == n2)
            for (; ++o2 < r2; )
              isNaN(e2 = u(t2[o2])) ? --i2 : a2 += e2;
          else
            for (; ++o2 < r2; )
              isNaN(e2 = u(n2(t2[o2], o2, t2))) ? --i2 : a2 += e2;
          if (i2)
            return a2 / i2;
        }, t.median = function(t2, e2) {
          var r2, i2 = t2.length, o2 = -1, a2 = [];
          if (null == e2)
            for (; ++o2 < i2; )
              isNaN(r2 = u(t2[o2])) || a2.push(r2);
          else
            for (; ++o2 < i2; )
              isNaN(r2 = u(e2(t2[o2], o2, t2))) || a2.push(r2);
          return N(a2.sort(n), 0.5);
        }, t.merge = T, t.min = S, t.pairs = function(t2, n2) {
          null == n2 && (n2 = a);
          for (var e2 = 0, r2 = t2.length - 1, i2 = t2[0], o2 = new Array(r2 < 0 ? 0 : r2); e2 < r2; )
            o2[e2] = n2(i2, i2 = t2[++e2]);
          return o2;
        }, t.permute = function(t2, n2) {
          for (var e2 = n2.length, r2 = new Array(e2); e2--; )
            r2[e2] = t2[n2[e2]];
          return r2;
        }, t.quantile = N, t.range = g, t.scan = function(t2, e2) {
          if (r2 = t2.length) {
            var r2, i2, o2 = 0, a2 = 0, u2 = t2[a2];
            for (null == e2 && (e2 = n); ++o2 < r2; )
              (e2(i2 = t2[o2], u2) < 0 || 0 !== e2(u2, u2)) && (u2 = i2, a2 = o2);
            return 0 === e2(u2, u2) ? a2 : void 0;
          }
        }, t.shuffle = function(t2, n2, e2) {
          for (var r2, i2, o2 = (null == e2 ? t2.length : e2) - (n2 = null == n2 ? 0 : +n2); o2; )
            i2 = Math.random() * o2-- | 0, r2 = t2[o2 + n2], t2[o2 + n2] = t2[i2 + n2], t2[i2 + n2] = r2;
          return t2;
        }, t.sum = function(t2, n2) {
          var e2, r2 = t2.length, i2 = -1, o2 = 0;
          if (null == n2)
            for (; ++i2 < r2; )
              (e2 = +t2[i2]) && (o2 += e2);
          else
            for (; ++i2 < r2; )
              (e2 = +n2(t2[i2], i2, t2)) && (o2 += e2);
          return o2;
        }, t.ticks = m, t.tickIncrement = x, t.tickStep = w, t.transpose = k, t.variance = c, t.zip = function() {
          return k(arguments);
        }, t.axisTop = function(t2) {
          return Y(z, t2);
        }, t.axisRight = function(t2) {
          return Y(R, t2);
        }, t.axisBottom = function(t2) {
          return Y(D, t2);
        }, t.axisLeft = function(t2) {
          return Y(q, t2);
        }, t.brush = function() {
          return Pi(mi);
        }, t.brushX = function() {
          return Pi(_i);
        }, t.brushY = function() {
          return Pi(bi);
        }, t.brushSelection = function(t2) {
          var n2 = t2.__brush;
          return n2 ? n2.dim.output(n2.selection) : null;
        }, t.chord = function() {
          var t2 = 0, n2 = null, e2 = null, r2 = null;
          function i2(i3) {
            var o2, a2, u2, c2, f2, s2, l2 = i3.length, h2 = [], d2 = g(l2), p2 = [], v2 = [], y2 = v2.groups = new Array(l2), _2 = new Array(l2 * l2);
            for (o2 = 0, f2 = -1; ++f2 < l2; ) {
              for (a2 = 0, s2 = -1; ++s2 < l2; )
                a2 += i3[f2][s2];
              h2.push(a2), p2.push(g(l2)), o2 += a2;
            }
            for (n2 && d2.sort(function(t3, e3) {
              return n2(h2[t3], h2[e3]);
            }), e2 && p2.forEach(function(t3, n3) {
              t3.sort(function(t4, r3) {
                return e2(i3[n3][t4], i3[n3][r3]);
              });
            }), c2 = (o2 = Ui(0, Li - t2 * l2) / o2) ? t2 : Li / l2, a2 = 0, f2 = -1; ++f2 < l2; ) {
              for (u2 = a2, s2 = -1; ++s2 < l2; ) {
                var b2 = d2[f2], m2 = p2[b2][s2], x2 = i3[b2][m2], w2 = a2, M2 = a2 += x2 * o2;
                _2[m2 * l2 + b2] = { index: b2, subindex: m2, startAngle: w2, endAngle: M2, value: x2 };
              }
              y2[b2] = { index: b2, startAngle: u2, endAngle: a2, value: h2[b2] }, a2 += c2;
            }
            for (f2 = -1; ++f2 < l2; )
              for (s2 = f2 - 1; ++s2 < l2; ) {
                var N2 = _2[s2 * l2 + f2], A2 = _2[f2 * l2 + s2];
                (N2.value || A2.value) && v2.push(N2.value < A2.value ? { source: A2, target: N2 } : { source: N2, target: A2 });
              }
            return r2 ? v2.sort(r2) : v2;
          }
          return i2.padAngle = function(n3) {
            return arguments.length ? (t2 = Ui(0, n3), i2) : t2;
          }, i2.sortGroups = function(t3) {
            return arguments.length ? (n2 = t3, i2) : n2;
          }, i2.sortSubgroups = function(t3) {
            return arguments.length ? (e2 = t3, i2) : e2;
          }, i2.sortChords = function(t3) {
            return arguments.length ? (null == t3 ? r2 = null : (n3 = t3, r2 = function(t4, e3) {
              return n3(t4.source.value + t4.target.value, e3.source.value + e3.target.value);
            })._ = t3, i2) : r2 && r2._;
            var n3;
          }, i2;
        }, t.ribbon = function() {
          var t2 = Xi, n2 = Gi, e2 = Vi, r2 = $i, i2 = Wi, o2 = null;
          function a2() {
            var a3, u2 = Oi.call(arguments), c2 = t2.apply(this, u2), f2 = n2.apply(this, u2), s2 = +e2.apply(this, (u2[0] = c2, u2)), l2 = r2.apply(this, u2) - qi, h2 = i2.apply(this, u2) - qi, d2 = s2 * zi(l2), p2 = s2 * Ri(l2), v2 = +e2.apply(this, (u2[0] = f2, u2)), g2 = r2.apply(this, u2) - qi, y2 = i2.apply(this, u2) - qi;
            if (o2 || (o2 = a3 = Hi()), o2.moveTo(d2, p2), o2.arc(0, 0, s2, l2, h2), l2 === g2 && h2 === y2 || (o2.quadraticCurveTo(0, 0, v2 * zi(g2), v2 * Ri(g2)), o2.arc(0, 0, v2, g2, y2)), o2.quadraticCurveTo(0, 0, d2, p2), o2.closePath(), a3)
              return o2 = null, a3 + "" || null;
          }
          return a2.radius = function(t3) {
            return arguments.length ? (e2 = "function" == typeof t3 ? t3 : Bi(+t3), a2) : e2;
          }, a2.startAngle = function(t3) {
            return arguments.length ? (r2 = "function" == typeof t3 ? t3 : Bi(+t3), a2) : r2;
          }, a2.endAngle = function(t3) {
            return arguments.length ? (i2 = "function" == typeof t3 ? t3 : Bi(+t3), a2) : i2;
          }, a2.source = function(n3) {
            return arguments.length ? (t2 = n3, a2) : t2;
          }, a2.target = function(t3) {
            return arguments.length ? (n2 = t3, a2) : n2;
          }, a2.context = function(t3) {
            return arguments.length ? (o2 = null == t3 ? null : t3, a2) : o2;
          }, a2;
        }, t.nest = function() {
          var t2, n2, e2, r2 = [], i2 = [];
          function o2(e3, i3, a2, u2) {
            if (i3 >= r2.length)
              return null != t2 && e3.sort(t2), null != n2 ? n2(e3) : e3;
            for (var c2, f2, s2, l2 = -1, h2 = e3.length, d2 = r2[i3++], p2 = Qi(), v2 = a2(); ++l2 < h2; )
              (s2 = p2.get(c2 = d2(f2 = e3[l2]) + "")) ? s2.push(f2) : p2.set(c2, [f2]);
            return p2.each(function(t3, n3) {
              u2(v2, n3, o2(t3, i3, a2, u2));
            }), v2;
          }
          return e2 = { object: function(t3) {
            return o2(t3, 0, Ji, Ki);
          }, map: function(t3) {
            return o2(t3, 0, to, no);
          }, entries: function(t3) {
            return function t4(e3, o3) {
              if (++o3 > r2.length)
                return e3;
              var a2, u2 = i2[o3 - 1];
              return null != n2 && o3 >= r2.length ? a2 = e3.entries() : (a2 = [], e3.each(function(n3, e4) {
                a2.push({ key: e4, values: t4(n3, o3) });
              })), null != u2 ? a2.sort(function(t5, n3) {
                return u2(t5.key, n3.key);
              }) : a2;
            }(o2(t3, 0, to, no), 0);
          }, key: function(t3) {
            return r2.push(t3), e2;
          }, sortKeys: function(t3) {
            return i2[r2.length - 1] = t3, e2;
          }, sortValues: function(n3) {
            return t2 = n3, e2;
          }, rollup: function(t3) {
            return n2 = t3, e2;
          } };
        }, t.set = io, t.map = Qi, t.keys = function(t2) {
          var n2 = [];
          for (var e2 in t2)
            n2.push(e2);
          return n2;
        }, t.values = function(t2) {
          var n2 = [];
          for (var e2 in t2)
            n2.push(t2[e2]);
          return n2;
        }, t.entries = function(t2) {
          var n2 = [];
          for (var e2 in t2)
            n2.push({ key: e2, value: t2[e2] });
          return n2;
        }, t.color = hn, t.rgb = gn, t.hsl = mn, t.lab = Rn, t.hcl = Yn, t.lch = function(t2, n2, e2, r2) {
          return 1 === arguments.length ? Bn(t2) : new Fn(e2, n2, t2, null == r2 ? 1 : r2);
        }, t.gray = function(t2, n2) {
          return new Dn(t2, 0, 0, null == n2 ? 1 : n2);
        }, t.cubehelix = Zn, t.contours = po, t.contourDensity = function() {
          var t2 = yo, n2 = _o, e2 = bo, r2 = 960, i2 = 500, o2 = 20, a2 = 2, u2 = 3 * o2, c2 = r2 + 2 * u2 >> a2, f2 = i2 + 2 * u2 >> a2, s2 = uo(20);
          function l2(r3) {
            var i3 = new Float32Array(c2 * f2), l3 = new Float32Array(c2 * f2);
            r3.forEach(function(r4, o3, s3) {
              var l4 = +t2(r4, o3, s3) + u2 >> a2, h3 = +n2(r4, o3, s3) + u2 >> a2, d5 = +e2(r4, o3, s3);
              l4 >= 0 && l4 < c2 && h3 >= 0 && h3 < f2 && (i3[l4 + h3 * c2] += d5);
            }), vo({ width: c2, height: f2, data: i3 }, { width: c2, height: f2, data: l3 }, o2 >> a2), go({ width: c2, height: f2, data: l3 }, { width: c2, height: f2, data: i3 }, o2 >> a2), vo({ width: c2, height: f2, data: i3 }, { width: c2, height: f2, data: l3 }, o2 >> a2), go({ width: c2, height: f2, data: l3 }, { width: c2, height: f2, data: i3 }, o2 >> a2), vo({ width: c2, height: f2, data: i3 }, { width: c2, height: f2, data: l3 }, o2 >> a2), go({ width: c2, height: f2, data: l3 }, { width: c2, height: f2, data: i3 }, o2 >> a2);
            var d4 = s2(i3);
            if (!Array.isArray(d4)) {
              var p3 = A(i3);
              d4 = w(0, p3, d4), (d4 = g(0, Math.floor(p3 / d4) * d4, d4)).shift();
            }
            return po().thresholds(d4).size([c2, f2])(i3).map(h2);
          }
          function h2(t3) {
            return t3.value *= Math.pow(2, -2 * a2), t3.coordinates.forEach(d2), t3;
          }
          function d2(t3) {
            t3.forEach(p2);
          }
          function p2(t3) {
            t3.forEach(v2);
          }
          function v2(t3) {
            t3[0] = t3[0] * Math.pow(2, a2) - u2, t3[1] = t3[1] * Math.pow(2, a2) - u2;
          }
          function y2() {
            return c2 = r2 + 2 * (u2 = 3 * o2) >> a2, f2 = i2 + 2 * u2 >> a2, l2;
          }
          return l2.x = function(n3) {
            return arguments.length ? (t2 = "function" == typeof n3 ? n3 : uo(+n3), l2) : t2;
          }, l2.y = function(t3) {
            return arguments.length ? (n2 = "function" == typeof t3 ? t3 : uo(+t3), l2) : n2;
          }, l2.weight = function(t3) {
            return arguments.length ? (e2 = "function" == typeof t3 ? t3 : uo(+t3), l2) : e2;
          }, l2.size = function(t3) {
            if (!arguments.length)
              return [r2, i2];
            var n3 = Math.ceil(t3[0]), e3 = Math.ceil(t3[1]);
            if (!(n3 >= 0 || n3 >= 0))
              throw new Error("invalid size");
            return r2 = n3, i2 = e3, y2();
          }, l2.cellSize = function(t3) {
            if (!arguments.length)
              return 1 << a2;
            if (!((t3 = +t3) >= 1))
              throw new Error("invalid cell size");
            return a2 = Math.floor(Math.log(t3) / Math.LN2), y2();
          }, l2.thresholds = function(t3) {
            return arguments.length ? (s2 = "function" == typeof t3 ? t3 : Array.isArray(t3) ? uo(oo.call(t3)) : uo(t3), l2) : s2;
          }, l2.bandwidth = function(t3) {
            if (!arguments.length)
              return Math.sqrt(o2 * (o2 + 1));
            if (!((t3 = +t3) >= 0))
              throw new Error("invalid bandwidth");
            return o2 = Math.round((Math.sqrt(4 * t3 * t3 + 1) - 1) / 2), y2();
          }, l2;
        }, t.dispatch = I, t.drag = function() {
          var n2, e2, r2, i2, o2 = Gt, a2 = Vt, u2 = $t, c2 = Wt, f2 = {}, s2 = I("start", "drag", "end"), l2 = 0, h2 = 0;
          function d2(t2) {
            t2.on("mousedown.drag", p2).filter(c2).on("touchstart.drag", y2).on("touchmove.drag", _2).on("touchend.drag touchcancel.drag", b2).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
          }
          function p2() {
            if (!i2 && o2.apply(this, arguments)) {
              var u3 = m2("mouse", a2.apply(this, arguments), Ot, this, arguments);
              u3 && (zt(t.event.view).on("mousemove.drag", v2, true).on("mouseup.drag", g2, true), It(t.event.view), Yt(), r2 = false, n2 = t.event.clientX, e2 = t.event.clientY, u3("start"));
            }
          }
          function v2() {
            if (Ft(), !r2) {
              var i3 = t.event.clientX - n2, o3 = t.event.clientY - e2;
              r2 = i3 * i3 + o3 * o3 > h2;
            }
            f2.mouse("drag");
          }
          function g2() {
            zt(t.event.view).on("mousemove.drag mouseup.drag", null), jt(t.event.view, r2), Ft(), f2.mouse("end");
          }
          function y2() {
            if (o2.apply(this, arguments)) {
              var n3, e3, r3 = t.event.changedTouches, i3 = a2.apply(this, arguments), u3 = r3.length;
              for (n3 = 0; n3 < u3; ++n3)
                (e3 = m2(r3[n3].identifier, i3, Bt, this, arguments)) && (Yt(), e3("start"));
            }
          }
          function _2() {
            var n3, e3, r3 = t.event.changedTouches, i3 = r3.length;
            for (n3 = 0; n3 < i3; ++n3)
              (e3 = f2[r3[n3].identifier]) && (Ft(), e3("drag"));
          }
          function b2() {
            var n3, e3, r3 = t.event.changedTouches, o3 = r3.length;
            for (i2 && window.clearTimeout(i2), i2 = window.setTimeout(function() {
              i2 = null;
            }, 500), n3 = 0; n3 < o3; ++n3)
              (e3 = f2[r3[n3].identifier]) && (Yt(), e3("end"));
          }
          function m2(n3, e3, r3, i3, o3) {
            var a3, c3, h3, p3 = r3(e3, n3), v3 = s2.copy();
            if (St(new Xt(d2, "beforestart", a3, n3, l2, p3[0], p3[1], 0, 0, v3), function() {
              return null != (t.event.subject = a3 = u2.apply(i3, o3)) && (c3 = a3.x - p3[0] || 0, h3 = a3.y - p3[1] || 0, true);
            }))
              return function t2(u3) {
                var s3, g3 = p3;
                switch (u3) {
                  case "start":
                    f2[n3] = t2, s3 = l2++;
                    break;
                  case "end":
                    delete f2[n3], --l2;
                  case "drag":
                    p3 = r3(e3, n3), s3 = l2;
                }
                St(new Xt(d2, u3, a3, n3, s3, p3[0] + c3, p3[1] + h3, p3[0] - g3[0], p3[1] - g3[1], v3), v3.apply, v3, [u3, i3, o3]);
              };
          }
          return d2.filter = function(t2) {
            return arguments.length ? (o2 = "function" == typeof t2 ? t2 : Ht(!!t2), d2) : o2;
          }, d2.container = function(t2) {
            return arguments.length ? (a2 = "function" == typeof t2 ? t2 : Ht(t2), d2) : a2;
          }, d2.subject = function(t2) {
            return arguments.length ? (u2 = "function" == typeof t2 ? t2 : Ht(t2), d2) : u2;
          }, d2.touchable = function(t2) {
            return arguments.length ? (c2 = "function" == typeof t2 ? t2 : Ht(!!t2), d2) : c2;
          }, d2.on = function() {
            var t2 = s2.on.apply(s2, arguments);
            return t2 === s2 ? d2 : t2;
          }, d2.clickDistance = function(t2) {
            return arguments.length ? (h2 = (t2 = +t2) * t2, d2) : Math.sqrt(h2);
          }, d2;
        }, t.dragDisable = It, t.dragEnable = jt, t.dsvFormat = Eo, t.csvParse = Po, t.csvParseRows = zo, t.csvFormat = Ro, t.csvFormatBody = Do, t.csvFormatRows = qo, t.tsvParse = Uo, t.tsvParseRows = Oo, t.tsvFormat = Bo, t.tsvFormatBody = Yo, t.tsvFormatRows = Fo, t.autoType = function(t2) {
          for (var n2 in t2) {
            var e2, r2 = t2[n2].trim();
            if (r2)
              if ("true" === r2)
                r2 = true;
              else if ("false" === r2)
                r2 = false;
              else if ("NaN" === r2)
                r2 = NaN;
              else if (isNaN(e2 = +r2)) {
                if (!/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/.test(r2))
                  continue;
                r2 = new Date(r2);
              } else
                r2 = e2;
            else
              r2 = null;
            t2[n2] = r2;
          }
          return t2;
        }, t.easeLinear = function(t2) {
          return +t2;
        }, t.easeQuad = Rr, t.easeQuadIn = function(t2) {
          return t2 * t2;
        }, t.easeQuadOut = function(t2) {
          return t2 * (2 - t2);
        }, t.easeQuadInOut = Rr, t.easeCubic = Dr, t.easeCubicIn = function(t2) {
          return t2 * t2 * t2;
        }, t.easeCubicOut = function(t2) {
          return --t2 * t2 * t2 + 1;
        }, t.easeCubicInOut = Dr, t.easePoly = Ur, t.easePolyIn = qr, t.easePolyOut = Lr, t.easePolyInOut = Ur, t.easeSin = Yr, t.easeSinIn = function(t2) {
          return 1 - Math.cos(t2 * Br);
        }, t.easeSinOut = function(t2) {
          return Math.sin(t2 * Br);
        }, t.easeSinInOut = Yr, t.easeExp = Fr, t.easeExpIn = function(t2) {
          return Math.pow(2, 10 * t2 - 10);
        }, t.easeExpOut = function(t2) {
          return 1 - Math.pow(2, -10 * t2);
        }, t.easeExpInOut = Fr, t.easeCircle = Ir, t.easeCircleIn = function(t2) {
          return 1 - Math.sqrt(1 - t2 * t2);
        }, t.easeCircleOut = function(t2) {
          return Math.sqrt(1 - --t2 * t2);
        }, t.easeCircleInOut = Ir, t.easeBounce = Kr, t.easeBounceIn = function(t2) {
          return 1 - Kr(1 - t2);
        }, t.easeBounceOut = Kr, t.easeBounceInOut = function(t2) {
          return ((t2 *= 2) <= 1 ? 1 - Kr(1 - t2) : Kr(t2 - 1) + 1) / 2;
        }, t.easeBack = ei, t.easeBackIn = ti, t.easeBackOut = ni, t.easeBackInOut = ei, t.easeElastic = oi, t.easeElasticIn = ii, t.easeElasticOut = oi, t.easeElasticInOut = ai, t.blob = function(t2, n2) {
          return fetch(t2, n2).then(Io);
        }, t.buffer = function(t2, n2) {
          return fetch(t2, n2).then(jo);
        }, t.dsv = function(t2, n2, e2, r2) {
          3 === arguments.length && "function" == typeof e2 && (r2 = e2, e2 = void 0);
          var i2 = Eo(t2);
          return Xo(n2, e2).then(function(t3) {
            return i2.parse(t3, r2);
          });
        }, t.csv = Vo, t.tsv = $o, t.image = function(t2, n2) {
          return new Promise(function(e2, r2) {
            var i2 = new Image();
            for (var o2 in n2)
              i2[o2] = n2[o2];
            i2.onerror = r2, i2.onload = function() {
              e2(i2);
            }, i2.src = t2;
          });
        }, t.json = function(t2, n2) {
          return fetch(t2, n2).then(Wo);
        }, t.text = Xo, t.xml = Qo, t.html = Jo, t.svg = Ko, t.forceCenter = function(t2, n2) {
          var e2;
          function r2() {
            var r3, i2, o2 = e2.length, a2 = 0, u2 = 0;
            for (r3 = 0; r3 < o2; ++r3)
              a2 += (i2 = e2[r3]).x, u2 += i2.y;
            for (a2 = a2 / o2 - t2, u2 = u2 / o2 - n2, r3 = 0; r3 < o2; ++r3)
              (i2 = e2[r3]).x -= a2, i2.y -= u2;
          }
          return null == t2 && (t2 = 0), null == n2 && (n2 = 0), r2.initialize = function(t3) {
            e2 = t3;
          }, r2.x = function(n3) {
            return arguments.length ? (t2 = +n3, r2) : t2;
          }, r2.y = function(t3) {
            return arguments.length ? (n2 = +t3, r2) : n2;
          }, r2;
        }, t.forceCollide = function(t2) {
          var n2, e2, r2 = 1, i2 = 1;
          function o2() {
            for (var t3, o3, u3, c2, f2, s2, l2, h2 = n2.length, d2 = 0; d2 < i2; ++d2)
              for (o3 = aa(n2, sa, la).visitAfter(a2), t3 = 0; t3 < h2; ++t3)
                u3 = n2[t3], s2 = e2[u3.index], l2 = s2 * s2, c2 = u3.x + u3.vx, f2 = u3.y + u3.vy, o3.visit(p2);
            function p2(t4, n3, e3, i3, o4) {
              var a3 = t4.data, h3 = t4.r, d4 = s2 + h3;
              if (!a3)
                return n3 > c2 + d4 || i3 < c2 - d4 || e3 > f2 + d4 || o4 < f2 - d4;
              if (a3.index > u3.index) {
                var p3 = c2 - a3.x - a3.vx, v2 = f2 - a3.y - a3.vy, g2 = p3 * p3 + v2 * v2;
                g2 < d4 * d4 && (0 === p3 && (g2 += (p3 = na()) * p3), 0 === v2 && (g2 += (v2 = na()) * v2), g2 = (d4 - (g2 = Math.sqrt(g2))) / g2 * r2, u3.vx += (p3 *= g2) * (d4 = (h3 *= h3) / (l2 + h3)), u3.vy += (v2 *= g2) * d4, a3.vx -= p3 * (d4 = 1 - d4), a3.vy -= v2 * d4);
              }
            }
          }
          function a2(t3) {
            if (t3.data)
              return t3.r = e2[t3.data.index];
            for (var n3 = t3.r = 0; n3 < 4; ++n3)
              t3[n3] && t3[n3].r > t3.r && (t3.r = t3[n3].r);
          }
          function u2() {
            if (n2) {
              var r3, i3, o3 = n2.length;
              for (e2 = new Array(o3), r3 = 0; r3 < o3; ++r3)
                i3 = n2[r3], e2[i3.index] = +t2(i3, r3, n2);
            }
          }
          return "function" != typeof t2 && (t2 = ta(null == t2 ? 1 : +t2)), o2.initialize = function(t3) {
            n2 = t3, u2();
          }, o2.iterations = function(t3) {
            return arguments.length ? (i2 = +t3, o2) : i2;
          }, o2.strength = function(t3) {
            return arguments.length ? (r2 = +t3, o2) : r2;
          }, o2.radius = function(n3) {
            return arguments.length ? (t2 = "function" == typeof n3 ? n3 : ta(+n3), u2(), o2) : t2;
          }, o2;
        }, t.forceLink = function(t2) {
          var n2, e2, r2, i2, o2, a2 = ha, u2 = function(t3) {
            return 1 / Math.min(i2[t3.source.index], i2[t3.target.index]);
          }, c2 = ta(30), f2 = 1;
          function s2(r3) {
            for (var i3 = 0, a3 = t2.length; i3 < f2; ++i3)
              for (var u3, c3, s3, l3, h3, d4, p2, v2 = 0; v2 < a3; ++v2)
                c3 = (u3 = t2[v2]).source, l3 = (s3 = u3.target).x + s3.vx - c3.x - c3.vx || na(), h3 = s3.y + s3.vy - c3.y - c3.vy || na(), l3 *= d4 = ((d4 = Math.sqrt(l3 * l3 + h3 * h3)) - e2[v2]) / d4 * r3 * n2[v2], h3 *= d4, s3.vx -= l3 * (p2 = o2[v2]), s3.vy -= h3 * p2, c3.vx += l3 * (p2 = 1 - p2), c3.vy += h3 * p2;
          }
          function l2() {
            if (r2) {
              var u3, c3, f3 = r2.length, s3 = t2.length, l3 = Qi(r2, a2);
              for (u3 = 0, i2 = new Array(f3); u3 < s3; ++u3)
                (c3 = t2[u3]).index = u3, "object" != typeof c3.source && (c3.source = da(l3, c3.source)), "object" != typeof c3.target && (c3.target = da(l3, c3.target)), i2[c3.source.index] = (i2[c3.source.index] || 0) + 1, i2[c3.target.index] = (i2[c3.target.index] || 0) + 1;
              for (u3 = 0, o2 = new Array(s3); u3 < s3; ++u3)
                c3 = t2[u3], o2[u3] = i2[c3.source.index] / (i2[c3.source.index] + i2[c3.target.index]);
              n2 = new Array(s3), h2(), e2 = new Array(s3), d2();
            }
          }
          function h2() {
            if (r2)
              for (var e3 = 0, i3 = t2.length; e3 < i3; ++e3)
                n2[e3] = +u2(t2[e3], e3, t2);
          }
          function d2() {
            if (r2)
              for (var n3 = 0, i3 = t2.length; n3 < i3; ++n3)
                e2[n3] = +c2(t2[n3], n3, t2);
          }
          return null == t2 && (t2 = []), s2.initialize = function(t3) {
            r2 = t3, l2();
          }, s2.links = function(n3) {
            return arguments.length ? (t2 = n3, l2(), s2) : t2;
          }, s2.id = function(t3) {
            return arguments.length ? (a2 = t3, s2) : a2;
          }, s2.iterations = function(t3) {
            return arguments.length ? (f2 = +t3, s2) : f2;
          }, s2.strength = function(t3) {
            return arguments.length ? (u2 = "function" == typeof t3 ? t3 : ta(+t3), h2(), s2) : u2;
          }, s2.distance = function(t3) {
            return arguments.length ? (c2 = "function" == typeof t3 ? t3 : ta(+t3), d2(), s2) : c2;
          }, s2;
        }, t.forceManyBody = function() {
          var t2, n2, e2, r2, i2 = ta(-30), o2 = 1, a2 = 1 / 0, u2 = 0.81;
          function c2(r3) {
            var i3, o3 = t2.length, a3 = aa(t2, pa, va).visitAfter(s2);
            for (e2 = r3, i3 = 0; i3 < o3; ++i3)
              n2 = t2[i3], a3.visit(l2);
          }
          function f2() {
            if (t2) {
              var n3, e3, o3 = t2.length;
              for (r2 = new Array(o3), n3 = 0; n3 < o3; ++n3)
                e3 = t2[n3], r2[e3.index] = +i2(e3, n3, t2);
            }
          }
          function s2(t3) {
            var n3, e3, i3, o3, a3, u3 = 0, c3 = 0;
            if (t3.length) {
              for (i3 = o3 = a3 = 0; a3 < 4; ++a3)
                (n3 = t3[a3]) && (e3 = Math.abs(n3.value)) && (u3 += n3.value, c3 += e3, i3 += e3 * n3.x, o3 += e3 * n3.y);
              t3.x = i3 / c3, t3.y = o3 / c3;
            } else {
              (n3 = t3).x = n3.data.x, n3.y = n3.data.y;
              do {
                u3 += r2[n3.data.index];
              } while (n3 = n3.next);
            }
            t3.value = u3;
          }
          function l2(t3, i3, c3, f3) {
            if (!t3.value)
              return true;
            var s3 = t3.x - n2.x, l3 = t3.y - n2.y, h2 = f3 - i3, d2 = s3 * s3 + l3 * l3;
            if (h2 * h2 / u2 < d2)
              return d2 < a2 && (0 === s3 && (d2 += (s3 = na()) * s3), 0 === l3 && (d2 += (l3 = na()) * l3), d2 < o2 && (d2 = Math.sqrt(o2 * d2)), n2.vx += s3 * t3.value * e2 / d2, n2.vy += l3 * t3.value * e2 / d2), true;
            if (!(t3.length || d2 >= a2)) {
              (t3.data !== n2 || t3.next) && (0 === s3 && (d2 += (s3 = na()) * s3), 0 === l3 && (d2 += (l3 = na()) * l3), d2 < o2 && (d2 = Math.sqrt(o2 * d2)));
              do {
                t3.data !== n2 && (h2 = r2[t3.data.index] * e2 / d2, n2.vx += s3 * h2, n2.vy += l3 * h2);
              } while (t3 = t3.next);
            }
          }
          return c2.initialize = function(n3) {
            t2 = n3, f2();
          }, c2.strength = function(t3) {
            return arguments.length ? (i2 = "function" == typeof t3 ? t3 : ta(+t3), f2(), c2) : i2;
          }, c2.distanceMin = function(t3) {
            return arguments.length ? (o2 = t3 * t3, c2) : Math.sqrt(o2);
          }, c2.distanceMax = function(t3) {
            return arguments.length ? (a2 = t3 * t3, c2) : Math.sqrt(a2);
          }, c2.theta = function(t3) {
            return arguments.length ? (u2 = t3 * t3, c2) : Math.sqrt(u2);
          }, c2;
        }, t.forceRadial = function(t2, n2, e2) {
          var r2, i2, o2, a2 = ta(0.1);
          function u2(t3) {
            for (var a3 = 0, u3 = r2.length; a3 < u3; ++a3) {
              var c3 = r2[a3], f2 = c3.x - n2 || 1e-6, s2 = c3.y - e2 || 1e-6, l2 = Math.sqrt(f2 * f2 + s2 * s2), h2 = (o2[a3] - l2) * i2[a3] * t3 / l2;
              c3.vx += f2 * h2, c3.vy += s2 * h2;
            }
          }
          function c2() {
            if (r2) {
              var n3, e3 = r2.length;
              for (i2 = new Array(e3), o2 = new Array(e3), n3 = 0; n3 < e3; ++n3)
                o2[n3] = +t2(r2[n3], n3, r2), i2[n3] = isNaN(o2[n3]) ? 0 : +a2(r2[n3], n3, r2);
            }
          }
          return "function" != typeof t2 && (t2 = ta(+t2)), null == n2 && (n2 = 0), null == e2 && (e2 = 0), u2.initialize = function(t3) {
            r2 = t3, c2();
          }, u2.strength = function(t3) {
            return arguments.length ? (a2 = "function" == typeof t3 ? t3 : ta(+t3), c2(), u2) : a2;
          }, u2.radius = function(n3) {
            return arguments.length ? (t2 = "function" == typeof n3 ? n3 : ta(+n3), c2(), u2) : t2;
          }, u2.x = function(t3) {
            return arguments.length ? (n2 = +t3, u2) : n2;
          }, u2.y = function(t3) {
            return arguments.length ? (e2 = +t3, u2) : e2;
          }, u2;
        }, t.forceSimulation = function(t2) {
          var n2, e2 = 1, r2 = 1e-3, i2 = 1 - Math.pow(r2, 1 / 300), o2 = 0, a2 = 0.6, u2 = Qi(), c2 = ir(s2), f2 = I("tick", "end");
          function s2() {
            l2(), f2.call("tick", n2), e2 < r2 && (c2.stop(), f2.call("end", n2));
          }
          function l2(r3) {
            var c3, f3, s3 = t2.length;
            void 0 === r3 && (r3 = 1);
            for (var l3 = 0; l3 < r3; ++l3)
              for (e2 += (o2 - e2) * i2, u2.each(function(t3) {
                t3(e2);
              }), c3 = 0; c3 < s3; ++c3)
                null == (f3 = t2[c3]).fx ? f3.x += f3.vx *= a2 : (f3.x = f3.fx, f3.vx = 0), null == f3.fy ? f3.y += f3.vy *= a2 : (f3.y = f3.fy, f3.vy = 0);
            return n2;
          }
          function h2() {
            for (var n3, e3 = 0, r3 = t2.length; e3 < r3; ++e3) {
              if ((n3 = t2[e3]).index = e3, isNaN(n3.fx) || (n3.x = n3.fx), isNaN(n3.fy) || (n3.y = n3.fy), isNaN(n3.x) || isNaN(n3.y)) {
                var i3 = ga * Math.sqrt(e3), o3 = e3 * ya;
                n3.x = i3 * Math.cos(o3), n3.y = i3 * Math.sin(o3);
              }
              (isNaN(n3.vx) || isNaN(n3.vy)) && (n3.vx = n3.vy = 0);
            }
          }
          function d2(n3) {
            return n3.initialize && n3.initialize(t2), n3;
          }
          return null == t2 && (t2 = []), h2(), n2 = { tick: l2, restart: function() {
            return c2.restart(s2), n2;
          }, stop: function() {
            return c2.stop(), n2;
          }, nodes: function(e3) {
            return arguments.length ? (t2 = e3, h2(), u2.each(d2), n2) : t2;
          }, alpha: function(t3) {
            return arguments.length ? (e2 = +t3, n2) : e2;
          }, alphaMin: function(t3) {
            return arguments.length ? (r2 = +t3, n2) : r2;
          }, alphaDecay: function(t3) {
            return arguments.length ? (i2 = +t3, n2) : +i2;
          }, alphaTarget: function(t3) {
            return arguments.length ? (o2 = +t3, n2) : o2;
          }, velocityDecay: function(t3) {
            return arguments.length ? (a2 = 1 - t3, n2) : 1 - a2;
          }, force: function(t3, e3) {
            return arguments.length > 1 ? (null == e3 ? u2.remove(t3) : u2.set(t3, d2(e3)), n2) : u2.get(t3);
          }, find: function(n3, e3, r3) {
            var i3, o3, a3, u3, c3, f3 = 0, s3 = t2.length;
            for (null == r3 ? r3 = 1 / 0 : r3 *= r3, f3 = 0; f3 < s3; ++f3)
              (a3 = (i3 = n3 - (u3 = t2[f3]).x) * i3 + (o3 = e3 - u3.y) * o3) < r3 && (c3 = u3, r3 = a3);
            return c3;
          }, on: function(t3, e3) {
            return arguments.length > 1 ? (f2.on(t3, e3), n2) : f2.on(t3);
          } };
        }, t.forceX = function(t2) {
          var n2, e2, r2, i2 = ta(0.1);
          function o2(t3) {
            for (var i3, o3 = 0, a3 = n2.length; o3 < a3; ++o3)
              (i3 = n2[o3]).vx += (r2[o3] - i3.x) * e2[o3] * t3;
          }
          function a2() {
            if (n2) {
              var o3, a3 = n2.length;
              for (e2 = new Array(a3), r2 = new Array(a3), o3 = 0; o3 < a3; ++o3)
                e2[o3] = isNaN(r2[o3] = +t2(n2[o3], o3, n2)) ? 0 : +i2(n2[o3], o3, n2);
            }
          }
          return "function" != typeof t2 && (t2 = ta(null == t2 ? 0 : +t2)), o2.initialize = function(t3) {
            n2 = t3, a2();
          }, o2.strength = function(t3) {
            return arguments.length ? (i2 = "function" == typeof t3 ? t3 : ta(+t3), a2(), o2) : i2;
          }, o2.x = function(n3) {
            return arguments.length ? (t2 = "function" == typeof n3 ? n3 : ta(+n3), a2(), o2) : t2;
          }, o2;
        }, t.forceY = function(t2) {
          var n2, e2, r2, i2 = ta(0.1);
          function o2(t3) {
            for (var i3, o3 = 0, a3 = n2.length; o3 < a3; ++o3)
              (i3 = n2[o3]).vy += (r2[o3] - i3.y) * e2[o3] * t3;
          }
          function a2() {
            if (n2) {
              var o3, a3 = n2.length;
              for (e2 = new Array(a3), r2 = new Array(a3), o3 = 0; o3 < a3; ++o3)
                e2[o3] = isNaN(r2[o3] = +t2(n2[o3], o3, n2)) ? 0 : +i2(n2[o3], o3, n2);
            }
          }
          return "function" != typeof t2 && (t2 = ta(null == t2 ? 0 : +t2)), o2.initialize = function(t3) {
            n2 = t3, a2();
          }, o2.strength = function(t3) {
            return arguments.length ? (i2 = "function" == typeof t3 ? t3 : ta(+t3), a2(), o2) : i2;
          }, o2.y = function(n3) {
            return arguments.length ? (t2 = "function" == typeof n3 ? n3 : ta(+n3), a2(), o2) : t2;
          }, o2;
        }, t.formatDefaultLocale = Ca, t.formatLocale = Ea, t.formatSpecifier = wa, t.precisionFixed = Pa, t.precisionPrefix = za, t.precisionRound = Ra, t.geoArea = function(t2) {
          return mu.reset(), du(t2, xu), 2 * mu;
        }, t.geoBounds = function(t2) {
          var n2, e2, r2, i2, o2, a2, u2;
          if (Lu = qu = -(Ru = Du = 1 / 0), Fu = [], du(t2, ac), e2 = Fu.length) {
            for (Fu.sort(vc), n2 = 1, o2 = [r2 = Fu[0]]; n2 < e2; ++n2)
              gc(r2, (i2 = Fu[n2])[0]) || gc(r2, i2[1]) ? (pc(r2[0], i2[1]) > pc(r2[0], r2[1]) && (r2[1] = i2[1]), pc(i2[0], r2[1]) > pc(r2[0], r2[1]) && (r2[0] = i2[0])) : o2.push(r2 = i2);
            for (a2 = -1 / 0, n2 = 0, r2 = o2[e2 = o2.length - 1]; n2 <= e2; r2 = i2, ++n2)
              i2 = o2[n2], (u2 = pc(r2[1], i2[0])) > a2 && (a2 = u2, Ru = i2[0], qu = r2[1]);
          }
          return Fu = Iu = null, Ru === 1 / 0 || Du === 1 / 0 ? [[NaN, NaN], [NaN, NaN]] : [[Ru, Du], [qu, Lu]];
        }, t.geoCentroid = function(t2) {
          ju = Hu = Xu = Gu = Vu = $u = Wu = Zu = Qu = Ju = Ku = 0, du(t2, yc);
          var n2 = Qu, e2 = Ju, r2 = Ku, i2 = n2 * n2 + e2 * e2 + r2 * r2;
          return i2 < Ba && (n2 = $u, e2 = Wu, r2 = Zu, Hu < Oa && (n2 = Xu, e2 = Gu, r2 = Vu), (i2 = n2 * n2 + e2 * e2 + r2 * r2) < Ba) ? [NaN, NaN] : [$a(e2, n2) * Ha, ou(r2 / eu(i2)) * Ha];
        }, t.geoCircle = function() {
          var t2, n2, e2 = kc([0, 0]), r2 = kc(90), i2 = kc(6), o2 = { point: function(e3, r3) {
            t2.push(e3 = n2(e3, r3)), e3[0] *= Ha, e3[1] *= Ha;
          } };
          function a2() {
            var a3 = e2.apply(this, arguments), u2 = r2.apply(this, arguments) * Xa, c2 = i2.apply(this, arguments) * Xa;
            return t2 = [], n2 = Pc(-a3[0] * Xa, -a3[1] * Xa, 0).invert, Lc(o2, u2, c2, 1), a3 = { type: "Polygon", coordinates: [t2] }, t2 = n2 = null, a3;
          }
          return a2.center = function(t3) {
            return arguments.length ? (e2 = "function" == typeof t3 ? t3 : kc([+t3[0], +t3[1]]), a2) : e2;
          }, a2.radius = function(t3) {
            return arguments.length ? (r2 = "function" == typeof t3 ? t3 : kc(+t3), a2) : r2;
          }, a2.precision = function(t3) {
            return arguments.length ? (i2 = "function" == typeof t3 ? t3 : kc(+t3), a2) : i2;
          }, a2;
        }, t.geoClipAntimeridian = $c, t.geoClipCircle = Wc, t.geoClipExtent = function() {
          var t2, n2, e2, r2 = 0, i2 = 0, o2 = 960, a2 = 500;
          return e2 = { stream: function(e3) {
            return t2 && n2 === e3 ? t2 : t2 = Jc(r2, i2, o2, a2)(n2 = e3);
          }, extent: function(u2) {
            return arguments.length ? (r2 = +u2[0][0], i2 = +u2[0][1], o2 = +u2[1][0], a2 = +u2[1][1], t2 = n2 = null, e2) : [[r2, i2], [o2, a2]];
          } };
        }, t.geoClipRectangle = Jc, t.geoContains = function(t2, n2) {
          return (t2 && hf.hasOwnProperty(t2.type) ? hf[t2.type] : pf)(t2, n2);
        }, t.geoDistance = lf, t.geoGraticule = wf, t.geoGraticule10 = function() {
          return wf()();
        }, t.geoInterpolate = function(t2, n2) {
          var e2 = t2[0] * Xa, r2 = t2[1] * Xa, i2 = n2[0] * Xa, o2 = n2[1] * Xa, a2 = Wa(r2), u2 = tu(r2), c2 = Wa(o2), f2 = tu(o2), s2 = a2 * Wa(e2), l2 = a2 * tu(e2), h2 = c2 * Wa(i2), d2 = c2 * tu(i2), p2 = 2 * ou(eu(au(o2 - r2) + a2 * c2 * au(i2 - e2))), v2 = tu(p2), g2 = p2 ? function(t3) {
            var n3 = tu(t3 *= p2) / v2, e3 = tu(p2 - t3) / v2, r3 = e3 * s2 + n3 * h2, i3 = e3 * l2 + n3 * d2, o3 = e3 * u2 + n3 * f2;
            return [$a(i3, r3) * Ha, $a(o3, eu(r3 * r3 + i3 * i3)) * Ha];
          } : function() {
            return [e2 * Ha, r2 * Ha];
          };
          return g2.distance = p2, g2;
        }, t.geoLength = cf, t.geoPath = function(t2, n2) {
          var e2, r2, i2 = 4.5;
          function o2(t3) {
            return t3 && ("function" == typeof i2 && r2.pointRadius(+i2.apply(this, arguments)), du(t3, e2(r2))), r2.result();
          }
          return o2.area = function(t3) {
            return du(t3, e2(Cf)), Cf.result();
          }, o2.measure = function(t3) {
            return du(t3, e2(gs)), gs.result();
          }, o2.bounds = function(t3) {
            return du(t3, e2(Bf)), Bf.result();
          }, o2.centroid = function(t3) {
            return du(t3, e2(Kf)), Kf.result();
          }, o2.projection = function(n3) {
            return arguments.length ? (e2 = null == n3 ? (t2 = null, Mf) : (t2 = n3).stream, o2) : t2;
          }, o2.context = function(t3) {
            return arguments.length ? (r2 = null == t3 ? (n2 = null, new bs()) : new fs(n2 = t3), "function" != typeof i2 && r2.pointRadius(i2), o2) : n2;
          }, o2.pointRadius = function(t3) {
            return arguments.length ? (i2 = "function" == typeof t3 ? t3 : (r2.pointRadius(+t3), +t3), o2) : i2;
          }, o2.projection(t2).context(n2);
        }, t.geoAlbers = Os, t.geoAlbersUsa = function() {
          var t2, n2, e2, r2, i2, o2, a2 = Os(), u2 = Us().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), c2 = Us().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), f2 = { point: function(t3, n3) {
            o2 = [t3, n3];
          } };
          function s2(t3) {
            var n3 = t3[0], a3 = t3[1];
            return o2 = null, e2.point(n3, a3), o2 || (r2.point(n3, a3), o2) || (i2.point(n3, a3), o2);
          }
          function l2() {
            return t2 = n2 = null, s2;
          }
          return s2.invert = function(t3) {
            var n3 = a2.scale(), e3 = a2.translate(), r3 = (t3[0] - e3[0]) / n3, i3 = (t3[1] - e3[1]) / n3;
            return (i3 >= 0.12 && i3 < 0.234 && r3 >= -0.425 && r3 < -0.214 ? u2 : i3 >= 0.166 && i3 < 0.234 && r3 >= -0.214 && r3 < -0.115 ? c2 : a2).invert(t3);
          }, s2.stream = function(e3) {
            return t2 && n2 === e3 ? t2 : (r3 = [a2.stream(n2 = e3), u2.stream(e3), c2.stream(e3)], i3 = r3.length, t2 = { point: function(t3, n3) {
              for (var e4 = -1; ++e4 < i3; )
                r3[e4].point(t3, n3);
            }, sphere: function() {
              for (var t3 = -1; ++t3 < i3; )
                r3[t3].sphere();
            }, lineStart: function() {
              for (var t3 = -1; ++t3 < i3; )
                r3[t3].lineStart();
            }, lineEnd: function() {
              for (var t3 = -1; ++t3 < i3; )
                r3[t3].lineEnd();
            }, polygonStart: function() {
              for (var t3 = -1; ++t3 < i3; )
                r3[t3].polygonStart();
            }, polygonEnd: function() {
              for (var t3 = -1; ++t3 < i3; )
                r3[t3].polygonEnd();
            } });
            var r3, i3;
          }, s2.precision = function(t3) {
            return arguments.length ? (a2.precision(t3), u2.precision(t3), c2.precision(t3), l2()) : a2.precision();
          }, s2.scale = function(t3) {
            return arguments.length ? (a2.scale(t3), u2.scale(0.35 * t3), c2.scale(t3), s2.translate(a2.translate())) : a2.scale();
          }, s2.translate = function(t3) {
            if (!arguments.length)
              return a2.translate();
            var n3 = a2.scale(), o3 = +t3[0], s3 = +t3[1];
            return e2 = a2.translate(t3).clipExtent([[o3 - 0.455 * n3, s3 - 0.238 * n3], [o3 + 0.455 * n3, s3 + 0.238 * n3]]).stream(f2), r2 = u2.translate([o3 - 0.307 * n3, s3 + 0.201 * n3]).clipExtent([[o3 - 0.425 * n3 + Oa, s3 + 0.12 * n3 + Oa], [o3 - 0.214 * n3 - Oa, s3 + 0.234 * n3 - Oa]]).stream(f2), i2 = c2.translate([o3 - 0.205 * n3, s3 + 0.212 * n3]).clipExtent([[o3 - 0.214 * n3 + Oa, s3 + 0.166 * n3 + Oa], [o3 - 0.115 * n3 - Oa, s3 + 0.234 * n3 - Oa]]).stream(f2), l2();
          }, s2.fitExtent = function(t3, n3) {
            return Ns(s2, t3, n3);
          }, s2.fitSize = function(t3, n3) {
            return As(s2, t3, n3);
          }, s2.fitWidth = function(t3, n3) {
            return Ts(s2, t3, n3);
          }, s2.fitHeight = function(t3, n3) {
            return Ss(s2, t3, n3);
          }, s2.scale(1070);
        }, t.geoAzimuthalEqualArea = function() {
          return Rs(Fs).scale(124.75).clipAngle(179.999);
        }, t.geoAzimuthalEqualAreaRaw = Fs, t.geoAzimuthalEquidistant = function() {
          return Rs(Is).scale(79.4188).clipAngle(179.999);
        }, t.geoAzimuthalEquidistantRaw = Is, t.geoConicConformal = function() {
          return qs(Gs).scale(109.5).parallels([30, 30]);
        }, t.geoConicConformalRaw = Gs, t.geoConicEqualArea = Us, t.geoConicEqualAreaRaw = Ls, t.geoConicEquidistant = function() {
          return qs($s).scale(131.154).center([0, 13.9389]);
        }, t.geoConicEquidistantRaw = $s, t.geoEqualEarth = function() {
          return Rs(tl).scale(177.158);
        }, t.geoEqualEarthRaw = tl, t.geoEquirectangular = function() {
          return Rs(Vs).scale(152.63);
        }, t.geoEquirectangularRaw = Vs, t.geoGnomonic = function() {
          return Rs(nl).scale(144.049).clipAngle(60);
        }, t.geoGnomonicRaw = nl, t.geoIdentity = function() {
          var t2, n2, e2, r2, i2, o2, a2 = 1, u2 = 0, c2 = 0, f2 = 1, s2 = 1, l2 = Mf, h2 = null, d2 = Mf;
          function p2() {
            return r2 = i2 = null, o2;
          }
          return o2 = { stream: function(t3) {
            return r2 && i2 === t3 ? r2 : r2 = l2(d2(i2 = t3));
          }, postclip: function(r3) {
            return arguments.length ? (d2 = r3, h2 = t2 = n2 = e2 = null, p2()) : d2;
          }, clipExtent: function(r3) {
            return arguments.length ? (d2 = null == r3 ? (h2 = t2 = n2 = e2 = null, Mf) : Jc(h2 = +r3[0][0], t2 = +r3[0][1], n2 = +r3[1][0], e2 = +r3[1][1]), p2()) : null == h2 ? null : [[h2, t2], [n2, e2]];
          }, scale: function(t3) {
            return arguments.length ? (l2 = el((a2 = +t3) * f2, a2 * s2, u2, c2), p2()) : a2;
          }, translate: function(t3) {
            return arguments.length ? (l2 = el(a2 * f2, a2 * s2, u2 = +t3[0], c2 = +t3[1]), p2()) : [u2, c2];
          }, reflectX: function(t3) {
            return arguments.length ? (l2 = el(a2 * (f2 = t3 ? -1 : 1), a2 * s2, u2, c2), p2()) : f2 < 0;
          }, reflectY: function(t3) {
            return arguments.length ? (l2 = el(a2 * f2, a2 * (s2 = t3 ? -1 : 1), u2, c2), p2()) : s2 < 0;
          }, fitExtent: function(t3, n3) {
            return Ns(o2, t3, n3);
          }, fitSize: function(t3, n3) {
            return As(o2, t3, n3);
          }, fitWidth: function(t3, n3) {
            return Ts(o2, t3, n3);
          }, fitHeight: function(t3, n3) {
            return Ss(o2, t3, n3);
          } };
        }, t.geoProjection = Rs, t.geoProjectionMutator = Ds, t.geoMercator = function() {
          return Hs(js).scale(961 / ja);
        }, t.geoMercatorRaw = js, t.geoNaturalEarth1 = function() {
          return Rs(rl).scale(175.295);
        }, t.geoNaturalEarth1Raw = rl, t.geoOrthographic = function() {
          return Rs(il).scale(249.5).clipAngle(90 + Oa);
        }, t.geoOrthographicRaw = il, t.geoStereographic = function() {
          return Rs(ol).scale(250).clipAngle(142);
        }, t.geoStereographicRaw = ol, t.geoTransverseMercator = function() {
          var t2 = Hs(al), n2 = t2.center, e2 = t2.rotate;
          return t2.center = function(t3) {
            return arguments.length ? n2([-t3[1], t3[0]]) : [(t3 = n2())[1], -t3[0]];
          }, t2.rotate = function(t3) {
            return arguments.length ? e2([t3[0], t3[1], t3.length > 2 ? t3[2] + 90 : 90]) : [(t3 = e2())[0], t3[1], t3[2] - 90];
          }, e2([0, 0, 90]).scale(159.155);
        }, t.geoTransverseMercatorRaw = al, t.geoRotation = qc, t.geoStream = du, t.geoTransform = function(t2) {
          return { stream: xs(t2) };
        }, t.cluster = function() {
          var t2 = ul, n2 = 1, e2 = 1, r2 = false;
          function i2(i3) {
            var o2, a2 = 0;
            i3.eachAfter(function(n3) {
              var e3 = n3.children;
              e3 ? (n3.x = function(t3) {
                return t3.reduce(cl, 0) / t3.length;
              }(e3), n3.y = function(t3) {
                return 1 + t3.reduce(fl, 0);
              }(e3)) : (n3.x = o2 ? a2 += t2(n3, o2) : 0, n3.y = 0, o2 = n3);
            });
            var u2 = function(t3) {
              for (var n3; n3 = t3.children; )
                t3 = n3[0];
              return t3;
            }(i3), c2 = function(t3) {
              for (var n3; n3 = t3.children; )
                t3 = n3[n3.length - 1];
              return t3;
            }(i3), f2 = u2.x - t2(u2, c2) / 2, s2 = c2.x + t2(c2, u2) / 2;
            return i3.eachAfter(r2 ? function(t3) {
              t3.x = (t3.x - i3.x) * n2, t3.y = (i3.y - t3.y) * e2;
            } : function(t3) {
              t3.x = (t3.x - f2) / (s2 - f2) * n2, t3.y = (1 - (i3.y ? t3.y / i3.y : 1)) * e2;
            });
          }
          return i2.separation = function(n3) {
            return arguments.length ? (t2 = n3, i2) : t2;
          }, i2.size = function(t3) {
            return arguments.length ? (r2 = false, n2 = +t3[0], e2 = +t3[1], i2) : r2 ? null : [n2, e2];
          }, i2.nodeSize = function(t3) {
            return arguments.length ? (r2 = true, n2 = +t3[0], e2 = +t3[1], i2) : r2 ? [n2, e2] : null;
          }, i2;
        }, t.hierarchy = ll, t.pack = function() {
          var t2 = null, n2 = 1, e2 = 1, r2 = Pl;
          function i2(i3) {
            return i3.x = n2 / 2, i3.y = e2 / 2, t2 ? i3.eachBefore(Dl(t2)).eachAfter(ql(r2, 0.5)).eachBefore(Ll(1)) : i3.eachBefore(Dl(Rl)).eachAfter(ql(Pl, 1)).eachAfter(ql(r2, i3.r / Math.min(n2, e2))).eachBefore(Ll(Math.min(n2, e2) / (2 * i3.r))), i3;
          }
          return i2.radius = function(n3) {
            return arguments.length ? (t2 = null == (e3 = n3) ? null : Cl(e3), i2) : t2;
            var e3;
          }, i2.size = function(t3) {
            return arguments.length ? (n2 = +t3[0], e2 = +t3[1], i2) : [n2, e2];
          }, i2.padding = function(t3) {
            return arguments.length ? (r2 = "function" == typeof t3 ? t3 : zl(+t3), i2) : r2;
          }, i2;
        }, t.packSiblings = function(t2) {
          return El(t2), t2;
        }, t.packEnclose = yl, t.partition = function() {
          var t2 = 1, n2 = 1, e2 = 0, r2 = false;
          function i2(i3) {
            var o2 = i3.height + 1;
            return i3.x0 = i3.y0 = e2, i3.x1 = t2, i3.y1 = n2 / o2, i3.eachBefore(function(t3, n3) {
              return function(r3) {
                r3.children && Ol(r3, r3.x0, t3 * (r3.depth + 1) / n3, r3.x1, t3 * (r3.depth + 2) / n3);
                var i4 = r3.x0, o3 = r3.y0, a2 = r3.x1 - e2, u2 = r3.y1 - e2;
                a2 < i4 && (i4 = a2 = (i4 + a2) / 2), u2 < o3 && (o3 = u2 = (o3 + u2) / 2), r3.x0 = i4, r3.y0 = o3, r3.x1 = a2, r3.y1 = u2;
              };
            }(n2, o2)), r2 && i3.eachBefore(Ul), i3;
          }
          return i2.round = function(t3) {
            return arguments.length ? (r2 = !!t3, i2) : r2;
          }, i2.size = function(e3) {
            return arguments.length ? (t2 = +e3[0], n2 = +e3[1], i2) : [t2, n2];
          }, i2.padding = function(t3) {
            return arguments.length ? (e2 = +t3, i2) : e2;
          }, i2;
        }, t.stratify = function() {
          var t2 = Il, n2 = jl;
          function e2(e3) {
            var r2, i2, o2, a2, u2, c2, f2, s2 = e3.length, l2 = new Array(s2), h2 = {};
            for (i2 = 0; i2 < s2; ++i2)
              r2 = e3[i2], u2 = l2[i2] = new vl(r2), null != (c2 = t2(r2, i2, e3)) && (c2 += "") && (h2[f2 = Bl + (u2.id = c2)] = f2 in h2 ? Fl : u2);
            for (i2 = 0; i2 < s2; ++i2)
              if (u2 = l2[i2], null != (c2 = n2(e3[i2], i2, e3)) && (c2 += "")) {
                if (!(a2 = h2[Bl + c2]))
                  throw new Error("missing: " + c2);
                if (a2 === Fl)
                  throw new Error("ambiguous: " + c2);
                a2.children ? a2.children.push(u2) : a2.children = [u2], u2.parent = a2;
              } else {
                if (o2)
                  throw new Error("multiple roots");
                o2 = u2;
              }
            if (!o2)
              throw new Error("no root");
            if (o2.parent = Yl, o2.eachBefore(function(t3) {
              t3.depth = t3.parent.depth + 1, --s2;
            }).eachBefore(pl), o2.parent = null, s2 > 0)
              throw new Error("cycle");
            return o2;
          }
          return e2.id = function(n3) {
            return arguments.length ? (t2 = Cl(n3), e2) : t2;
          }, e2.parentId = function(t3) {
            return arguments.length ? (n2 = Cl(t3), e2) : n2;
          }, e2;
        }, t.tree = function() {
          var t2 = Hl, n2 = 1, e2 = 1, r2 = null;
          function i2(i3) {
            var c2 = function(t3) {
              for (var n3, e3, r3, i4, o3, a3 = new Wl(t3, 0), u3 = [a3]; n3 = u3.pop(); )
                if (r3 = n3._.children)
                  for (n3.children = new Array(o3 = r3.length), i4 = o3 - 1; i4 >= 0; --i4)
                    u3.push(e3 = n3.children[i4] = new Wl(r3[i4], i4)), e3.parent = n3;
              return (a3.parent = new Wl(null, 0)).children = [a3], a3;
            }(i3);
            if (c2.eachAfter(o2), c2.parent.m = -c2.z, c2.eachBefore(a2), r2)
              i3.eachBefore(u2);
            else {
              var f2 = i3, s2 = i3, l2 = i3;
              i3.eachBefore(function(t3) {
                t3.x < f2.x && (f2 = t3), t3.x > s2.x && (s2 = t3), t3.depth > l2.depth && (l2 = t3);
              });
              var h2 = f2 === s2 ? 1 : t2(f2, s2) / 2, d2 = h2 - f2.x, p2 = n2 / (s2.x + h2 + d2), v2 = e2 / (l2.depth || 1);
              i3.eachBefore(function(t3) {
                t3.x = (t3.x + d2) * p2, t3.y = t3.depth * v2;
              });
            }
            return i3;
          }
          function o2(n3) {
            var e3 = n3.children, r3 = n3.parent.children, i3 = n3.i ? r3[n3.i - 1] : null;
            if (e3) {
              !function(t3) {
                for (var n4, e4 = 0, r4 = 0, i4 = t3.children, o4 = i4.length; --o4 >= 0; )
                  (n4 = i4[o4]).z += e4, n4.m += e4, e4 += n4.s + (r4 += n4.c);
              }(n3);
              var o3 = (e3[0].z + e3[e3.length - 1].z) / 2;
              i3 ? (n3.z = i3.z + t2(n3._, i3._), n3.m = n3.z - o3) : n3.z = o3;
            } else
              i3 && (n3.z = i3.z + t2(n3._, i3._));
            n3.parent.A = function(n4, e4, r4) {
              if (e4) {
                for (var i4, o4 = n4, a3 = n4, u3 = e4, c2 = o4.parent.children[0], f2 = o4.m, s2 = a3.m, l2 = u3.m, h2 = c2.m; u3 = Gl(u3), o4 = Xl(o4), u3 && o4; )
                  c2 = Xl(c2), (a3 = Gl(a3)).a = n4, (i4 = u3.z + l2 - o4.z - f2 + t2(u3._, o4._)) > 0 && (Vl($l(u3, n4, r4), n4, i4), f2 += i4, s2 += i4), l2 += u3.m, f2 += o4.m, h2 += c2.m, s2 += a3.m;
                u3 && !Gl(a3) && (a3.t = u3, a3.m += l2 - s2), o4 && !Xl(c2) && (c2.t = o4, c2.m += f2 - h2, r4 = n4);
              }
              return r4;
            }(n3, i3, n3.parent.A || r3[0]);
          }
          function a2(t3) {
            t3._.x = t3.z + t3.parent.m, t3.m += t3.parent.m;
          }
          function u2(t3) {
            t3.x *= n2, t3.y = t3.depth * e2;
          }
          return i2.separation = function(n3) {
            return arguments.length ? (t2 = n3, i2) : t2;
          }, i2.size = function(t3) {
            return arguments.length ? (r2 = false, n2 = +t3[0], e2 = +t3[1], i2) : r2 ? null : [n2, e2];
          }, i2.nodeSize = function(t3) {
            return arguments.length ? (r2 = true, n2 = +t3[0], e2 = +t3[1], i2) : r2 ? [n2, e2] : null;
          }, i2;
        }, t.treemap = function() {
          var t2 = Kl, n2 = false, e2 = 1, r2 = 1, i2 = [0], o2 = Pl, a2 = Pl, u2 = Pl, c2 = Pl, f2 = Pl;
          function s2(t3) {
            return t3.x0 = t3.y0 = 0, t3.x1 = e2, t3.y1 = r2, t3.eachBefore(l2), i2 = [0], n2 && t3.eachBefore(Ul), t3;
          }
          function l2(n3) {
            var e3 = i2[n3.depth], r3 = n3.x0 + e3, s3 = n3.y0 + e3, l3 = n3.x1 - e3, h2 = n3.y1 - e3;
            l3 < r3 && (r3 = l3 = (r3 + l3) / 2), h2 < s3 && (s3 = h2 = (s3 + h2) / 2), n3.x0 = r3, n3.y0 = s3, n3.x1 = l3, n3.y1 = h2, n3.children && (e3 = i2[n3.depth + 1] = o2(n3) / 2, r3 += f2(n3) - e3, s3 += a2(n3) - e3, (l3 -= u2(n3) - e3) < r3 && (r3 = l3 = (r3 + l3) / 2), (h2 -= c2(n3) - e3) < s3 && (s3 = h2 = (s3 + h2) / 2), t2(n3, r3, s3, l3, h2));
          }
          return s2.round = function(t3) {
            return arguments.length ? (n2 = !!t3, s2) : n2;
          }, s2.size = function(t3) {
            return arguments.length ? (e2 = +t3[0], r2 = +t3[1], s2) : [e2, r2];
          }, s2.tile = function(n3) {
            return arguments.length ? (t2 = Cl(n3), s2) : t2;
          }, s2.padding = function(t3) {
            return arguments.length ? s2.paddingInner(t3).paddingOuter(t3) : s2.paddingInner();
          }, s2.paddingInner = function(t3) {
            return arguments.length ? (o2 = "function" == typeof t3 ? t3 : zl(+t3), s2) : o2;
          }, s2.paddingOuter = function(t3) {
            return arguments.length ? s2.paddingTop(t3).paddingRight(t3).paddingBottom(t3).paddingLeft(t3) : s2.paddingTop();
          }, s2.paddingTop = function(t3) {
            return arguments.length ? (a2 = "function" == typeof t3 ? t3 : zl(+t3), s2) : a2;
          }, s2.paddingRight = function(t3) {
            return arguments.length ? (u2 = "function" == typeof t3 ? t3 : zl(+t3), s2) : u2;
          }, s2.paddingBottom = function(t3) {
            return arguments.length ? (c2 = "function" == typeof t3 ? t3 : zl(+t3), s2) : c2;
          }, s2.paddingLeft = function(t3) {
            return arguments.length ? (f2 = "function" == typeof t3 ? t3 : zl(+t3), s2) : f2;
          }, s2;
        }, t.treemapBinary = function(t2, n2, e2, r2, i2) {
          var o2, a2, u2 = t2.children, c2 = u2.length, f2 = new Array(c2 + 1);
          for (f2[0] = a2 = o2 = 0; o2 < c2; ++o2)
            f2[o2 + 1] = a2 += u2[o2].value;
          !function t3(n3, e3, r3, i3, o3, a3, c3) {
            if (n3 >= e3 - 1) {
              var s2 = u2[n3];
              return s2.x0 = i3, s2.y0 = o3, s2.x1 = a3, void (s2.y1 = c3);
            }
            for (var l2 = f2[n3], h2 = r3 / 2 + l2, d2 = n3 + 1, p2 = e3 - 1; d2 < p2; ) {
              var v2 = d2 + p2 >>> 1;
              f2[v2] < h2 ? d2 = v2 + 1 : p2 = v2;
            }
            h2 - f2[d2 - 1] < f2[d2] - h2 && n3 + 1 < d2 && --d2;
            var g2 = f2[d2] - l2, y2 = r3 - g2;
            if (a3 - i3 > c3 - o3) {
              var _2 = (i3 * y2 + a3 * g2) / r3;
              t3(n3, d2, g2, i3, o3, _2, c3), t3(d2, e3, y2, _2, o3, a3, c3);
            } else {
              var b2 = (o3 * y2 + c3 * g2) / r3;
              t3(n3, d2, g2, i3, o3, a3, b2), t3(d2, e3, y2, i3, b2, a3, c3);
            }
          }(0, c2, t2.value, n2, e2, r2, i2);
        }, t.treemapDice = Ol, t.treemapSlice = Zl, t.treemapSliceDice = function(t2, n2, e2, r2, i2) {
          (1 & t2.depth ? Zl : Ol)(t2, n2, e2, r2, i2);
        }, t.treemapSquarify = Kl, t.treemapResquarify = th, t.interpolate = ye, t.interpolateArray = se, t.interpolateBasis = Kn, t.interpolateBasisClosed = te, t.interpolateDate = le, t.interpolateDiscrete = function(t2) {
          var n2 = t2.length;
          return function(e2) {
            return t2[Math.max(0, Math.min(n2 - 1, Math.floor(e2 * n2)))];
          };
        }, t.interpolateHue = function(t2, n2) {
          var e2 = re(+t2, +n2);
          return function(t3) {
            var n3 = e2(t3);
            return n3 - 360 * Math.floor(n3 / 360);
          };
        }, t.interpolateNumber = he, t.interpolateObject = de, t.interpolateRound = _e, t.interpolateString = ge, t.interpolateTransformCss = Se, t.interpolateTransformSvg = ke, t.interpolateZoom = De, t.interpolateRgb = ae, t.interpolateRgbBasis = ce, t.interpolateRgbBasisClosed = fe, t.interpolateHsl = Le, t.interpolateHslLong = Ue, t.interpolateLab = function(t2, n2) {
          var e2 = oe((t2 = Rn(t2)).l, (n2 = Rn(n2)).l), r2 = oe(t2.a, n2.a), i2 = oe(t2.b, n2.b), o2 = oe(t2.opacity, n2.opacity);
          return function(n3) {
            return t2.l = e2(n3), t2.a = r2(n3), t2.b = i2(n3), t2.opacity = o2(n3), t2 + "";
          };
        }, t.interpolateHcl = Be, t.interpolateHclLong = Ye, t.interpolateCubehelix = Ie, t.interpolateCubehelixLong = je, t.piecewise = function(t2, n2) {
          for (var e2 = 0, r2 = n2.length - 1, i2 = n2[0], o2 = new Array(r2 < 0 ? 0 : r2); e2 < r2; )
            o2[e2] = t2(i2, i2 = n2[++e2]);
          return function(t3) {
            var n3 = Math.max(0, Math.min(r2 - 1, Math.floor(t3 *= r2)));
            return o2[n3](t3 - n3);
          };
        }, t.quantize = function(t2, n2) {
          for (var e2 = new Array(n2), r2 = 0; r2 < n2; ++r2)
            e2[r2] = t2(r2 / (n2 - 1));
          return e2;
        }, t.path = Hi, t.polygonArea = function(t2) {
          for (var n2, e2 = -1, r2 = t2.length, i2 = t2[r2 - 1], o2 = 0; ++e2 < r2; )
            n2 = i2, i2 = t2[e2], o2 += n2[1] * i2[0] - n2[0] * i2[1];
          return o2 / 2;
        }, t.polygonCentroid = function(t2) {
          for (var n2, e2, r2 = -1, i2 = t2.length, o2 = 0, a2 = 0, u2 = t2[i2 - 1], c2 = 0; ++r2 < i2; )
            n2 = u2, u2 = t2[r2], c2 += e2 = n2[0] * u2[1] - u2[0] * n2[1], o2 += (n2[0] + u2[0]) * e2, a2 += (n2[1] + u2[1]) * e2;
          return [o2 / (c2 *= 3), a2 / c2];
        }, t.polygonHull = function(t2) {
          if ((e2 = t2.length) < 3)
            return null;
          var n2, e2, r2 = new Array(e2), i2 = new Array(e2);
          for (n2 = 0; n2 < e2; ++n2)
            r2[n2] = [+t2[n2][0], +t2[n2][1], n2];
          for (r2.sort(nh), n2 = 0; n2 < e2; ++n2)
            i2[n2] = [r2[n2][0], -r2[n2][1]];
          var o2 = eh(r2), a2 = eh(i2), u2 = a2[0] === o2[0], c2 = a2[a2.length - 1] === o2[o2.length - 1], f2 = [];
          for (n2 = o2.length - 1; n2 >= 0; --n2)
            f2.push(t2[r2[o2[n2]][2]]);
          for (n2 = +u2; n2 < a2.length - c2; ++n2)
            f2.push(t2[r2[a2[n2]][2]]);
          return f2;
        }, t.polygonContains = function(t2, n2) {
          for (var e2, r2, i2 = t2.length, o2 = t2[i2 - 1], a2 = n2[0], u2 = n2[1], c2 = o2[0], f2 = o2[1], s2 = false, l2 = 0; l2 < i2; ++l2)
            e2 = (o2 = t2[l2])[0], (r2 = o2[1]) > u2 != f2 > u2 && a2 < (c2 - e2) * (u2 - r2) / (f2 - r2) + e2 && (s2 = !s2), c2 = e2, f2 = r2;
          return s2;
        }, t.polygonLength = function(t2) {
          for (var n2, e2, r2 = -1, i2 = t2.length, o2 = t2[i2 - 1], a2 = o2[0], u2 = o2[1], c2 = 0; ++r2 < i2; )
            n2 = a2, e2 = u2, n2 -= a2 = (o2 = t2[r2])[0], e2 -= u2 = o2[1], c2 += Math.sqrt(n2 * n2 + e2 * e2);
          return c2;
        }, t.quadtree = aa, t.randomUniform = ih, t.randomNormal = oh, t.randomLogNormal = ah, t.randomBates = ch, t.randomIrwinHall = uh, t.randomExponential = fh, t.scaleBand = yh, t.scalePoint = function() {
          return function t2(n2) {
            var e2 = n2.copy;
            return n2.padding = n2.paddingOuter, delete n2.paddingInner, delete n2.paddingOuter, n2.copy = function() {
              return t2(e2());
            }, n2;
          }(yh.apply(null, arguments).paddingInner(1));
        }, t.scaleIdentity = function t2(n2) {
          var e2;
          function r2(t3) {
            return isNaN(t3 = +t3) ? e2 : t3;
          }
          return r2.invert = r2, r2.domain = r2.range = function(t3) {
            return arguments.length ? (n2 = dh.call(t3, _h), r2) : n2.slice();
          }, r2.unknown = function(t3) {
            return arguments.length ? (e2 = t3, r2) : e2;
          }, r2.copy = function() {
            return t2(n2).unknown(e2);
          }, n2 = arguments.length ? dh.call(n2, _h) : [0, 1], Eh(r2);
        }, t.scaleLinear = function t2() {
          var n2 = Sh(mh, mh);
          return n2.copy = function() {
            return Ah(n2, t2());
          }, sh.apply(n2, arguments), Eh(n2);
        }, t.scaleLog = function t2() {
          var n2 = Uh(Th()).domain([1, 10]);
          return n2.copy = function() {
            return Ah(n2, t2()).base(n2.base());
          }, sh.apply(n2, arguments), n2;
        }, t.scaleSymlog = function t2() {
          var n2 = Yh(Th());
          return n2.copy = function() {
            return Ah(n2, t2()).constant(n2.constant());
          }, sh.apply(n2, arguments);
        }, t.scaleOrdinal = gh, t.scaleImplicit = vh, t.scalePow = Xh, t.scaleSqrt = function() {
          return Xh.apply(null, arguments).exponent(0.5);
        }, t.scaleQuantile = function t2() {
          var e2, r2 = [], o2 = [], a2 = [];
          function u2() {
            var t3 = 0, n2 = Math.max(1, o2.length);
            for (a2 = new Array(n2 - 1); ++t3 < n2; )
              a2[t3 - 1] = N(r2, t3 / n2);
            return c2;
          }
          function c2(t3) {
            return isNaN(t3 = +t3) ? e2 : o2[i(a2, t3)];
          }
          return c2.invertExtent = function(t3) {
            var n2 = o2.indexOf(t3);
            return n2 < 0 ? [NaN, NaN] : [n2 > 0 ? a2[n2 - 1] : r2[0], n2 < a2.length ? a2[n2] : r2[r2.length - 1]];
          }, c2.domain = function(t3) {
            if (!arguments.length)
              return r2.slice();
            r2 = [];
            for (var e3, i2 = 0, o3 = t3.length; i2 < o3; ++i2)
              null == (e3 = t3[i2]) || isNaN(e3 = +e3) || r2.push(e3);
            return r2.sort(n), u2();
          }, c2.range = function(t3) {
            return arguments.length ? (o2 = ph.call(t3), u2()) : o2.slice();
          }, c2.unknown = function(t3) {
            return arguments.length ? (e2 = t3, c2) : e2;
          }, c2.quantiles = function() {
            return a2.slice();
          }, c2.copy = function() {
            return t2().domain(r2).range(o2).unknown(e2);
          }, sh.apply(c2, arguments);
        }, t.scaleQuantize = function t2() {
          var n2, e2 = 0, r2 = 1, o2 = 1, a2 = [0.5], u2 = [0, 1];
          function c2(t3) {
            return t3 <= t3 ? u2[i(a2, t3, 0, o2)] : n2;
          }
          function f2() {
            var t3 = -1;
            for (a2 = new Array(o2); ++t3 < o2; )
              a2[t3] = ((t3 + 1) * r2 - (t3 - o2) * e2) / (o2 + 1);
            return c2;
          }
          return c2.domain = function(t3) {
            return arguments.length ? (e2 = +t3[0], r2 = +t3[1], f2()) : [e2, r2];
          }, c2.range = function(t3) {
            return arguments.length ? (o2 = (u2 = ph.call(t3)).length - 1, f2()) : u2.slice();
          }, c2.invertExtent = function(t3) {
            var n3 = u2.indexOf(t3);
            return n3 < 0 ? [NaN, NaN] : n3 < 1 ? [e2, a2[0]] : n3 >= o2 ? [a2[o2 - 1], r2] : [a2[n3 - 1], a2[n3]];
          }, c2.unknown = function(t3) {
            return arguments.length ? (n2 = t3, c2) : c2;
          }, c2.thresholds = function() {
            return a2.slice();
          }, c2.copy = function() {
            return t2().domain([e2, r2]).range(u2).unknown(n2);
          }, sh.apply(Eh(c2), arguments);
        }, t.scaleThreshold = function t2() {
          var n2, e2 = [0.5], r2 = [0, 1], o2 = 1;
          function a2(t3) {
            return t3 <= t3 ? r2[i(e2, t3, 0, o2)] : n2;
          }
          return a2.domain = function(t3) {
            return arguments.length ? (e2 = ph.call(t3), o2 = Math.min(e2.length, r2.length - 1), a2) : e2.slice();
          }, a2.range = function(t3) {
            return arguments.length ? (r2 = ph.call(t3), o2 = Math.min(e2.length, r2.length - 1), a2) : r2.slice();
          }, a2.invertExtent = function(t3) {
            var n3 = r2.indexOf(t3);
            return [e2[n3 - 1], e2[n3]];
          }, a2.unknown = function(t3) {
            return arguments.length ? (n2 = t3, a2) : n2;
          }, a2.copy = function() {
            return t2().domain(e2).range(r2).unknown(n2);
          }, sh.apply(a2, arguments);
        }, t.scaleTime = function() {
          return sh.apply(Nv(Nd, wd, cd, od, rd, nd, Kh, Wh, t.timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
        }, t.scaleUtc = function() {
          return sh.apply(Nv(Wd, Vd, Rd, Cd, kd, Td, Kh, Wh, t.utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
        }, t.scaleSequential = function t2() {
          var n2 = Eh(Av()(mh));
          return n2.copy = function() {
            return Tv(n2, t2());
          }, lh.apply(n2, arguments);
        }, t.scaleSequentialLog = function t2() {
          var n2 = Uh(Av()).domain([1, 10]);
          return n2.copy = function() {
            return Tv(n2, t2()).base(n2.base());
          }, lh.apply(n2, arguments);
        }, t.scaleSequentialPow = Sv, t.scaleSequentialSqrt = function() {
          return Sv.apply(null, arguments).exponent(0.5);
        }, t.scaleSequentialSymlog = function t2() {
          var n2 = Yh(Av());
          return n2.copy = function() {
            return Tv(n2, t2()).constant(n2.constant());
          }, lh.apply(n2, arguments);
        }, t.scaleSequentialQuantile = function t2() {
          var e2 = [], r2 = mh;
          function o2(t3) {
            if (!isNaN(t3 = +t3))
              return r2((i(e2, t3) - 1) / (e2.length - 1));
          }
          return o2.domain = function(t3) {
            if (!arguments.length)
              return e2.slice();
            e2 = [];
            for (var r3, i2 = 0, a2 = t3.length; i2 < a2; ++i2)
              null == (r3 = t3[i2]) || isNaN(r3 = +r3) || e2.push(r3);
            return e2.sort(n), o2;
          }, o2.interpolator = function(t3) {
            return arguments.length ? (r2 = t3, o2) : r2;
          }, o2.copy = function() {
            return t2(r2).domain(e2);
          }, lh.apply(o2, arguments);
        }, t.scaleDiverging = function t2() {
          var n2 = Eh(kv()(mh));
          return n2.copy = function() {
            return Tv(n2, t2());
          }, lh.apply(n2, arguments);
        }, t.scaleDivergingLog = function t2() {
          var n2 = Uh(kv()).domain([0.1, 1, 10]);
          return n2.copy = function() {
            return Tv(n2, t2()).base(n2.base());
          }, lh.apply(n2, arguments);
        }, t.scaleDivergingPow = Ev, t.scaleDivergingSqrt = function() {
          return Ev.apply(null, arguments).exponent(0.5);
        }, t.scaleDivergingSymlog = function t2() {
          var n2 = Yh(kv());
          return n2.copy = function() {
            return Tv(n2, t2()).constant(n2.constant());
          }, lh.apply(n2, arguments);
        }, t.tickFormat = kh, t.schemeCategory10 = Pv, t.schemeAccent = zv, t.schemeDark2 = Rv, t.schemePaired = Dv, t.schemePastel1 = qv, t.schemePastel2 = Lv, t.schemeSet1 = Uv, t.schemeSet2 = Ov, t.schemeSet3 = Bv, t.interpolateBrBG = Iv, t.schemeBrBG = Fv, t.interpolatePRGn = Hv, t.schemePRGn = jv, t.interpolatePiYG = Gv, t.schemePiYG = Xv, t.interpolatePuOr = $v, t.schemePuOr = Vv, t.interpolateRdBu = Zv, t.schemeRdBu = Wv, t.interpolateRdGy = Jv, t.schemeRdGy = Qv, t.interpolateRdYlBu = tg, t.schemeRdYlBu = Kv, t.interpolateRdYlGn = eg, t.schemeRdYlGn = ng, t.interpolateSpectral = ig, t.schemeSpectral = rg, t.interpolateBuGn = ag, t.schemeBuGn = og, t.interpolateBuPu = cg, t.schemeBuPu = ug, t.interpolateGnBu = sg, t.schemeGnBu = fg, t.interpolateOrRd = hg, t.schemeOrRd = lg, t.interpolatePuBuGn = pg, t.schemePuBuGn = dg, t.interpolatePuBu = gg, t.schemePuBu = vg, t.interpolatePuRd = _g, t.schemePuRd = yg, t.interpolateRdPu = mg, t.schemeRdPu = bg, t.interpolateYlGnBu = wg, t.schemeYlGnBu = xg, t.interpolateYlGn = Ng, t.schemeYlGn = Mg, t.interpolateYlOrBr = Tg, t.schemeYlOrBr = Ag, t.interpolateYlOrRd = kg, t.schemeYlOrRd = Sg, t.interpolateBlues = Cg, t.schemeBlues = Eg, t.interpolateGreens = zg, t.schemeGreens = Pg, t.interpolateGreys = Dg, t.schemeGreys = Rg, t.interpolatePurples = Lg, t.schemePurples = qg, t.interpolateReds = Og, t.schemeReds = Ug, t.interpolateOranges = Yg, t.schemeOranges = Bg, t.interpolateCubehelixDefault = Fg, t.interpolateRainbow = function(t2) {
          (t2 < 0 || t2 > 1) && (t2 -= Math.floor(t2));
          var n2 = Math.abs(t2 - 0.5);
          return Hg.h = 360 * t2 - 100, Hg.s = 1.5 - 1.5 * n2, Hg.l = 0.8 - 0.9 * n2, Hg + "";
        }, t.interpolateWarm = Ig, t.interpolateCool = jg, t.interpolateSinebow = function(t2) {
          var n2;
          return t2 = (0.5 - t2) * Math.PI, Xg.r = 255 * (n2 = Math.sin(t2)) * n2, Xg.g = 255 * (n2 = Math.sin(t2 + Gg)) * n2, Xg.b = 255 * (n2 = Math.sin(t2 + Vg)) * n2, Xg + "";
        }, t.interpolateViridis = Wg, t.interpolateMagma = Zg, t.interpolateInferno = Qg, t.interpolatePlasma = Jg, t.create = function(t2) {
          return zt(W(t2).call(document.documentElement));
        }, t.creator = W, t.local = Dt, t.matcher = tt, t.mouse = Ot, t.namespace = $, t.namespaces = V, t.clientPoint = Ut, t.select = zt, t.selectAll = function(t2) {
          return "string" == typeof t2 ? new Ct([document.querySelectorAll(t2)], [document.documentElement]) : new Ct([null == t2 ? [] : t2], Et);
        }, t.selection = Pt, t.selector = Q, t.selectorAll = K, t.style = ct, t.touch = Bt, t.touches = function(t2, n2) {
          null == n2 && (n2 = Lt().touches);
          for (var e2 = 0, r2 = n2 ? n2.length : 0, i2 = new Array(r2); e2 < r2; ++e2)
            i2[e2] = Ut(t2, n2[e2]);
          return i2;
        }, t.window = ut, t.customEvent = St, t.arc = function() {
          var t2 = hy, n2 = dy, e2 = Kg(0), r2 = null, i2 = py, o2 = vy, a2 = gy, u2 = null;
          function c2() {
            var c3, f2, s2, l2 = +t2.apply(this, arguments), h2 = +n2.apply(this, arguments), d2 = i2.apply(this, arguments) - fy, p2 = o2.apply(this, arguments) - fy, v2 = ty(p2 - d2), g2 = p2 > d2;
            if (u2 || (u2 = c3 = Hi()), h2 < l2 && (f2 = h2, h2 = l2, l2 = f2), h2 > uy)
              if (v2 > sy - uy)
                u2.moveTo(h2 * ey(d2), h2 * oy(d2)), u2.arc(0, 0, h2, d2, p2, !g2), l2 > uy && (u2.moveTo(l2 * ey(p2), l2 * oy(p2)), u2.arc(0, 0, l2, p2, d2, g2));
              else {
                var y2, _2, b2 = d2, m2 = p2, x2 = d2, w2 = p2, M2 = v2, N2 = v2, A2 = a2.apply(this, arguments) / 2, T2 = A2 > uy && (r2 ? +r2.apply(this, arguments) : ay(l2 * l2 + h2 * h2)), S2 = iy(ty(h2 - l2) / 2, +e2.apply(this, arguments)), k2 = S2, E2 = S2;
                if (T2 > uy) {
                  var C2 = ly(T2 / l2 * oy(A2)), P2 = ly(T2 / h2 * oy(A2));
                  (M2 -= 2 * C2) > uy ? (x2 += C2 *= g2 ? 1 : -1, w2 -= C2) : (M2 = 0, x2 = w2 = (d2 + p2) / 2), (N2 -= 2 * P2) > uy ? (b2 += P2 *= g2 ? 1 : -1, m2 -= P2) : (N2 = 0, b2 = m2 = (d2 + p2) / 2);
                }
                var z2 = h2 * ey(b2), R2 = h2 * oy(b2), D2 = l2 * ey(w2), q2 = l2 * oy(w2);
                if (S2 > uy) {
                  var L2, U2 = h2 * ey(m2), O2 = h2 * oy(m2), B2 = l2 * ey(x2), Y2 = l2 * oy(x2);
                  if (v2 < cy && (L2 = function(t3, n3, e3, r3, i3, o3, a3, u3) {
                    var c4 = e3 - t3, f3 = r3 - n3, s3 = a3 - i3, l3 = u3 - o3, h3 = l3 * c4 - s3 * f3;
                    if (!(h3 * h3 < uy))
                      return [t3 + (h3 = (s3 * (n3 - o3) - l3 * (t3 - i3)) / h3) * c4, n3 + h3 * f3];
                  }(z2, R2, B2, Y2, U2, O2, D2, q2))) {
                    var F2 = z2 - L2[0], I2 = R2 - L2[1], j2 = U2 - L2[0], H2 = O2 - L2[1], X2 = 1 / oy(((s2 = (F2 * j2 + I2 * H2) / (ay(F2 * F2 + I2 * I2) * ay(j2 * j2 + H2 * H2))) > 1 ? 0 : s2 < -1 ? cy : Math.acos(s2)) / 2), G2 = ay(L2[0] * L2[0] + L2[1] * L2[1]);
                    k2 = iy(S2, (l2 - G2) / (X2 - 1)), E2 = iy(S2, (h2 - G2) / (X2 + 1));
                  }
                }
                N2 > uy ? E2 > uy ? (y2 = yy(B2, Y2, z2, R2, h2, E2, g2), _2 = yy(U2, O2, D2, q2, h2, E2, g2), u2.moveTo(y2.cx + y2.x01, y2.cy + y2.y01), E2 < S2 ? u2.arc(y2.cx, y2.cy, E2, ny(y2.y01, y2.x01), ny(_2.y01, _2.x01), !g2) : (u2.arc(y2.cx, y2.cy, E2, ny(y2.y01, y2.x01), ny(y2.y11, y2.x11), !g2), u2.arc(0, 0, h2, ny(y2.cy + y2.y11, y2.cx + y2.x11), ny(_2.cy + _2.y11, _2.cx + _2.x11), !g2), u2.arc(_2.cx, _2.cy, E2, ny(_2.y11, _2.x11), ny(_2.y01, _2.x01), !g2))) : (u2.moveTo(z2, R2), u2.arc(0, 0, h2, b2, m2, !g2)) : u2.moveTo(z2, R2), l2 > uy && M2 > uy ? k2 > uy ? (y2 = yy(D2, q2, U2, O2, l2, -k2, g2), _2 = yy(z2, R2, B2, Y2, l2, -k2, g2), u2.lineTo(y2.cx + y2.x01, y2.cy + y2.y01), k2 < S2 ? u2.arc(y2.cx, y2.cy, k2, ny(y2.y01, y2.x01), ny(_2.y01, _2.x01), !g2) : (u2.arc(y2.cx, y2.cy, k2, ny(y2.y01, y2.x01), ny(y2.y11, y2.x11), !g2), u2.arc(0, 0, l2, ny(y2.cy + y2.y11, y2.cx + y2.x11), ny(_2.cy + _2.y11, _2.cx + _2.x11), g2), u2.arc(_2.cx, _2.cy, k2, ny(_2.y11, _2.x11), ny(_2.y01, _2.x01), !g2))) : u2.arc(0, 0, l2, w2, x2, g2) : u2.lineTo(D2, q2);
              }
            else
              u2.moveTo(0, 0);
            if (u2.closePath(), c3)
              return u2 = null, c3 + "" || null;
          }
          return c2.centroid = function() {
            var e3 = (+t2.apply(this, arguments) + +n2.apply(this, arguments)) / 2, r3 = (+i2.apply(this, arguments) + +o2.apply(this, arguments)) / 2 - cy / 2;
            return [ey(r3) * e3, oy(r3) * e3];
          }, c2.innerRadius = function(n3) {
            return arguments.length ? (t2 = "function" == typeof n3 ? n3 : Kg(+n3), c2) : t2;
          }, c2.outerRadius = function(t3) {
            return arguments.length ? (n2 = "function" == typeof t3 ? t3 : Kg(+t3), c2) : n2;
          }, c2.cornerRadius = function(t3) {
            return arguments.length ? (e2 = "function" == typeof t3 ? t3 : Kg(+t3), c2) : e2;
          }, c2.padRadius = function(t3) {
            return arguments.length ? (r2 = null == t3 ? null : "function" == typeof t3 ? t3 : Kg(+t3), c2) : r2;
          }, c2.startAngle = function(t3) {
            return arguments.length ? (i2 = "function" == typeof t3 ? t3 : Kg(+t3), c2) : i2;
          }, c2.endAngle = function(t3) {
            return arguments.length ? (o2 = "function" == typeof t3 ? t3 : Kg(+t3), c2) : o2;
          }, c2.padAngle = function(t3) {
            return arguments.length ? (a2 = "function" == typeof t3 ? t3 : Kg(+t3), c2) : a2;
          }, c2.context = function(t3) {
            return arguments.length ? (u2 = null == t3 ? null : t3, c2) : u2;
          }, c2;
        }, t.area = My, t.line = wy, t.pie = function() {
          var t2 = Ay, n2 = Ny, e2 = null, r2 = Kg(0), i2 = Kg(sy), o2 = Kg(0);
          function a2(a3) {
            var u2, c2, f2, s2, l2, h2 = a3.length, d2 = 0, p2 = new Array(h2), v2 = new Array(h2), g2 = +r2.apply(this, arguments), y2 = Math.min(sy, Math.max(-sy, i2.apply(this, arguments) - g2)), _2 = Math.min(Math.abs(y2) / h2, o2.apply(this, arguments)), b2 = _2 * (y2 < 0 ? -1 : 1);
            for (u2 = 0; u2 < h2; ++u2)
              (l2 = v2[p2[u2] = u2] = +t2(a3[u2], u2, a3)) > 0 && (d2 += l2);
            for (null != n2 ? p2.sort(function(t3, e3) {
              return n2(v2[t3], v2[e3]);
            }) : null != e2 && p2.sort(function(t3, n3) {
              return e2(a3[t3], a3[n3]);
            }), u2 = 0, f2 = d2 ? (y2 - h2 * b2) / d2 : 0; u2 < h2; ++u2, g2 = s2)
              c2 = p2[u2], s2 = g2 + ((l2 = v2[c2]) > 0 ? l2 * f2 : 0) + b2, v2[c2] = { data: a3[c2], index: u2, value: l2, startAngle: g2, endAngle: s2, padAngle: _2 };
            return v2;
          }
          return a2.value = function(n3) {
            return arguments.length ? (t2 = "function" == typeof n3 ? n3 : Kg(+n3), a2) : t2;
          }, a2.sortValues = function(t3) {
            return arguments.length ? (n2 = t3, e2 = null, a2) : n2;
          }, a2.sort = function(t3) {
            return arguments.length ? (e2 = t3, n2 = null, a2) : e2;
          }, a2.startAngle = function(t3) {
            return arguments.length ? (r2 = "function" == typeof t3 ? t3 : Kg(+t3), a2) : r2;
          }, a2.endAngle = function(t3) {
            return arguments.length ? (i2 = "function" == typeof t3 ? t3 : Kg(+t3), a2) : i2;
          }, a2.padAngle = function(t3) {
            return arguments.length ? (o2 = "function" == typeof t3 ? t3 : Kg(+t3), a2) : o2;
          }, a2;
        }, t.areaRadial = Py, t.radialArea = Py, t.lineRadial = Cy, t.radialLine = Cy, t.pointRadial = zy, t.linkHorizontal = function() {
          return Ly(Uy);
        }, t.linkVertical = function() {
          return Ly(Oy);
        }, t.linkRadial = function() {
          var t2 = Ly(By);
          return t2.angle = t2.x, delete t2.x, t2.radius = t2.y, delete t2.y, t2;
        }, t.symbol = function() {
          var t2 = Kg(Yy), n2 = Kg(64), e2 = null;
          function r2() {
            var r3;
            if (e2 || (e2 = r3 = Hi()), t2.apply(this, arguments).draw(e2, +n2.apply(this, arguments)), r3)
              return e2 = null, r3 + "" || null;
          }
          return r2.type = function(n3) {
            return arguments.length ? (t2 = "function" == typeof n3 ? n3 : Kg(n3), r2) : t2;
          }, r2.size = function(t3) {
            return arguments.length ? (n2 = "function" == typeof t3 ? t3 : Kg(+t3), r2) : n2;
          }, r2.context = function(t3) {
            return arguments.length ? (e2 = null == t3 ? null : t3, r2) : e2;
          }, r2;
        }, t.symbols = e_, t.symbolCircle = Yy, t.symbolCross = Fy, t.symbolDiamond = Hy, t.symbolSquare = Wy, t.symbolStar = $y, t.symbolTriangle = Qy, t.symbolWye = n_, t.curveBasisClosed = function(t2) {
          return new a_(t2);
        }, t.curveBasisOpen = function(t2) {
          return new u_(t2);
        }, t.curveBasis = function(t2) {
          return new o_(t2);
        }, t.curveBundle = f_, t.curveCardinalClosed = p_, t.curveCardinalOpen = g_, t.curveCardinal = h_, t.curveCatmullRomClosed = x_, t.curveCatmullRomOpen = M_, t.curveCatmullRom = b_, t.curveLinearClosed = function(t2) {
          return new N_(t2);
        }, t.curveLinear = by, t.curveMonotoneX = function(t2) {
          return new E_(t2);
        }, t.curveMonotoneY = function(t2) {
          return new C_(t2);
        }, t.curveNatural = function(t2) {
          return new z_(t2);
        }, t.curveStep = function(t2) {
          return new D_(t2, 0.5);
        }, t.curveStepAfter = function(t2) {
          return new D_(t2, 1);
        }, t.curveStepBefore = function(t2) {
          return new D_(t2, 0);
        }, t.stack = function() {
          var t2 = Kg([]), n2 = L_, e2 = q_, r2 = U_;
          function i2(i3) {
            var o2, a2, u2 = t2.apply(this, arguments), c2 = i3.length, f2 = u2.length, s2 = new Array(f2);
            for (o2 = 0; o2 < f2; ++o2) {
              for (var l2, h2 = u2[o2], d2 = s2[o2] = new Array(c2), p2 = 0; p2 < c2; ++p2)
                d2[p2] = l2 = [0, +r2(i3[p2], h2, p2, i3)], l2.data = i3[p2];
              d2.key = h2;
            }
            for (o2 = 0, a2 = n2(s2); o2 < f2; ++o2)
              s2[a2[o2]].index = o2;
            return e2(s2, a2), s2;
          }
          return i2.keys = function(n3) {
            return arguments.length ? (t2 = "function" == typeof n3 ? n3 : Kg(Ry.call(n3)), i2) : t2;
          }, i2.value = function(t3) {
            return arguments.length ? (r2 = "function" == typeof t3 ? t3 : Kg(+t3), i2) : r2;
          }, i2.order = function(t3) {
            return arguments.length ? (n2 = null == t3 ? L_ : "function" == typeof t3 ? t3 : Kg(Ry.call(t3)), i2) : n2;
          }, i2.offset = function(t3) {
            return arguments.length ? (e2 = null == t3 ? q_ : t3, i2) : e2;
          }, i2;
        }, t.stackOffsetExpand = function(t2, n2) {
          if ((r2 = t2.length) > 0) {
            for (var e2, r2, i2, o2 = 0, a2 = t2[0].length; o2 < a2; ++o2) {
              for (i2 = e2 = 0; e2 < r2; ++e2)
                i2 += t2[e2][o2][1] || 0;
              if (i2)
                for (e2 = 0; e2 < r2; ++e2)
                  t2[e2][o2][1] /= i2;
            }
            q_(t2, n2);
          }
        }, t.stackOffsetDiverging = function(t2, n2) {
          if ((u2 = t2.length) > 1)
            for (var e2, r2, i2, o2, a2, u2, c2 = 0, f2 = t2[n2[0]].length; c2 < f2; ++c2)
              for (o2 = a2 = 0, e2 = 0; e2 < u2; ++e2)
                (i2 = (r2 = t2[n2[e2]][c2])[1] - r2[0]) >= 0 ? (r2[0] = o2, r2[1] = o2 += i2) : i2 < 0 ? (r2[1] = a2, r2[0] = a2 += i2) : r2[0] = o2;
        }, t.stackOffsetNone = q_, t.stackOffsetSilhouette = function(t2, n2) {
          if ((e2 = t2.length) > 0) {
            for (var e2, r2 = 0, i2 = t2[n2[0]], o2 = i2.length; r2 < o2; ++r2) {
              for (var a2 = 0, u2 = 0; a2 < e2; ++a2)
                u2 += t2[a2][r2][1] || 0;
              i2[r2][1] += i2[r2][0] = -u2 / 2;
            }
            q_(t2, n2);
          }
        }, t.stackOffsetWiggle = function(t2, n2) {
          if ((i2 = t2.length) > 0 && (r2 = (e2 = t2[n2[0]]).length) > 0) {
            for (var e2, r2, i2, o2 = 0, a2 = 1; a2 < r2; ++a2) {
              for (var u2 = 0, c2 = 0, f2 = 0; u2 < i2; ++u2) {
                for (var s2 = t2[n2[u2]], l2 = s2[a2][1] || 0, h2 = (l2 - (s2[a2 - 1][1] || 0)) / 2, d2 = 0; d2 < u2; ++d2) {
                  var p2 = t2[n2[d2]];
                  h2 += (p2[a2][1] || 0) - (p2[a2 - 1][1] || 0);
                }
                c2 += l2, f2 += h2 * l2;
              }
              e2[a2 - 1][1] += e2[a2 - 1][0] = o2, c2 && (o2 -= f2 / c2);
            }
            e2[a2 - 1][1] += e2[a2 - 1][0] = o2, q_(t2, n2);
          }
        }, t.stackOrderAppearance = O_, t.stackOrderAscending = Y_, t.stackOrderDescending = function(t2) {
          return Y_(t2).reverse();
        }, t.stackOrderInsideOut = function(t2) {
          var n2, e2, r2 = t2.length, i2 = t2.map(F_), o2 = O_(t2), a2 = 0, u2 = 0, c2 = [], f2 = [];
          for (n2 = 0; n2 < r2; ++n2)
            e2 = o2[n2], a2 < u2 ? (a2 += i2[e2], c2.push(e2)) : (u2 += i2[e2], f2.push(e2));
          return f2.reverse().concat(c2);
        }, t.stackOrderNone = L_, t.stackOrderReverse = function(t2) {
          return L_(t2).reverse();
        }, t.timeInterval = $h, t.timeMillisecond = Wh, t.timeMilliseconds = Zh, t.utcMillisecond = Wh, t.utcMilliseconds = Zh, t.timeSecond = Kh, t.timeSeconds = td, t.utcSecond = Kh, t.utcSeconds = td, t.timeMinute = nd, t.timeMinutes = ed, t.timeHour = rd, t.timeHours = id, t.timeDay = od, t.timeDays = ad, t.timeWeek = cd, t.timeWeeks = vd, t.timeSunday = cd, t.timeSundays = vd, t.timeMonday = fd, t.timeMondays = gd, t.timeTuesday = sd, t.timeTuesdays = yd, t.timeWednesday = ld, t.timeWednesdays = _d, t.timeThursday = hd, t.timeThursdays = bd, t.timeFriday = dd, t.timeFridays = md, t.timeSaturday = pd, t.timeSaturdays = xd, t.timeMonth = wd, t.timeMonths = Md, t.timeYear = Nd, t.timeYears = Ad, t.utcMinute = Td, t.utcMinutes = Sd, t.utcHour = kd, t.utcHours = Ed, t.utcDay = Cd, t.utcDays = Pd, t.utcWeek = Rd, t.utcWeeks = Yd, t.utcSunday = Rd, t.utcSundays = Yd, t.utcMonday = Dd, t.utcMondays = Fd, t.utcTuesday = qd, t.utcTuesdays = Id, t.utcWednesday = Ld, t.utcWednesdays = jd, t.utcThursday = Ud, t.utcThursdays = Hd, t.utcFriday = Od, t.utcFridays = Xd, t.utcSaturday = Bd, t.utcSaturdays = Gd, t.utcMonth = Vd, t.utcMonths = $d, t.utcYear = Wd, t.utcYears = Zd, t.timeFormatDefaultLocale = hv, t.timeFormatLocale = tp, t.isoFormat = dv, t.isoParse = pv, t.now = nr, t.timer = ir, t.timerFlush = or, t.timeout = fr, t.interval = function(t2, n2, e2) {
          var r2 = new rr(), i2 = n2;
          return null == n2 ? (r2.restart(t2, n2, e2), r2) : (n2 = +n2, e2 = null == e2 ? nr() : +e2, r2.restart(function o2(a2) {
            a2 += i2, r2.restart(o2, i2 += n2, e2), t2(a2);
          }, n2, e2), r2);
        }, t.transition = Cr, t.active = function(t2, n2) {
          var e2, r2, i2 = t2.__transition;
          if (i2) {
            for (r2 in n2 = null == n2 ? null : n2 + "", i2)
              if ((e2 = i2[r2]).state > dr && e2.name === n2)
                return new Er([[t2]], fi, n2, +r2);
          }
          return null;
        }, t.interrupt = Mr, t.voronoi = function() {
          var t2 = j_, n2 = H_, e2 = null;
          function r2(r3) {
            return new Nb(r3.map(function(e3, i2) {
              var o2 = [Math.round(t2(e3, i2, r3) / xb) * xb, Math.round(n2(e3, i2, r3) / xb) * xb];
              return o2.index = i2, o2.data = e3, o2;
            }), e2);
          }
          return r2.polygons = function(t3) {
            return r2(t3).polygons();
          }, r2.links = function(t3) {
            return r2(t3).links();
          }, r2.triangles = function(t3) {
            return r2(t3).triangles();
          }, r2.x = function(n3) {
            return arguments.length ? (t2 = "function" == typeof n3 ? n3 : I_(+n3), r2) : t2;
          }, r2.y = function(t3) {
            return arguments.length ? (n2 = "function" == typeof t3 ? t3 : I_(+t3), r2) : n2;
          }, r2.extent = function(t3) {
            return arguments.length ? (e2 = null == t3 ? null : [[+t3[0][0], +t3[0][1]], [+t3[1][0], +t3[1][1]]], r2) : e2 && [[e2[0][0], e2[0][1]], [e2[1][0], e2[1][1]]];
          }, r2.size = function(t3) {
            return arguments.length ? (e2 = null == t3 ? null : [[0, 0], [+t3[0], +t3[1]]], r2) : e2 && [e2[1][0] - e2[0][0], e2[1][1] - e2[0][1]];
          }, r2;
        }, t.zoom = function() {
          var n2, e2, r2 = zb, i2 = Rb, o2 = Ub, a2 = qb, u2 = Lb, c2 = [0, 1 / 0], f2 = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], s2 = 250, l2 = De, h2 = [], d2 = I("start", "zoom", "end"), p2 = 500, v2 = 150, g2 = 0;
          function y2(t2) {
            t2.property("__zoom", Db).on("wheel.zoom", N2).on("mousedown.zoom", A2).on("dblclick.zoom", T2).filter(u2).on("touchstart.zoom", S2).on("touchmove.zoom", k2).on("touchend.zoom touchcancel.zoom", E2).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
          }
          function _2(t2, n3) {
            return (n3 = Math.max(c2[0], Math.min(c2[1], n3))) === t2.k ? t2 : new Sb(n3, t2.x, t2.y);
          }
          function b2(t2, n3, e3) {
            var r3 = n3[0] - e3[0] * t2.k, i3 = n3[1] - e3[1] * t2.k;
            return r3 === t2.x && i3 === t2.y ? t2 : new Sb(t2.k, r3, i3);
          }
          function m2(t2) {
            return [(+t2[0][0] + +t2[1][0]) / 2, (+t2[0][1] + +t2[1][1]) / 2];
          }
          function x2(t2, n3, e3) {
            t2.on("start.zoom", function() {
              w2(this, arguments).start();
            }).on("interrupt.zoom end.zoom", function() {
              w2(this, arguments).end();
            }).tween("zoom", function() {
              var t3 = arguments, r3 = w2(this, t3), o3 = i2.apply(this, t3), a3 = e3 || m2(o3), u3 = Math.max(o3[1][0] - o3[0][0], o3[1][1] - o3[0][1]), c3 = this.__zoom, f3 = "function" == typeof n3 ? n3.apply(this, t3) : n3, s3 = l2(c3.invert(a3).concat(u3 / c3.k), f3.invert(a3).concat(u3 / f3.k));
              return function(t4) {
                if (1 === t4)
                  t4 = f3;
                else {
                  var n4 = s3(t4), e4 = u3 / n4[2];
                  t4 = new Sb(e4, a3[0] - n4[0] * e4, a3[1] - n4[1] * e4);
                }
                r3.zoom(null, t4);
              };
            });
          }
          function w2(t2, n3) {
            for (var e3, r3 = 0, i3 = h2.length; r3 < i3; ++r3)
              if ((e3 = h2[r3]).that === t2)
                return e3;
            return new M2(t2, n3);
          }
          function M2(t2, n3) {
            this.that = t2, this.args = n3, this.index = -1, this.active = 0, this.extent = i2.apply(t2, n3);
          }
          function N2() {
            if (r2.apply(this, arguments)) {
              var t2 = w2(this, arguments), n3 = this.__zoom, e3 = Math.max(c2[0], Math.min(c2[1], n3.k * Math.pow(2, a2.apply(this, arguments)))), i3 = Ot(this);
              if (t2.wheel)
                t2.mouse[0][0] === i3[0] && t2.mouse[0][1] === i3[1] || (t2.mouse[1] = n3.invert(t2.mouse[0] = i3)), window.clearTimeout(t2.wheel);
              else {
                if (n3.k === e3)
                  return;
                t2.mouse = [i3, n3.invert(i3)], Mr(this), t2.start();
              }
              Pb(), t2.wheel = window.setTimeout(function() {
                t2.wheel = null, t2.end();
              }, v2), t2.zoom("mouse", o2(b2(_2(n3, e3), t2.mouse[0], t2.mouse[1]), t2.extent, f2));
            }
          }
          function A2() {
            if (!e2 && r2.apply(this, arguments)) {
              var n3 = w2(this, arguments), i3 = zt(t.event.view).on("mousemove.zoom", function() {
                if (Pb(), !n3.moved) {
                  var e3 = t.event.clientX - u3, r3 = t.event.clientY - c3;
                  n3.moved = e3 * e3 + r3 * r3 > g2;
                }
                n3.zoom("mouse", o2(b2(n3.that.__zoom, n3.mouse[0] = Ot(n3.that), n3.mouse[1]), n3.extent, f2));
              }, true).on("mouseup.zoom", function() {
                i3.on("mousemove.zoom mouseup.zoom", null), jt(t.event.view, n3.moved), Pb(), n3.end();
              }, true), a3 = Ot(this), u3 = t.event.clientX, c3 = t.event.clientY;
              It(t.event.view), Cb(), n3.mouse = [a3, this.__zoom.invert(a3)], Mr(this), n3.start();
            }
          }
          function T2() {
            if (r2.apply(this, arguments)) {
              var n3 = this.__zoom, e3 = Ot(this), a3 = n3.invert(e3), u3 = n3.k * (t.event.shiftKey ? 0.5 : 2), c3 = o2(b2(_2(n3, u3), e3, a3), i2.apply(this, arguments), f2);
              Pb(), s2 > 0 ? zt(this).transition().duration(s2).call(x2, c3, e3) : zt(this).call(y2.transform, c3);
            }
          }
          function S2() {
            if (r2.apply(this, arguments)) {
              var e3, i3, o3, a3, u3 = w2(this, arguments), c3 = t.event.changedTouches, f3 = c3.length;
              for (Cb(), i3 = 0; i3 < f3; ++i3)
                a3 = [a3 = Bt(this, c3, (o3 = c3[i3]).identifier), this.__zoom.invert(a3), o3.identifier], u3.touch0 ? u3.touch1 || (u3.touch1 = a3) : (u3.touch0 = a3, e3 = true);
              if (n2 && (n2 = window.clearTimeout(n2), !u3.touch1))
                return u3.end(), void ((a3 = zt(this).on("dblclick.zoom")) && a3.apply(this, arguments));
              e3 && (n2 = window.setTimeout(function() {
                n2 = null;
              }, p2), Mr(this), u3.start());
            }
          }
          function k2() {
            var e3, r3, i3, a3, u3 = w2(this, arguments), c3 = t.event.changedTouches, s3 = c3.length;
            for (Pb(), n2 && (n2 = window.clearTimeout(n2)), e3 = 0; e3 < s3; ++e3)
              i3 = Bt(this, c3, (r3 = c3[e3]).identifier), u3.touch0 && u3.touch0[2] === r3.identifier ? u3.touch0[0] = i3 : u3.touch1 && u3.touch1[2] === r3.identifier && (u3.touch1[0] = i3);
            if (r3 = u3.that.__zoom, u3.touch1) {
              var l3 = u3.touch0[0], h3 = u3.touch0[1], d4 = u3.touch1[0], p3 = u3.touch1[1], v3 = (v3 = d4[0] - l3[0]) * v3 + (v3 = d4[1] - l3[1]) * v3, g3 = (g3 = p3[0] - h3[0]) * g3 + (g3 = p3[1] - h3[1]) * g3;
              r3 = _2(r3, Math.sqrt(v3 / g3)), i3 = [(l3[0] + d4[0]) / 2, (l3[1] + d4[1]) / 2], a3 = [(h3[0] + p3[0]) / 2, (h3[1] + p3[1]) / 2];
            } else {
              if (!u3.touch0)
                return;
              i3 = u3.touch0[0], a3 = u3.touch0[1];
            }
            u3.zoom("touch", o2(b2(r3, i3, a3), u3.extent, f2));
          }
          function E2() {
            var n3, r3, i3 = w2(this, arguments), o3 = t.event.changedTouches, a3 = o3.length;
            for (Cb(), e2 && window.clearTimeout(e2), e2 = window.setTimeout(function() {
              e2 = null;
            }, p2), n3 = 0; n3 < a3; ++n3)
              r3 = o3[n3], i3.touch0 && i3.touch0[2] === r3.identifier ? delete i3.touch0 : i3.touch1 && i3.touch1[2] === r3.identifier && delete i3.touch1;
            i3.touch1 && !i3.touch0 && (i3.touch0 = i3.touch1, delete i3.touch1), i3.touch0 ? i3.touch0[1] = this.__zoom.invert(i3.touch0[0]) : i3.end();
          }
          return y2.transform = function(t2, n3) {
            var e3 = t2.selection ? t2.selection() : t2;
            e3.property("__zoom", Db), t2 !== e3 ? x2(t2, n3) : e3.interrupt().each(function() {
              w2(this, arguments).start().zoom(null, "function" == typeof n3 ? n3.apply(this, arguments) : n3).end();
            });
          }, y2.scaleBy = function(t2, n3) {
            y2.scaleTo(t2, function() {
              return this.__zoom.k * ("function" == typeof n3 ? n3.apply(this, arguments) : n3);
            });
          }, y2.scaleTo = function(t2, n3) {
            y2.transform(t2, function() {
              var t3 = i2.apply(this, arguments), e3 = this.__zoom, r3 = m2(t3), a3 = e3.invert(r3), u3 = "function" == typeof n3 ? n3.apply(this, arguments) : n3;
              return o2(b2(_2(e3, u3), r3, a3), t3, f2);
            });
          }, y2.translateBy = function(t2, n3, e3) {
            y2.transform(t2, function() {
              return o2(this.__zoom.translate("function" == typeof n3 ? n3.apply(this, arguments) : n3, "function" == typeof e3 ? e3.apply(this, arguments) : e3), i2.apply(this, arguments), f2);
            });
          }, y2.translateTo = function(t2, n3, e3) {
            y2.transform(t2, function() {
              var t3 = i2.apply(this, arguments), r3 = this.__zoom, a3 = m2(t3);
              return o2(kb.translate(a3[0], a3[1]).scale(r3.k).translate("function" == typeof n3 ? -n3.apply(this, arguments) : -n3, "function" == typeof e3 ? -e3.apply(this, arguments) : -e3), t3, f2);
            });
          }, M2.prototype = { start: function() {
            return 1 == ++this.active && (this.index = h2.push(this) - 1, this.emit("start")), this;
          }, zoom: function(t2, n3) {
            return this.mouse && "mouse" !== t2 && (this.mouse[1] = n3.invert(this.mouse[0])), this.touch0 && "touch" !== t2 && (this.touch0[1] = n3.invert(this.touch0[0])), this.touch1 && "touch" !== t2 && (this.touch1[1] = n3.invert(this.touch1[0])), this.that.__zoom = n3, this.emit("zoom"), this;
          }, end: function() {
            return 0 == --this.active && (h2.splice(this.index, 1), this.index = -1, this.emit("end")), this;
          }, emit: function(t2) {
            St(new Tb(y2, t2, this.that.__zoom), d2.apply, d2, [t2, this.that, this.args]);
          } }, y2.wheelDelta = function(t2) {
            return arguments.length ? (a2 = "function" == typeof t2 ? t2 : Ab(+t2), y2) : a2;
          }, y2.filter = function(t2) {
            return arguments.length ? (r2 = "function" == typeof t2 ? t2 : Ab(!!t2), y2) : r2;
          }, y2.touchable = function(t2) {
            return arguments.length ? (u2 = "function" == typeof t2 ? t2 : Ab(!!t2), y2) : u2;
          }, y2.extent = function(t2) {
            return arguments.length ? (i2 = "function" == typeof t2 ? t2 : Ab([[+t2[0][0], +t2[0][1]], [+t2[1][0], +t2[1][1]]]), y2) : i2;
          }, y2.scaleExtent = function(t2) {
            return arguments.length ? (c2[0] = +t2[0], c2[1] = +t2[1], y2) : [c2[0], c2[1]];
          }, y2.translateExtent = function(t2) {
            return arguments.length ? (f2[0][0] = +t2[0][0], f2[1][0] = +t2[1][0], f2[0][1] = +t2[0][1], f2[1][1] = +t2[1][1], y2) : [[f2[0][0], f2[0][1]], [f2[1][0], f2[1][1]]];
          }, y2.constrain = function(t2) {
            return arguments.length ? (o2 = t2, y2) : o2;
          }, y2.duration = function(t2) {
            return arguments.length ? (s2 = +t2, y2) : s2;
          }, y2.interpolate = function(t2) {
            return arguments.length ? (l2 = t2, y2) : l2;
          }, y2.on = function() {
            var t2 = d2.on.apply(d2, arguments);
            return t2 === d2 ? y2 : t2;
          }, y2.clickDistance = function(t2) {
            return arguments.length ? (g2 = (t2 = +t2) * t2, y2) : Math.sqrt(g2);
          }, y2;
        }, t.zoomTransform = Eb, t.zoomIdentity = kb, Object.defineProperty(t, "__esModule", { value: true });
      });
    }
  });

  // node_modules/zotero-plugin-toolkit/dist/tools/ui.js
  var require_ui = __commonJS({
    "node_modules/zotero-plugin-toolkit/dist/tools/ui.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.UITool = void 0;
      var basic_1 = require_basic();
      var UITool = class extends basic_1.BasicTool {
        get basicOptions() {
          return this._basicOptions;
        }
        constructor(base) {
          super(base);
          this.elementCache = [];
          if (!this._basicOptions.ui) {
            this._basicOptions.ui = {
              enableElementRecord: true,
              enableElementJSONLog: false,
              enableElementDOMLog: true
            };
          }
        }
        /**
         * Remove all elements created by `createElement`.
         *
         * @remarks
         * > What is this for?
         *
         * In bootstrap plugins, elements must be manually maintained and removed on exiting.
         *
         * This API does this for you.
         */
        unregisterAll() {
          this.elementCache.forEach((e) => {
            var _a;
            try {
              (_a = e === null || e === void 0 ? void 0 : e.deref()) === null || _a === void 0 ? void 0 : _a.remove();
            } catch (e2) {
              this.log(e2);
            }
          });
        }
        createElement(...args) {
          var _a, _b, _c;
          const doc = args[0];
          const tagName = args[1].toLowerCase();
          let props = args[2] || {};
          if (!tagName) {
            return;
          }
          if (typeof args[2] === "string") {
            props = {
              namespace: args[2],
              enableElementRecord: args[3]
            };
          }
          if (typeof props.enableElementJSONLog !== "undefined" && props.enableElementJSONLog || this.basicOptions.ui.enableElementJSONLog) {
            this.log(props);
          }
          props.properties = props.properties || props.directAttributes;
          props.children = props.children || props.subElementOptions;
          let elem;
          if (tagName === "fragment") {
            const fragElem = doc.createDocumentFragment();
            elem = fragElem;
          } else {
            let realElem = props.id && (props.checkExistenceParent ? props.checkExistenceParent : doc).querySelector(`#${props.id}`);
            if (realElem && props.ignoreIfExists) {
              return realElem;
            }
            if (realElem && props.removeIfExists) {
              realElem.remove();
              realElem = void 0;
            }
            if (props.customCheck && !props.customCheck(doc, props)) {
              return void 0;
            }
            if (!realElem || !props.skipIfExists) {
              let namespace = props.namespace;
              if (!namespace) {
                const mightHTML = HTMLElementTagNames.includes(tagName);
                const mightXUL = XULElementTagNames.includes(tagName);
                const mightSVG = SVGElementTagNames.includes(tagName);
                if (Number(mightHTML) + Number(mightXUL) + Number(mightSVG) > 1) {
                  this.log(`[Warning] Creating element ${tagName} with no namespace specified. Found multiply namespace matches.`);
                }
                if (mightHTML) {
                  namespace = "html";
                } else if (mightXUL) {
                  namespace = "xul";
                } else if (mightSVG) {
                  namespace = "svg";
                } else {
                  namespace = "html";
                }
              }
              if (namespace === "xul") {
                realElem = this.createXULElement(doc, tagName);
              } else {
                realElem = doc.createElementNS({
                  html: "http://www.w3.org/1999/xhtml",
                  svg: "http://www.w3.org/2000/svg"
                }[namespace], tagName);
              }
              this.elementCache.push(new WeakRef(realElem));
            }
            if (props.id) {
              realElem.id = props.id;
            }
            if (props.styles && Object.keys(props.styles).length) {
              Object.keys(props.styles).forEach((k) => {
                const v = props.styles[k];
                typeof v !== "undefined" && (realElem.style[k] = v);
              });
            }
            if (props.properties && Object.keys(props.properties).length) {
              Object.keys(props.properties).forEach((k) => {
                const v = props.properties[k];
                typeof v !== "undefined" && (realElem[k] = v);
              });
            }
            if (props.attributes && Object.keys(props.attributes).length) {
              Object.keys(props.attributes).forEach((k) => {
                const v = props.attributes[k];
                typeof v !== "undefined" && realElem.setAttribute(k, String(v));
              });
            }
            if ((_a = props.classList) === null || _a === void 0 ? void 0 : _a.length) {
              realElem.classList.add(...props.classList);
            }
            if ((_b = props.listeners) === null || _b === void 0 ? void 0 : _b.length) {
              props.listeners.forEach(({ type, listener, options }) => {
                listener && realElem.addEventListener(type, listener, options);
              });
            }
            elem = realElem;
          }
          if ((_c = props.children) === null || _c === void 0 ? void 0 : _c.length) {
            const subElements = props.children.map((childProps) => {
              childProps.namespace = childProps.namespace || props.namespace;
              return this.createElement(doc, childProps.tag, childProps);
            }).filter((e) => e);
            elem.append(...subElements);
          }
          if (typeof props.enableElementDOMLog !== "undefined" && props.enableElementDOMLog || this.basicOptions.ui.enableElementDOMLog) {
            this.log(elem);
          }
          return elem;
        }
        /**
         * Append element(s) to a node.
         * @param properties See {@link ElementProps}
         * @param container The parent node to append to.
         * @returns A Node that is the appended child (aChild),
         *          except when aChild is a DocumentFragment,
         *          in which case the empty DocumentFragment is returned.
         */
        appendElement(properties, container) {
          return container.appendChild(this.createElement(container.ownerDocument, properties.tag, properties));
        }
        /**
         * Inserts a node before a reference node as a child of its parent node.
         * @param properties See {@link ElementProps}
         * @param referenceNode The node before which newNode is inserted.
         * @returns
         */
        insertElementBefore(properties, referenceNode) {
          if (referenceNode.parentNode)
            return referenceNode.parentNode.insertBefore(this.createElement(referenceNode.ownerDocument, properties.tag, properties), referenceNode);
          else
            this.log(referenceNode.tagName + " has no parent, cannot insert " + properties.tag);
        }
        /**
         * Replace oldNode with a new one.
         * @param properties See {@link ElementProps}
         * @param oldNode The child to be replaced.
         * @returns The replaced Node. This is the same node as oldChild.
         */
        replaceElement(properties, oldNode) {
          if (oldNode.parentNode)
            return oldNode.parentNode.replaceChild(this.createElement(oldNode.ownerDocument, properties.tag, properties), oldNode);
          else
            this.log(oldNode.tagName + " has no parent, cannot replace it with " + properties.tag);
        }
        /**
         * Parse XHTML to XUL fragment. For Zotero 6.
         *
         * To load preferences from a Zotero 7's `.xhtml`, use this method to parse it.
         * @param str xhtml raw text
         * @param entities dtd file list ("chrome://xxx.dtd")
         * @param defaultXUL true for default XUL namespace
         */
        parseXHTMLToFragment(str, entities = [], defaultXUL = true) {
          let parser = this.getDOMParser();
          const xulns = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
          const htmlns = "http://www.w3.org/1999/xhtml";
          const wrappedStr = `${entities.length ? `<!DOCTYPE bindings [ ${entities.reduce((preamble, url, index) => {
            return preamble + `<!ENTITY % _dtd-${index} SYSTEM "${url}"> %_dtd-${index}; `;
          }, "")}]>` : ""}
      <html:div xmlns="${defaultXUL ? xulns : htmlns}"
          xmlns:xul="${xulns}" xmlns:html="${htmlns}">
      ${str}
      </html:div>`;
          this.log(wrappedStr, parser);
          let doc = parser.parseFromString(wrappedStr, "text/xml");
          this.log(doc);
          if (doc.documentElement.localName === "parsererror") {
            throw new Error("not well-formed XHTML");
          }
          let range = doc.createRange();
          range.selectNodeContents(doc.querySelector("div"));
          return range.extractContents();
        }
      };
      exports.UITool = UITool;
      var HTMLElementTagNames = [
        "a",
        "abbr",
        "address",
        "area",
        "article",
        "aside",
        "audio",
        "b",
        "base",
        "bdi",
        "bdo",
        "blockquote",
        "body",
        "br",
        "button",
        "canvas",
        "caption",
        "cite",
        "code",
        "col",
        "colgroup",
        "data",
        "datalist",
        "dd",
        "del",
        "details",
        "dfn",
        "dialog",
        "div",
        "dl",
        "dt",
        "em",
        "embed",
        "fieldset",
        "figcaption",
        "figure",
        "footer",
        "form",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "head",
        "header",
        "hgroup",
        "hr",
        "html",
        "i",
        "iframe",
        "img",
        "input",
        "ins",
        "kbd",
        "label",
        "legend",
        "li",
        "link",
        "main",
        "map",
        "mark",
        "menu",
        "meta",
        "meter",
        "nav",
        "noscript",
        "object",
        "ol",
        "optgroup",
        "option",
        "output",
        "p",
        "picture",
        "pre",
        "progress",
        "q",
        "rp",
        "rt",
        "ruby",
        "s",
        "samp",
        "script",
        "section",
        "select",
        "slot",
        "small",
        "source",
        "span",
        "strong",
        "style",
        "sub",
        "summary",
        "sup",
        "table",
        "tbody",
        "td",
        "template",
        "textarea",
        "tfoot",
        "th",
        "thead",
        "time",
        "title",
        "tr",
        "track",
        "u",
        "ul",
        "var",
        "video",
        "wbr"
      ];
      var XULElementTagNames = [
        "action",
        "arrowscrollbox",
        "bbox",
        "binding",
        "bindings",
        "box",
        "broadcaster",
        "broadcasterset",
        "button",
        "browser",
        "checkbox",
        "caption",
        "colorpicker",
        "column",
        "columns",
        "commandset",
        "command",
        "conditions",
        "content",
        "deck",
        "description",
        "dialog",
        "dialogheader",
        "editor",
        "grid",
        "grippy",
        "groupbox",
        "hbox",
        "iframe",
        "image",
        "key",
        "keyset",
        "label",
        "listbox",
        "listcell",
        "listcol",
        "listcols",
        "listhead",
        "listheader",
        "listitem",
        "member",
        "menu",
        "menubar",
        "menuitem",
        "menulist",
        "menupopup",
        "menuseparator",
        "observes",
        "overlay",
        "page",
        "popup",
        "popupset",
        "preference",
        "preferences",
        "prefpane",
        "prefwindow",
        "progressmeter",
        "radio",
        "radiogroup",
        "resizer",
        "richlistbox",
        "richlistitem",
        "row",
        "rows",
        "rule",
        "script",
        "scrollbar",
        "scrollbox",
        "scrollcorner",
        "separator",
        "spacer",
        "splitter",
        "stack",
        "statusbar",
        "statusbarpanel",
        "stringbundle",
        "stringbundleset",
        "tab",
        "tabbrowser",
        "tabbox",
        "tabpanel",
        "tabpanels",
        "tabs",
        "template",
        "textnode",
        "textbox",
        "titlebar",
        "toolbar",
        "toolbarbutton",
        "toolbargrippy",
        "toolbaritem",
        "toolbarpalette",
        "toolbarseparator",
        "toolbarset",
        "toolbarspacer",
        "toolbarspring",
        "toolbox",
        "tooltip",
        "tree",
        "treecell",
        "treechildren",
        "treecol",
        "treecols",
        "treeitem",
        "treerow",
        "treeseparator",
        "triple",
        "vbox",
        "window",
        "wizard",
        "wizardpage"
      ];
      var SVGElementTagNames = [
        "a",
        "animate",
        "animateMotion",
        "animateTransform",
        "circle",
        "clipPath",
        "defs",
        "desc",
        "ellipse",
        "feBlend",
        "feColorMatrix",
        "feComponentTransfer",
        "feComposite",
        "feConvolveMatrix",
        "feDiffuseLighting",
        "feDisplacementMap",
        "feDistantLight",
        "feDropShadow",
        "feFlood",
        "feFuncA",
        "feFuncB",
        "feFuncG",
        "feFuncR",
        "feGaussianBlur",
        "feImage",
        "feMerge",
        "feMergeNode",
        "feMorphology",
        "feOffset",
        "fePointLight",
        "feSpecularLighting",
        "feSpotLight",
        "feTile",
        "feTurbulence",
        "filter",
        "foreignObject",
        "g",
        "image",
        "line",
        "linearGradient",
        "marker",
        "mask",
        "metadata",
        "mpath",
        "path",
        "pattern",
        "polygon",
        "polyline",
        "radialGradient",
        "rect",
        "script",
        "set",
        "stop",
        "style",
        "svg",
        "switch",
        "symbol",
        "text",
        "textPath",
        "title",
        "tspan",
        "use",
        "view"
      ];
    }
  });

  // node_modules/zotero-plugin-toolkit/dist/utils/wait.js
  var require_wait = __commonJS({
    "node_modules/zotero-plugin-toolkit/dist/utils/wait.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.waitUtilAsync = exports.waitUntil = void 0;
      var basic_1 = require_basic();
      var basicTool2 = new basic_1.BasicTool();
      function waitUntil(condition, callback, interval = 100, timeout = 1e4) {
        const start = Date.now();
        const intervalId = basicTool2.getGlobal("setInterval")(() => {
          if (condition()) {
            basicTool2.getGlobal("clearInterval")(intervalId);
            callback();
          } else if (Date.now() - start > timeout) {
            basicTool2.getGlobal("clearInterval")(intervalId);
          }
        }, interval);
      }
      exports.waitUntil = waitUntil;
      function waitUtilAsync(condition, interval = 100, timeout = 1e4) {
        return new Promise((resolve, reject) => {
          const start = Date.now();
          const intervalId = basicTool2.getGlobal("setInterval")(() => {
            if (condition()) {
              basicTool2.getGlobal("clearInterval")(intervalId);
              resolve();
            } else if (Date.now() - start > timeout) {
              basicTool2.getGlobal("clearInterval")(intervalId);
              reject();
            }
          }, interval);
        });
      }
      exports.waitUtilAsync = waitUtilAsync;
    }
  });

  // node_modules/zotero-plugin-toolkit/dist/tools/reader.js
  var require_reader = __commonJS({
    "node_modules/zotero-plugin-toolkit/dist/tools/reader.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ReaderTool = void 0;
      var basic_1 = require_basic();
      var wait_1 = require_wait();
      var ReaderTool = class extends basic_1.BasicTool {
        /**
         * Get the selected tab reader.
         * @param waitTime Wait for n MS until the reader is ready
         */
        async getReader(waitTime = 5e3) {
          const Zotero_Tabs2 = this.getGlobal("Zotero_Tabs");
          if (Zotero_Tabs2.selectedType !== "reader") {
            return void 0;
          }
          let reader = Zotero.Reader.getByTabID(Zotero_Tabs2.selectedID);
          let delayCount = 0;
          const checkPeriod = 50;
          while (!reader && delayCount * checkPeriod < waitTime) {
            await Zotero.Promise.delay(checkPeriod);
            reader = Zotero.Reader.getByTabID(Zotero_Tabs2.selectedID);
            delayCount++;
          }
          await (reader === null || reader === void 0 ? void 0 : reader._initPromise);
          return reader;
        }
        /**
         * Get all window readers.
         */
        getWindowReader() {
          const Zotero_Tabs2 = this.getGlobal("Zotero_Tabs");
          let windowReaders = [];
          let tabs = Zotero_Tabs2._tabs.map((e) => e.id);
          for (let i = 0; i < Zotero.Reader._readers.length; i++) {
            let flag = false;
            for (let j = 0; j < tabs.length; j++) {
              if (Zotero.Reader._readers[i].tabID == tabs[j]) {
                flag = true;
                break;
              }
            }
            if (!flag) {
              windowReaders.push(Zotero.Reader._readers[i]);
            }
          }
          return windowReaders;
        }
        /**
         * Get Reader tabpanel deck element.
         * @alpha
         */
        getReaderTabPanelDeck() {
          var _a;
          const deck = (_a = this.getGlobal("window").document.querySelector(".notes-pane-deck")) === null || _a === void 0 ? void 0 : _a.previousElementSibling;
          return deck;
        }
        /**
         * Add a reader tabpanel deck selection change observer.
         * @alpha
         * @param callback
         */
        async addReaderTabPanelDeckObserver(callback) {
          await (0, wait_1.waitUtilAsync)(() => !!this.getReaderTabPanelDeck());
          const deck = this.getReaderTabPanelDeck();
          const observer = new (this.getGlobal("MutationObserver"))(async (mutations) => {
            mutations.forEach(async (mutation) => {
              const target = mutation.target;
              if (target.classList.contains("zotero-view-tabbox") || target.tagName === "deck") {
                callback();
              }
            });
          });
          observer.observe(deck, {
            attributes: true,
            attributeFilter: ["selectedIndex"],
            subtree: true
          });
          return observer;
        }
        /**
         * Get the text selection of reader.
         * @param currentReader Target reader
         */
        getSelectedText(currentReader) {
          var _a, _b, _c;
          if (!currentReader) {
            return "";
          }
          if (this.isZotero7()) {
            if (currentReader._internalReader._type === "pdf") {
              const selectionRanges = (
                // @ts-ignore
                currentReader._internalReader._lastView._selectionRanges
              );
              return (
                // @ts-ignore
                ((_a = currentReader._internalReader._lastView._getAnnotationFromSelectionRanges(selectionRanges, "highlight")) === null || _a === void 0 ? void 0 : _a.text) || ""
              );
            }
            return (
              // @ts-ignore
              ((_b = currentReader._internalReader._lastView._getAnnotationFromTextSelection("highlight")) === null || _b === void 0 ? void 0 : _b.text) || ""
            );
          } else {
            let textArea = (_c = currentReader._iframeWindow) === null || _c === void 0 ? void 0 : _c.document.querySelectorAll("textarea");
            if (!textArea) {
              return "";
            }
            for (let i = 0; i < textArea.length; i++) {
              if (textArea[i].style.zIndex === "-1" && textArea[i].style["width"] === "0px") {
                return textArea[i].value.replace(/(^\s*)|(\s*$)/g, "");
              }
            }
            return "";
          }
        }
      };
      exports.ReaderTool = ReaderTool;
    }
  });

  // node_modules/zotero-plugin-toolkit/dist/tools/extraField.js
  var require_extraField = __commonJS({
    "node_modules/zotero-plugin-toolkit/dist/tools/extraField.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ExtraFieldTool = void 0;
      var basic_1 = require_basic();
      var ExtraFieldTool = class extends basic_1.BasicTool {
        /**
         * Get all extra fields
         * @param item
         */
        getExtraFields(item, backend = "custom") {
          const extraFiledRaw = item.getField("extra");
          if (backend === "default") {
            return this.getGlobal("Zotero").Utilities.Internal.extractExtraFields(extraFiledRaw).fields;
          } else {
            const map = /* @__PURE__ */ new Map();
            const nonStandardFields = [];
            extraFiledRaw.split("\n").forEach((line) => {
              const split = line.split(": ");
              if (split.length >= 2 && split[0]) {
                map.set(split[0], split.slice(1).join(": "));
              } else {
                nonStandardFields.push(line);
              }
            });
            map.set("__nonStandard__", nonStandardFields.join("\n"));
            return map;
          }
        }
        /**
         * Get extra field value by key. If it does not exists, return undefined.
         * @param item
         * @param key
         */
        getExtraField(item, key) {
          const fields = this.getExtraFields(item);
          return fields.get(key);
        }
        /**
         * Replace extra field of an item.
         * @param item
         * @param fields
         */
        async replaceExtraFields(item, fields) {
          let kvs = [];
          if (fields.has("__nonStandard__")) {
            kvs.push(fields.get("__nonStandard__"));
            fields.delete("__nonStandard__");
          }
          fields.forEach((v, k) => {
            kvs.push(`${k}: ${v}`);
          });
          item.setField("extra", kvs.join("\n"));
          await item.saveTx();
        }
        /**
         * Set an key-value pair to the item's extra field
         * @param item
         * @param key
         * @param value
         */
        async setExtraField(item, key, value) {
          const fields = this.getExtraFields(item);
          if (value === "" || typeof value === "undefined") {
            fields.delete(key);
          } else {
            fields.set(key, value);
          }
          await this.replaceExtraFields(item, fields);
        }
      };
      exports.ExtraFieldTool = ExtraFieldTool;
    }
  });

  // node_modules/zotero-plugin-toolkit/dist/managers/patch.js
  var require_patch = __commonJS({
    "node_modules/zotero-plugin-toolkit/dist/managers/patch.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PatcherManager = void 0;
      var basic_1 = require_basic();
      var PatcherManager = class extends basic_1.ManagerTool {
        constructor(base) {
          super(base);
          this.patcherIDMap = /* @__PURE__ */ new Map();
        }
        /**
         * Patch a function
         * @param object The owner of the function
         * @param funcSign The signature of the function(function name)
         * @param patcher A function that returns the new wrapper of the patched function
         * @returns A unique ID of the patcher, which can be used to unregister the patcher
         */
        register(object, funcSign, patcher) {
          const Zotero2 = this.getGlobal("Zotero");
          const patchIDMap = this.patcherIDMap;
          let id = Zotero2.randomString();
          while (patchIDMap.has(id)) {
            id = Zotero2.randomString();
          }
          const origin = object[funcSign];
          patchIDMap.set(id, true);
          this.log("patching ", funcSign);
          object[funcSign] = function(...args) {
            if (patchIDMap.get(id))
              try {
                return patcher(origin).apply(this, args);
              } catch (e) {
                Zotero2.logError(e);
              }
            return origin.apply(this, args);
          };
          return id;
        }
        /**
         * Unregister a patcher
         * @param patcherID The ID of the patcher to be unregistered
         */
        unregister(patcherID) {
          this.patcherIDMap.delete(patcherID);
        }
        /**
         * Unregister all patchers
         */
        unregisterAll() {
          this.patcherIDMap.clear();
        }
      };
      exports.PatcherManager = PatcherManager;
    }
  });

  // node_modules/zotero-plugin-toolkit/dist/managers/fieldHook.js
  var require_fieldHook = __commonJS({
    "node_modules/zotero-plugin-toolkit/dist/managers/fieldHook.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FieldHookManager = void 0;
      var basic_1 = require_basic();
      var patch_1 = require_patch();
      var toolkitGlobal_1 = __importDefault(require_toolkitGlobal());
      var FieldHookManager = class extends basic_1.ManagerTool {
        constructor(base) {
          super(base);
          this.patcherManager = new patch_1.PatcherManager();
          this.localCache = [];
          this.initializeGlobal();
        }
        register(type, field, hook) {
          let hooks = this.getHooksFactory(type);
          if (!hooks) {
            return;
          }
          if (field in hooks) {
            this.log(`[WARNING] ${type}.${field} overwrites an existing hook.`);
          }
          hooks[field] = hook;
          this.localCache.push({ type, field });
        }
        unregister(type, field) {
          let hooks = this.getHooksFactory(type);
          if (hooks) {
            delete hooks[field];
          }
          const idx = this.localCache.findIndex(({ type: cacheType }) => cacheType === type);
          if (idx > -1) {
            this.localCache.splice(idx, 1);
          }
        }
        unregisterAll() {
          [...this.localCache].forEach((cache) => {
            this.unregister(cache.type, cache.field);
          });
        }
        getHooksFactory(type) {
          switch (type) {
            case "getField":
              const globalItemTree = toolkitGlobal_1.default.getInstance().itemTree;
              const deprecatedHooks = globalItemTree.fieldHooks;
              if (deprecatedHooks && deprecatedHooks !== this.globalCache.getFieldHooks) {
                Object.assign(this.globalCache.getFieldHooks, deprecatedHooks);
                globalItemTree.fieldHooks = this.globalCache.getFieldHooks;
              }
              return this.globalCache.getFieldHooks;
              break;
            case "setField":
              return this.globalCache.setFieldHooks;
              break;
            case "isFieldOfBase":
              return this.globalCache.isFieldOfBaseHooks;
              break;
            default:
              break;
          }
        }
        initializeGlobal() {
          const Zotero2 = this.getGlobal("Zotero");
          const globalCache = this.globalCache = toolkitGlobal_1.default.getInstance().fieldHooks;
          if (!this.globalCache._ready) {
            this.globalCache._ready = true;
            this.patcherManager.register(Zotero2.Item.prototype, "getField", (original) => function(field, unformatted, includeBaseMapped) {
              const originalThis = this;
              if (Object.keys(globalCache.getFieldHooks).includes(field)) {
                try {
                  const hook = globalCache.getFieldHooks[field];
                  return hook(field, unformatted, includeBaseMapped, originalThis, original.bind(originalThis));
                } catch (e) {
                  return field + String(e);
                }
              }
              return original.apply(originalThis, arguments);
            });
            this.patcherManager.register(Zotero2.Item.prototype, "setField", (original) => function(field, value, loadIn) {
              const originalThis = this;
              if (Object.keys(globalCache.setFieldHooks).includes(field)) {
                try {
                  const hook = globalCache.setFieldHooks[field];
                  return hook(field, value, loadIn, originalThis, original.bind(originalThis));
                } catch (e) {
                  return field + String(e);
                }
              }
              return original.apply(originalThis, arguments);
            });
            this.patcherManager.register(Zotero2.ItemFields, "isFieldOfBase", (original) => function(field, baseField) {
              const originalThis = this;
              if (Object.keys(globalCache.isFieldOfBaseHooks).includes(field)) {
                try {
                  const hook = globalCache.isFieldOfBaseHooks[field];
                  return hook(field, baseField, original.bind(originalThis));
                } catch (e) {
                  return false;
                }
              }
              return original.apply(originalThis, arguments);
            });
          }
        }
      };
      exports.FieldHookManager = FieldHookManager;
    }
  });

  // node_modules/zotero-plugin-toolkit/dist/managers/itemTree.js
  var require_itemTree = __commonJS({
    "node_modules/zotero-plugin-toolkit/dist/managers/itemTree.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ItemTreeManager = void 0;
      var basic_1 = require_basic();
      var fieldHook_1 = require_fieldHook();
      var toolkitGlobal_1 = __importDefault(require_toolkitGlobal());
      var patch_1 = require_patch();
      var ItemTreeManager = class extends basic_1.ManagerTool {
        /**
         * Initialize Zotero._ItemTreeExtraColumnsGlobal if it doesn't exist.
         *
         * New columns and hooks are stored there.
         *
         * Then patch `require("zotero/itemTree").getColumns` and `Zotero.Item.getField`
         */
        constructor(base) {
          super(base);
          this.defaultPersist = [
            "width",
            "ordinal",
            "hidden",
            "sortActive",
            "sortDirection"
          ];
          this.backend = this.getGlobal("Zotero").ItemTreeManager;
          this.localColumnCache = [];
          this.localRenderCellCache = [];
          this.fieldHooks = new fieldHook_1.FieldHookManager(base);
          this.patcherManager = new patch_1.PatcherManager(base);
          this.initializationLock = this.getGlobal("Zotero").Promise.defer();
          if (!this.backend) {
            this.initializeGlobal();
          } else {
            this.initializationLock.resolve();
          }
        }
        unregisterAll() {
          [...this.localColumnCache].forEach((key) => this.unregister(key, { skipGetField: true }));
          [...this.localRenderCellCache].forEach(this.removeRenderCellHook.bind(this));
          this.fieldHooks.unregisterAll();
        }
        /**
         * Register a new column. Don't forget to call `unregister` on plugin exit.
         * @param key Column dataKey
         * @param label Column display label
         * @param getFieldHook Called when loading cell content.
         * If you registered the getField hook somewhere else (in ItemBox or FieldHooks), leave it undefined.
         * @param options See zotero source code:chrome/content/zotero/itemTreeColumns.jsx
         * @param options.renderCellHook Called when rendering cell. This will override
         *
         * @example
         * ```ts
         * const itemTree = new ItemTreeTool();
         * await itemTree.register(
         *   "test",
         *   "new column",
         *   (
         *     field: string,
         *     unformatted: boolean,
         *     includeBaseMapped: boolean,
         *     item: Zotero.Item
         *   ) => {
         *     return field + String(item.id);
         *   },
         *   {
         *     iconPath: "chrome://zotero/skin/cross.png",
         *   }
         * );
         * ```
         */
        async register(key, label, getFieldHook, options = {
          showInColumnPicker: true
        }) {
          var _a;
          await ((_a = this.initializationLock) === null || _a === void 0 ? void 0 : _a.promise);
          if (!this.backend) {
            if (this.globalCache.columns.map((_c) => _c.dataKey).includes(key)) {
              this.log(`ItemTreeTool: ${key} is already registered.`);
              return;
            }
          }
          const column = {
            dataKey: key,
            label,
            pluginID: this._basicOptions.api.pluginID,
            iconLabel: options.iconPath ? this.createIconLabel({
              iconPath: options.iconPath,
              name: label
            }) : void 0,
            iconPath: options.iconPath,
            htmlLabel: options.htmlLabel,
            zoteroPersist: options.zoteroPersist || (this.backend ? this.defaultPersist : new Set(this.defaultPersist)),
            defaultIn: options.defaultIn,
            disabledIn: options.disabledIn,
            enabledTreeIDs: options.enabledTreeIDs,
            defaultSort: options.defaultSort,
            sortReverse: options.sortReverse || options.defaultSort === -1,
            flex: typeof options.flex === "undefined" ? 1 : options.flex,
            width: options.width,
            fixedWidth: options.fixedWidth,
            staticWidth: options.staticWidth,
            minWidth: options.minWidth,
            ignoreInColumnPicker: options.ignoreInColumnPicker,
            showInColumnPicker: typeof options.ignoreInColumnPicker === "undefined" ? true : options.showInColumnPicker,
            submenu: options.submenu,
            columnPickerSubMenu: options.columnPickerSubMenu || options.submenu,
            dataProvider: options.dataProvider || ((item, _dataKey) => item.getField(key)),
            renderCell: options.renderCell || options.renderCellHook
          };
          if (getFieldHook) {
            this.fieldHooks.register("getField", key, getFieldHook);
          }
          if (this.backend) {
            return await this.backend.registerColumns(column);
          } else {
            this.globalCache.columns.push(column);
            this.localColumnCache.push(column.dataKey);
            if (options.renderCellHook) {
              await this.addRenderCellHook(key, options.renderCellHook);
            }
            await this.refresh();
          }
        }
        /**
         * Unregister an extra column. Call it on plugin exit.
         * @param key Column dataKey, should be same as the one used in `register`
         * @param options.skipGetField skip unregister of getField hook.
         * This is useful when the hook is not initialized by this instance
         */
        async unregister(key, options = {}) {
          await this.initializationLock.promise;
          if (this.backend) {
            await this.backend.unregisterColumns(key);
            if (!options.skipGetField) {
              this.fieldHooks.unregister("getField", key);
            }
            return;
          }
          const Zotero2 = this.getGlobal("Zotero");
          let persisted = Zotero2.Prefs.get("pane.persist");
          const persistedJSON = JSON.parse(persisted);
          delete persistedJSON[key];
          Zotero2.Prefs.set("pane.persist", JSON.stringify(persistedJSON));
          const idx = this.globalCache.columns.map((_c) => _c.dataKey).indexOf(key);
          if (idx >= 0) {
            this.globalCache.columns.splice(idx, 1);
          }
          if (!options.skipGetField) {
            this.fieldHooks.unregister("getField", key);
          }
          this.removeRenderCellHook(key);
          await this.refresh();
          const localKeyIdx = this.localColumnCache.indexOf(key);
          if (localKeyIdx >= 0) {
            this.localColumnCache.splice(localKeyIdx, 1);
          }
        }
        /**
         * Add a patch hook for `_renderCell`, which is called when cell is rendered.
         * @deprecated
         *
         * This also works for Zotero's built-in cells.
         * @remarks
         * Don't call it manually unless you understand what you are doing.
         * @param dataKey Cell `dataKey`, e.g. 'title'
         * @param renderCellHook patch hook
         */
        async addRenderCellHook(dataKey, renderCellHook) {
          await this.initializationLock.promise;
          if (dataKey in this.globalCache.renderCellHooks) {
            this.log("[WARNING] ItemTreeTool.addRenderCellHook overwrites an existing hook:", dataKey);
          }
          this.globalCache.renderCellHooks[dataKey] = renderCellHook;
          this.localRenderCellCache.push(dataKey);
        }
        /**
         * Remove a patch hook by `dataKey`.
         * @deprecated
         */
        async removeRenderCellHook(dataKey) {
          delete this.globalCache.renderCellHooks[dataKey];
          const idx = this.localRenderCellCache.indexOf(dataKey);
          if (idx >= 0) {
            this.localRenderCellCache.splice(idx, 1);
          }
          await this.refresh();
        }
        /**
         * Do initializations. Called in constructor to be async
         */
        async initializeGlobal() {
          const Zotero2 = this.getGlobal("Zotero");
          await Zotero2.uiReadyPromise;
          const window2 = this.getGlobal("window");
          this.globalCache = toolkitGlobal_1.default.getInstance().itemTree;
          const globalCache = this.globalCache;
          if (!globalCache._ready) {
            globalCache._ready = true;
            const itemTree = window2.require("zotero/itemTree");
            if (!this.backend) {
              this.patcherManager.register(itemTree.prototype, "getColumns", (original) => function() {
                const columns = original.apply(this, arguments);
                const insertAfter = columns.findIndex((column) => column.dataKey === "title");
                columns.splice(insertAfter + 1, 0, ...globalCache.columns);
                return columns;
              });
            }
            this.patcherManager.register(itemTree.prototype, "_renderCell", (original) => function(index, data, column) {
              if (!(column.dataKey in globalCache.renderCellHooks)) {
                return original.apply(this, arguments);
              }
              const hook = globalCache.renderCellHooks[column.dataKey];
              const elem = hook(index, data, column, original.bind(this));
              if (elem.classList.contains("cell")) {
                return elem;
              }
              const span = window2.document.createElementNS("http://www.w3.org/1999/xhtml", "span");
              span.classList.add("cell", column.dataKey, `${column.dataKey}-item-tree-main-default`);
              if (column.fixedWidth) {
                span.classList.add("fixed-width");
              }
              span.appendChild(elem);
              return span;
            });
          }
          this.initializationLock.resolve();
        }
        /**
         * Create a React Icon element
         * @param props
         */
        createIconLabel(props) {
          const _React = window.require("react");
          return _React.createElement("span", null, _React.createElement("img", {
            src: props.iconPath,
            height: "10px",
            width: "9px",
            style: {
              "margin-left": "6px"
            }
          }), " ", props.name);
        }
        /**
         * Refresh itemView. You don't need to call it manually.
         */
        async refresh() {
          var _a, _b;
          await this.initializationLock.promise;
          const ZoteroPane2 = this.getGlobal("ZoteroPane");
          ZoteroPane2.itemsView._columnsId = null;
          const virtualizedTable = (_a = ZoteroPane2.itemsView.tree) === null || _a === void 0 ? void 0 : _a._columns;
          if (!virtualizedTable) {
            this.log("ItemTree is still loading. Refresh skipped.");
            return;
          }
          (_b = document.querySelector(`.${virtualizedTable._styleKey}`)) === null || _b === void 0 ? void 0 : _b.remove();
          await ZoteroPane2.itemsView.refreshAndMaintainSelection();
          ZoteroPane2.itemsView.tree._columns = new virtualizedTable.__proto__.constructor(ZoteroPane2.itemsView.tree);
          await ZoteroPane2.itemsView.refreshAndMaintainSelection();
        }
      };
      exports.ItemTreeManager = ItemTreeManager;
    }
  });

  // node_modules/zotero-plugin-toolkit/dist/managers/prompt.js
  var require_prompt = __commonJS({
    "node_modules/zotero-plugin-toolkit/dist/managers/prompt.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PromptManager = exports.Prompt = void 0;
      var basic_1 = require_basic();
      var basic_2 = require_basic();
      var ui_1 = require_ui();
      var toolkitGlobal_1 = __importDefault(require_toolkitGlobal());
      var Prompt = class {
        get document() {
          return this.base.getGlobal("document");
        }
        /**
         * Initialize `Prompt` but do not create UI.
         */
        constructor() {
          this.lastInputText = "";
          this.defaultText = {
            placeholder: "Select a command...",
            empty: "No commands found."
          };
          this.maxLineNum = 12;
          this.maxSuggestionNum = 100;
          this.commands = [];
          this.base = new basic_1.BasicTool();
          this.ui = new ui_1.UITool();
          this.initializeUI();
        }
        /**
         * Initialize `Prompt` UI and then bind events on it.
         */
        initializeUI() {
          this.addStyle();
          this.createHTML();
          this.initInputEvents();
          this.registerShortcut();
        }
        createHTML() {
          this.promptNode = this.ui.createElement(this.document, "div", {
            styles: {
              display: "none"
            },
            children: [
              {
                tag: "div",
                styles: {
                  position: "fixed",
                  left: "0",
                  top: "0",
                  backgroundColor: "rgba(220, 220, 220, 0.4)",
                  width: "100%",
                  height: "100%",
                  opacity: "0.5"
                },
                listeners: [
                  {
                    type: "click",
                    listener: () => {
                      this.promptNode.style.display = "none";
                    }
                  }
                ]
              }
            ]
          });
          this.promptNode.appendChild(this.ui.createElement(this.document, "div", {
            id: `zotero-plugin-toolkit-prompt`,
            classList: ["prompt-container"],
            children: [
              {
                tag: "div",
                classList: ["input-container"],
                children: [
                  {
                    tag: "input",
                    classList: ["prompt-input"],
                    attributes: {
                      type: "text",
                      placeholder: this.defaultText.placeholder
                    }
                  },
                  {
                    tag: "div",
                    classList: ["cta"]
                  }
                ]
              },
              {
                tag: "div",
                classList: ["commands-containers"]
              },
              {
                tag: "div",
                classList: ["instructions"],
                children: [
                  {
                    tag: "div",
                    classList: ["instruction"],
                    children: [
                      {
                        tag: "span",
                        classList: ["key"],
                        properties: {
                          innerText: "\u2191\u2193"
                        }
                      },
                      {
                        tag: "span",
                        properties: {
                          innerText: "to navigate"
                        }
                      }
                    ]
                  },
                  {
                    tag: "div",
                    classList: ["instruction"],
                    children: [
                      {
                        tag: "span",
                        classList: ["key"],
                        properties: {
                          innerText: "enter"
                        }
                      },
                      {
                        tag: "span",
                        properties: {
                          innerText: "to trigger"
                        }
                      }
                    ]
                  },
                  {
                    tag: "div",
                    classList: ["instruction"],
                    children: [
                      {
                        tag: "span",
                        classList: ["key"],
                        properties: {
                          innerText: "esc"
                        }
                      },
                      {
                        tag: "span",
                        properties: {
                          innerText: "to exit"
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }));
          this.inputNode = this.promptNode.querySelector("input");
          this.document.documentElement.appendChild(this.promptNode);
        }
        /**
         * Show commands in a new `commandsContainer`
         * All other `commandsContainer` is hidden
         * @param commands Command[]
         * @param clear remove all `commandsContainer` if true
         */
        showCommands(commands, clear = false) {
          if (clear) {
            this.promptNode.querySelectorAll(".commands-container").forEach((e) => e.remove());
          }
          this.inputNode.placeholder = this.defaultText.placeholder;
          const commandsContainer = this.createCommandsContainer();
          for (let command of commands) {
            try {
              if (!command.name || command.when && !command.when()) {
                continue;
              }
            } catch (_a) {
              continue;
            }
            commandsContainer.appendChild(this.createCommandNode(command));
          }
        }
        /**
         * Create a `commandsContainer` div element, append to `commandsContainer` and hide others.
         * @returns commandsNode
         */
        createCommandsContainer() {
          const commandsContainer = this.ui.createElement(this.document, "div", {
            classList: ["commands-container"]
          });
          this.promptNode.querySelectorAll(".commands-container").forEach((e) => {
            e.style.display = "none";
          });
          this.promptNode.querySelector(".commands-containers").appendChild(commandsContainer);
          return commandsContainer;
        }
        /**
         * Return current displayed `commandsContainer`
         * @returns
         */
        getCommandsContainer() {
          return [
            ...Array.from(this.promptNode.querySelectorAll(".commands-container"))
          ].find((e) => {
            return e.style.display != "none";
          });
        }
        /**
         * Create a command item for `Prompt` UI.
         * @param command
         * @returns
         */
        createCommandNode(command) {
          const commandNode = this.ui.createElement(this.document, "div", {
            classList: ["command"],
            children: [
              {
                tag: "div",
                classList: ["content"],
                children: [
                  {
                    tag: "div",
                    classList: ["name"],
                    children: [
                      {
                        tag: "span",
                        properties: {
                          innerText: command.name
                        }
                      }
                    ]
                  },
                  {
                    tag: "div",
                    classList: ["aux"],
                    children: command.label ? [
                      {
                        tag: "span",
                        classList: ["label"],
                        properties: {
                          innerText: command.label
                        }
                      }
                    ] : []
                  }
                ]
              }
            ],
            listeners: [
              {
                type: "mousemove",
                listener: () => {
                  this.selectItem(commandNode);
                }
              },
              {
                type: "click",
                listener: async () => {
                  await this.execCallback(command.callback);
                }
              }
            ]
          });
          commandNode.command = command;
          return commandNode;
        }
        /**
         * Called when `enter` key is pressed.
         */
        trigger() {
          [...Array.from(this.promptNode.querySelectorAll(".commands-container"))].find((e) => e.style.display != "none").querySelector(".selected").click();
        }
        /**
         * Called when `escape` key is pressed.
         */
        exit() {
          this.inputNode.placeholder = this.defaultText.placeholder;
          if (this.promptNode.querySelectorAll(".commands-containers .commands-container").length >= 2) {
            this.promptNode.querySelector(".commands-container:last-child").remove();
            const commandsContainer = this.promptNode.querySelector(".commands-container:last-child");
            commandsContainer.style.display = "";
            commandsContainer.querySelectorAll(".commands").forEach((e) => e.style.display = "flex");
            this.inputNode.focus();
          } else {
            this.promptNode.style.display = "none";
          }
        }
        async execCallback(callback) {
          if (Array.isArray(callback)) {
            this.showCommands(callback);
          } else {
            await callback(this);
          }
        }
        /**
         * Match suggestions for user's entered text.
         */
        async showSuggestions(inputText) {
          var _w = /[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,\-.\/:;<=>?@\[\]^_`{|}~]/, jw = /\s/, Ww = /[\u0F00-\u0FFF\u3040-\u30ff\u3400-\u4dbf\u4e00-\u9fff\uf900-\ufaff\uff66-\uff9f]/;
          function Yw(e2, t, n, i) {
            if (0 === e2.length)
              return 0;
            var r = 0;
            r -= Math.max(0, e2.length - 1), r -= i / 10;
            var o = e2[0][0];
            return r -= (e2[e2.length - 1][1] - o + 1 - t) / 100, r -= o / 1e3, r -= n / 1e4;
          }
          function $w(e2, t, n, i) {
            if (0 === e2.length)
              return null;
            for (var r = n.toLowerCase(), o = 0, a = 0, s = [], l = 0; l < e2.length; l++) {
              var c = e2[l], u = r.indexOf(c, a);
              if (-1 === u)
                return null;
              var h = n.charAt(u);
              if (u > 0 && !_w.test(h) && !Ww.test(h)) {
                var p = n.charAt(u - 1);
                if (h.toLowerCase() !== h && p.toLowerCase() !== p || h.toUpperCase() !== h && !_w.test(p) && !jw.test(p) && !Ww.test(p))
                  if (i) {
                    if (u !== a) {
                      a += c.length, l--;
                      continue;
                    }
                  } else
                    o += 1;
              }
              if (0 === s.length)
                s.push([u, u + c.length]);
              else {
                var d = s[s.length - 1];
                d[1] < u ? s.push([u, u + c.length]) : d[1] = u + c.length;
              }
              a = u + c.length;
            }
            return {
              matches: s,
              score: Yw(s, t.length, r.length, o)
            };
          }
          function Gw(e2) {
            for (var t = e2.toLowerCase(), n = [], i = 0, r = 0; r < t.length; r++) {
              var o = t.charAt(r);
              jw.test(o) ? (i !== r && n.push(t.substring(i, r)), i = r + 1) : (_w.test(o) || Ww.test(o)) && (i !== r && n.push(t.substring(i, r)), n.push(o), i = r + 1);
            }
            return i !== t.length && n.push(t.substring(i, t.length)), {
              query: e2,
              tokens: n,
              fuzzy: t.split("")
            };
          }
          function Xw(e2, t) {
            if ("" === e2.query)
              return {
                score: 0,
                matches: []
              };
            var n = $w(e2.tokens, e2.query, t, false);
            return n || $w(e2.fuzzy, e2.query, t, true);
          }
          var e = Gw(inputText);
          let container = this.getCommandsContainer();
          if (container.classList.contains("suggestions")) {
            this.exit();
          }
          if (inputText.trim() == "") {
            return true;
          }
          let suggestions = [];
          this.getCommandsContainer().querySelectorAll(".command").forEach((commandNode) => {
            let spanNode = commandNode.querySelector(".name span");
            let spanText = spanNode.innerText;
            let res = Xw(e, spanText);
            if (res) {
              commandNode = this.createCommandNode(commandNode.command);
              let spanHTML = "";
              let i = 0;
              for (let j = 0; j < res.matches.length; j++) {
                let [start, end] = res.matches[j];
                if (start > i) {
                  spanHTML += spanText.slice(i, start);
                }
                spanHTML += `<span class="highlight">${spanText.slice(start, end)}</span>`;
                i = end;
              }
              if (i < spanText.length) {
                spanHTML += spanText.slice(i, spanText.length);
              }
              commandNode.querySelector(".name span").innerHTML = spanHTML;
              suggestions.push({ score: res.score, commandNode });
            }
          });
          if (suggestions.length > 0) {
            suggestions.sort((a, b) => b.score - a.score).slice(this.maxSuggestionNum);
            container = this.createCommandsContainer();
            container.classList.add("suggestions");
            suggestions.forEach((suggestion) => {
              container.appendChild(suggestion.commandNode);
            });
            return true;
          } else {
            const anonymousCommand = this.commands.find((c) => !c.name && (!c.when || c.when()));
            if (anonymousCommand) {
              await this.execCallback(anonymousCommand.callback);
            } else {
              this.showTip(this.defaultText.empty);
            }
            return false;
          }
        }
        /**
         * Bind events of pressing `keydown` and `keyup` key.
         */
        initInputEvents() {
          this.promptNode.addEventListener("keydown", (event) => {
            if (["ArrowUp", "ArrowDown"].indexOf(event.key) != -1) {
              event.preventDefault();
              let selectedIndex;
              let allItems = [
                ...Array.from(this.getCommandsContainer().querySelectorAll(".command"))
              ].filter((e) => e.style.display != "none");
              selectedIndex = allItems.findIndex((e) => e.classList.contains("selected"));
              if (selectedIndex != -1) {
                allItems[selectedIndex].classList.remove("selected");
                selectedIndex += event.key == "ArrowUp" ? -1 : 1;
              } else {
                if (event.key == "ArrowUp") {
                  selectedIndex = allItems.length - 1;
                } else {
                  selectedIndex = 0;
                }
              }
              if (selectedIndex == -1) {
                selectedIndex = allItems.length - 1;
              } else if (selectedIndex == allItems.length) {
                selectedIndex = 0;
              }
              allItems[selectedIndex].classList.add("selected");
              let commandsContainer = this.getCommandsContainer();
              commandsContainer.scrollTo(0, commandsContainer.querySelector(".selected").offsetTop - commandsContainer.offsetHeight + 7.5);
              allItems[selectedIndex].classList.add("selected");
            }
          });
          this.promptNode.addEventListener("keyup", async (event) => {
            if (event.key == "Enter") {
              this.trigger();
            } else if (event.key == "Escape") {
              if (this.inputNode.value.length > 0) {
                this.inputNode.value = "";
              } else {
                this.exit();
              }
            } else if (["ArrowUp", "ArrowDown"].indexOf(event.key) != -1) {
              return;
            }
            const currentInputText = this.inputNode.value;
            if (currentInputText == this.lastInputText) {
              return;
            }
            this.lastInputText = currentInputText;
            window.setTimeout(async () => {
              await this.showSuggestions(currentInputText);
            });
          });
        }
        /**
         * Create a commandsContainer and display a text
         */
        showTip(text) {
          const tipNode = this.ui.createElement(this.document, "div", {
            classList: ["tip"],
            properties: {
              innerText: text
            }
          });
          let container = this.createCommandsContainer();
          container.classList.add("suggestions");
          container.appendChild(tipNode);
          return tipNode;
        }
        /**
         * Mark the selected item with class `selected`.
         * @param item HTMLDivElement
         */
        selectItem(item) {
          this.getCommandsContainer().querySelectorAll(".command").forEach((e) => e.classList.remove("selected"));
          item.classList.add("selected");
        }
        addStyle() {
          const style = this.ui.createElement(this.document, "style", {
            namespace: "html",
            id: "prompt-style"
          });
          style.innerText = `
      .prompt-container * {
        box-sizing: border-box;
      }
      .prompt-container {
        ---radius---: 10px;
        position: fixed;
        left: 25%;
        top: 10%;
        width: 50%;
        border-radius: var(---radius---);
        border: 1px solid #bdbdbd;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background-color: white;
        font-size: 18px;
        box-shadow: 0px 1.8px 7.3px rgba(0, 0, 0, 0.071),
                    0px 6.3px 24.7px rgba(0, 0, 0, 0.112),
                    0px 30px 90px rgba(0, 0, 0, 0.2);
        font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Inter", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Microsoft YaHei Light", sans-serif;
      }
      
      /* input */
      .prompt-container .input-container  {
        width: 100%;
      }
      
      .input-container input {
        width: 100%;
        height: 40px;
        padding: 24px;
        border-radius: 50%;
        border: none;
        outline: none;
        font-size: 18px;
      }
      
      .input-container .cta {
        border-bottom: 1px solid #f6f6f6;  
        margin: 5px auto;
      }
      
      /* results */
      .commands-containers {
        width: 100%;
        height: 100%;
      }
      .commands-container {
        max-height: calc(${this.maxLineNum} * 35.5px);
        width: calc(100% - 12px);
        margin-left: 12px;
        margin-right: 0%;
        overflow-y: auto;
        overflow-x: hidden;
      }
      
      .commands-container .command {
        display: flex;
        align-content: baseline;
        justify-content: space-between;
        border-radius: 5px;
        padding: 6px 12px;
        margin-right: 12px;
        margin-top: 2px;
        margin-bottom: 2px;
      }
      .commands-container .command .content {
        display: flex;
        width: 100%;
        justify-content: space-between;
        flex-direction: row;
        overflow: hidden;
      }
      .commands-container .command .content .name {
        white-space: nowrap; 
        text-overflow: ellipsis;
        overflow: hidden;
      }
      .commands-container .command .content .aux {
        display: flex;
        align-items: center;
        align-self: center;
        flex-shrink: 0;
      }
      
      .commands-container .command .content .aux .label {
        font-size: 15px;
        color: #5a5a5a;
        padding: 2px 6px;
        background-color: #fafafa;
        border-radius: 5px;
      }
      
      .commands-container .selected {
          background-color: rgba(0, 0, 0, 0.075);
      }

      .commands-container .highlight {
        font-weight: bold;
      }

      .tip {
        color: #5a5a5a;
        text-align: center;
        padding: 12px 12px;
        font-size: 18px;
      }
      
      .current-value {
        background-color: #a7b8c1;
        color: white;
        border-radius: 5px;
        padding: 0 5px;
        margin-left: 10px;
        font-size: 14px;
        vertical-align: middle;
        letter-spacing: 0.05em;
      }

      /* instructions */
      .instructions {
        display: flex;
        align-content: center;
        justify-content: center;
        font-size: 15px;
        color: rgba(0, 0, 0, 0.4);
        height: 2.5em;
        width: 100%;
        border-top: 1px solid #f6f6f6;
        margin-top: 5px;
      }
      
      .instructions .instruction {
        margin: auto .5em;  
      }
      
      .instructions .key {
        margin-right: .2em;
        font-weight: 600;
      }
    `;
          this.document.documentElement.appendChild(style);
        }
        registerShortcut() {
          this.document.addEventListener("keydown", (event) => {
            if (event.shiftKey && event.key.toLowerCase() == "p") {
              if (event.originalTarget.isContentEditable || "value" in event.originalTarget || this.commands.length == 0) {
                return;
              }
              event.preventDefault();
              event.stopPropagation();
              if (this.promptNode.style.display == "none") {
                this.promptNode.style.display = "flex";
                if (this.promptNode.querySelectorAll(".commands-container").length == 1) {
                  this.showCommands(this.commands, true);
                }
                this.promptNode.focus();
                this.inputNode.focus();
              } else {
                this.promptNode.style.display = "none";
              }
            }
          }, true);
        }
      };
      exports.Prompt = Prompt;
      var PromptManager = class extends basic_2.ManagerTool {
        constructor(base) {
          super(base);
          this.commands = [];
          const globalCache = toolkitGlobal_1.default.getInstance().prompt;
          if (!globalCache._ready) {
            globalCache._ready = true;
            globalCache.instance = new Prompt();
          }
          this.prompt = globalCache.instance;
        }
        /**
         * Register commands. Don't forget to call `unregister` on plugin exit.
         * @param commands Command[]
         * @example
         * ```ts
         * let getReader = () => {
         *   return BasicTool.getZotero().Reader.getByTabID(
         *     (Zotero.getMainWindow().Zotero_Tabs).selectedID
         *   )
         * }
         *
         * register([
         *   {
         *     name: "Split Horizontally",
         *     label: "Zotero",
         *     when: () => getReader() as boolean,
         *     callback: (prompt: Prompt) => getReader().menuCmd("splitHorizontally")
         *   },
         *   {
         *     name: "Split Vertically",
         *     label: "Zotero",
         *     when: () => getReader() as boolean,
         *     callback: (prompt: Prompt) => getReader().menuCmd("splitVertically")
         *   }
         * ])
         * ```
         */
        register(commands) {
          commands.forEach((c) => {
            var _a;
            return (_a = c.id) !== null && _a !== void 0 ? _a : c.id = c.name;
          });
          this.prompt.commands = [...this.prompt.commands, ...commands];
          this.commands = [...this.commands, ...commands];
          this.prompt.showCommands(this.commands, true);
        }
        /**
         * You can delete a command registed before by its name.
         * @remarks
         * There is a premise here that the names of all commands registered by a single plugin are not duplicated.
         * @param id Command.name
         */
        unregister(id) {
          const command = this.commands.find((c) => c.id == id);
          this.prompt.commands = this.prompt.commands.filter((c) => {
            return JSON.stringify(command) != JSON.stringify(c);
          });
          this.commands = this.commands.filter((c) => c.id != id);
        }
        /**
         * Call `unregisterAll` on plugin exit.
         */
        unregisterAll() {
          this.prompt.commands = this.prompt.commands.filter((c) => {
            return this.commands.find((_c) => {
              JSON.stringify(_c) != JSON.stringify(c);
            });
          });
          this.commands = [];
        }
      };
      exports.PromptManager = PromptManager;
    }
  });

  // node_modules/zotero-plugin-toolkit/dist/managers/libraryTabPanel.js
  var require_libraryTabPanel = __commonJS({
    "node_modules/zotero-plugin-toolkit/dist/managers/libraryTabPanel.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LibraryTabPanelManager = void 0;
      var ui_1 = require_ui();
      var basic_1 = require_basic();
      var LibraryTabPanelManager = class extends basic_1.ManagerTool {
        constructor(base) {
          super(base);
          this.ui = new ui_1.UITool(this);
          this.libraryTabCache = {
            optionsList: []
          };
        }
        /**
         * Register a tabpanel in library.
         * @remarks
         * If you don't want to remove the tab & panel in runtime, `unregisterLibraryTabPanel` is not a must.
         *
         * The elements wiil be removed by `removeAddonElements`.
         * @param tabLabel Label of panel tab.
         * @param renderPanelHook Called when panel is ready. Add elements to the panel.
         * @param options Other optional parameters.
         * @param options.tabId ID of panel tab. Also used as unregister query. If not set, generate a random one.
         * @param options.panelId ID of panel container (XUL.TabPanel). If not set, generate a random one.
         * @param options.targetIndex Index of the inserted tab. Default the end of tabs.
         * @param options.selectPanel If the panel should be selected immediately.
         * @returns tabId. Use it for unregister.
         * @example
         * Register an extra library tabpanel into index 1.
         * ```ts
         * const libPaneManager = new LibraryTabPanelManager();
         * const libTabId = libPaneManager.registerLibraryTabPanel(
         *   "test",
         *   (panel: XUL.Element, win: Window) => {
         *     const elem = ui.creatElementsFromJSON(
         *       win.document,
         *       {
         *         tag: "vbox",
         *         namespace: "xul",
         *         subElementOptions: [
         *           {
         *             tag: "h2",
         *             directAttributes: {
         *               innerText: "Hello World!",
         *             },
         *           },
         *           {
         *             tag: "label",
         *             namespace: "xul",
         *             directAttributes: {
         *               value: "This is a library tab.",
         *             },
         *           },
         *           {
         *             tag: "button",
         *             directAttributes: {
         *               innerText: "Unregister",
         *             },
         *             listeners: [
         *               {
         *                 type: "click",
         *                 listener: () => {
         *                   ui.unregisterLibraryTabPanel(
         *                     libTabId
         *                   );
         *                 },
         *               },
         *             ],
         *           },
         *         ],
         *       }
         *     );
         *     panel.append(elem);
         *   },
         *   {
         *     targetIndex: 1,
         *   }
         * );
         * ```
         */
        register(tabLabel, renderPanelHook, options) {
          options = options || {
            tabId: void 0,
            panelId: void 0,
            targetIndex: -1,
            selectPanel: false
          };
          const window2 = this.getGlobal("window");
          const tabbox = window2.document.querySelector("#zotero-view-tabbox");
          const randomId = `${Zotero.Utilities.randomString()}-${(/* @__PURE__ */ new Date()).getTime()}`;
          const tabId = options.tabId || `toolkit-readertab-${randomId}`;
          const panelId = options.panelId || `toolkit-readertabpanel-${randomId}`;
          const tab = this.ui.createElement(window2.document, "tab", {
            id: tabId,
            classList: [`toolkit-ui-tabs-${tabId}`],
            attributes: {
              label: tabLabel
            },
            ignoreIfExists: true
          });
          const tabpanel = this.ui.createElement(window2.document, "tabpanel", {
            id: panelId,
            classList: [`toolkit-ui-tabs-${tabId}`],
            ignoreIfExists: true
          });
          const tabs = tabbox.querySelector("tabs");
          const tabpanels = tabbox.querySelector("tabpanels");
          const targetIndex = typeof options.targetIndex === "number" ? options.targetIndex : -1;
          if (targetIndex >= 0) {
            tabs.querySelectorAll("tab")[targetIndex].before(tab);
            tabpanels.querySelectorAll("tabpanel")[targetIndex].before(tabpanel);
          } else {
            tabs.appendChild(tab);
            tabpanels.appendChild(tabpanel);
          }
          if (options.selectPanel) {
            tabbox.selectedTab = tab;
          }
          this.libraryTabCache.optionsList.push({
            tabId,
            tabLabel,
            panelId,
            renderPanelHook,
            targetIndex,
            selectPanel: options.selectPanel
          });
          renderPanelHook(tabpanel, window2);
          return tabId;
        }
        /**
         * Unregister the library tabpanel.
         * @param tabId tab id
         */
        unregister(tabId) {
          const idx = this.libraryTabCache.optionsList.findIndex((v) => v.tabId === tabId);
          if (idx >= 0) {
            this.libraryTabCache.optionsList.splice(idx, 1);
          }
          this.removeTabPanel(tabId);
        }
        /**
         * Unregister all library tabpanel.
         */
        unregisterAll() {
          const tabIds = this.libraryTabCache.optionsList.map((options) => options.tabId);
          tabIds.forEach(this.unregister.bind(this));
        }
        removeTabPanel(tabId) {
          const doc = this.getGlobal("document");
          Array.prototype.forEach.call(doc.querySelectorAll(`.toolkit-ui-tabs-${tabId}`), (e) => {
            e.remove();
          });
        }
      };
      exports.LibraryTabPanelManager = LibraryTabPanelManager;
    }
  });

  // node_modules/zotero-plugin-toolkit/dist/managers/readerTabPanel.js
  var require_readerTabPanel = __commonJS({
    "node_modules/zotero-plugin-toolkit/dist/managers/readerTabPanel.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ReaderTabPanelManager = void 0;
      var ui_1 = require_ui();
      var reader_1 = require_reader();
      var basic_1 = require_basic();
      var ReaderTabPanelManager = class extends basic_1.ManagerTool {
        constructor(base) {
          super(base);
          this.ui = new ui_1.UITool(this);
          this.readerTool = new reader_1.ReaderTool(this);
          this.readerTabCache = {
            optionsList: [],
            observer: void 0,
            initializeLock: void 0
          };
        }
        /**
         * Register a tabpanel for every reader.
         * @remarks
         * Don't forget to call `unregisterReaderTabPanel` on exit.
         * @remarks
         * Every time a tab reader is selected/opened, the hook will be called.
         * @param tabLabel Label of panel tab.
         * @param renderPanelHook Called when panel is ready. Add elements to the panel.
         *
         * The panel might be `undefined` when opening a PDF without parent item.
         *
         * The owner deck is the top container of right-side bar.
         *
         * The readerInstance is the reader of current tabpanel.
         * @param options Other optional parameters.
         * @param options.tabId ID of panel tab. Also used as unregister query. If not set, generate a random one.
         * @param options.panelId ID of panel container (XUL.TabPanel). If not set, generate a random one.
         * @param options.targetIndex Index of the inserted tab. Default the end of tabs.
         * @param options.selectPanel If the panel should be selected immediately.
         * @returns tabId. Use it for unregister.
         * @example
         * Register an extra reader tabpanel into index 1.
         * ```ts
         * const readerTabId = `${config.addonRef}-extra-reader-tab`;
         * this._Addon.toolkit.UI.registerReaderTabPanel(
         *   "test",
         *   (
         *     panel: XUL.Element,
         *     deck: XUL.Deck,
         *     win: Window,
         *     reader: _ZoteroReaderInstance
         *   ) => {
         *     if (!panel) {
         *       this._Addon.toolkit.Tool.log(
         *         "This reader do not have right-side bar. Adding reader tab skipped."
         *       );
         *       return;
         *     }
         *     this._Addon.toolkit.Tool.log(reader);
         *     const elem = this._Addon.toolkit.UI.creatElementsFromJSON(
         *       win.document,
         *       {
         *         tag: "vbox",
         *         id: `${config.addonRef}-${reader._instanceID}-extra-reader-tab-div`,
         *         namespace: "xul",
         *         // This is important! Don't create content for multiple times
         *         ignoreIfExists: true,
         *         subElementOptions: [
         *           {
         *             tag: "h2",
         *             directAttributes: {
         *               innerText: "Hello World!",
         *             },
         *           },
         *           {
         *             tag: "label",
         *             namespace: "xul",
         *             directAttributes: {
         *               value: "This is a reader tab.",
         *             },
         *           },
         *           {
         *             tag: "label",
         *             namespace: "xul",
         *             directAttributes: {
         *               value: `Reader: ${reader._title.slice(0, 20)}`,
         *             },
         *           },
         *           {
         *             tag: "label",
         *             namespace: "xul",
         *             directAttributes: {
         *               value: `itemID: ${reader.itemID}.`,
         *             },
         *           },
         *           {
         *             tag: "button",
         *             directAttributes: {
         *               innerText: "Unregister",
         *             },
         *             listeners: [
         *               {
         *                 type: "click",
         *                 listener: () => {
         *                   this._Addon.toolkit.UI.unregisterReaderTabPanel(
         *                     readerTabId
         *                   );
         *                 },
         *               },
         *             ],
         *           },
         *         ],
         *       }
         *     );
         *     panel.append(elem);
         *   },
         *   {
         *     tabId: readerTabId,
         *   }
         * );
         * ```
         */
        async register(tabLabel, renderPanelHook, options) {
          var _a;
          options = options || {
            tabId: void 0,
            panelId: void 0,
            targetIndex: -1,
            selectPanel: false
          };
          if (typeof this.readerTabCache.initializeLock === "undefined") {
            await this.initializeReaderTabObserver();
          }
          await ((_a = this.readerTabCache.initializeLock) === null || _a === void 0 ? void 0 : _a.promise);
          const randomId = `${Zotero.Utilities.randomString()}-${(/* @__PURE__ */ new Date()).getTime()}`;
          const tabId = options.tabId || `toolkit-readertab-${randomId}`;
          const panelId = options.panelId || `toolkit-readertabpanel-${randomId}`;
          const targetIndex = typeof options.targetIndex === "number" ? options.targetIndex : -1;
          this.readerTabCache.optionsList.push({
            tabId,
            tabLabel,
            panelId,
            renderPanelHook,
            targetIndex,
            selectPanel: options.selectPanel
          });
          await this.addReaderTabPanel();
          return tabId;
        }
        /**
         * Unregister the reader tabpanel.
         * @param tabId tab id
         */
        unregister(tabId) {
          var _a;
          const idx = this.readerTabCache.optionsList.findIndex((v) => v.tabId === tabId);
          if (idx >= 0) {
            this.readerTabCache.optionsList.splice(idx, 1);
          }
          if (this.readerTabCache.optionsList.length === 0) {
            (_a = this.readerTabCache.observer) === null || _a === void 0 ? void 0 : _a.disconnect();
            this.readerTabCache = {
              optionsList: [],
              observer: void 0,
              initializeLock: void 0
            };
          }
          this.removeTabPanel(tabId);
        }
        /**
         * Unregister all library tabpanel.
         */
        unregisterAll() {
          const tabIds = this.readerTabCache.optionsList.map((options) => options.tabId);
          tabIds.forEach(this.unregister.bind(this));
        }
        changeTabPanel(tabId, options) {
          const idx = this.readerTabCache.optionsList.findIndex((v) => v.tabId === tabId);
          if (idx >= 0) {
            Object.assign(this.readerTabCache.optionsList[idx], options);
          }
        }
        removeTabPanel(tabId) {
          const doc = this.getGlobal("document");
          Array.prototype.forEach.call(doc.querySelectorAll(`.toolkit-ui-tabs-${tabId}`), (e) => {
            e.remove();
          });
        }
        async initializeReaderTabObserver() {
          this.readerTabCache.initializeLock = this.getGlobal("Zotero").Promise.defer();
          await Promise.all([
            Zotero.initializationPromise,
            Zotero.unlockPromise,
            Zotero.uiReadyPromise
          ]);
          let lock = Zotero.Promise.defer();
          lock.resolve();
          const observer = await this.readerTool.addReaderTabPanelDeckObserver(async () => {
            await lock.promise;
            lock = Zotero.Promise.defer();
            try {
              this.addReaderTabPanel();
            } catch (e) {
            }
            lock.resolve();
          });
          this.readerTabCache.observer = observer;
          this.readerTabCache.initializeLock.resolve();
        }
        async addReaderTabPanel() {
          var _a, _b;
          const window2 = this.getGlobal("window");
          const deck = this.readerTool.getReaderTabPanelDeck();
          const reader = await this.readerTool.getReader();
          if (!reader) {
            return;
          }
          if (((_a = deck.selectedPanel) === null || _a === void 0 ? void 0 : _a.children[0].tagName) === "vbox") {
            const container = deck.selectedPanel;
            container.innerHTML = "";
            this.ui.appendElement({
              tag: "tabbox",
              classList: ["zotero-view-tabbox"],
              attributes: {
                flex: "1"
              },
              enableElementRecord: false,
              children: [
                {
                  tag: "tabs",
                  classList: ["zotero-editpane-tabs"],
                  attributes: {
                    orient: "horizontal"
                  },
                  enableElementRecord: false
                },
                {
                  tag: "tabpanels",
                  classList: ["zotero-view-item"],
                  attributes: {
                    flex: "1"
                  },
                  enableElementRecord: false
                }
              ]
            }, container);
          }
          let tabbox = (_b = deck.selectedPanel) === null || _b === void 0 ? void 0 : _b.querySelector("tabbox");
          if (!tabbox) {
            return;
          }
          const tabs = tabbox.querySelector("tabs");
          const tabpanels = tabbox.querySelector("tabpanels");
          this.readerTabCache.optionsList.forEach((options) => {
            const tabId = `${options.tabId}-${reader._instanceID}`;
            const tabClass = `toolkit-ui-tabs-${options.tabId}`;
            if (tabs === null || tabs === void 0 ? void 0 : tabs.querySelector(`.${tabClass}`)) {
              return;
            }
            const tab = this.ui.createElement(window2.document, "tab", {
              id: tabId,
              classList: [tabClass],
              attributes: {
                label: options.tabLabel
              },
              ignoreIfExists: true
            });
            const tabpanel = this.ui.createElement(window2.document, "tabpanel", {
              id: `${options.panelId}-${reader._instanceID}`,
              classList: [tabClass],
              ignoreIfExists: true
            });
            if (options.targetIndex >= 0) {
              tabs === null || tabs === void 0 ? void 0 : tabs.querySelectorAll("tab")[options.targetIndex].before(tab);
              tabpanels === null || tabpanels === void 0 ? void 0 : tabpanels.querySelectorAll("tabpanel")[options.targetIndex].before(tabpanel);
              if (tabbox.getAttribute("toolkit-select-fixed") !== "true") {
                tabbox.tabpanels.addEventListener("select", () => {
                  this.getGlobal("setTimeout")(() => {
                    tabbox.tabpanels.selectedPanel = tabbox.tabs.getRelatedElement(tabbox === null || tabbox === void 0 ? void 0 : tabbox.tabs.selectedItem);
                  }, 0);
                });
                tabbox.setAttribute("toolkit-select-fixed", "true");
              }
            } else {
              tabs === null || tabs === void 0 ? void 0 : tabs.appendChild(tab);
              tabpanels === null || tabpanels === void 0 ? void 0 : tabpanels.appendChild(tabpanel);
            }
            if (options.selectPanel) {
              tabbox.selectedTab = tab;
            }
            options.renderPanelHook(tabpanel, deck, window2, reader);
          });
        }
      };
      exports.ReaderTabPanelManager = ReaderTabPanelManager;
    }
  });

  // node_modules/zotero-plugin-toolkit/dist/managers/menu.js
  var require_menu = __commonJS({
    "node_modules/zotero-plugin-toolkit/dist/managers/menu.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MenuManager = void 0;
      var ui_1 = require_ui();
      var basic_1 = require_basic();
      var MenuManager = class extends basic_1.ManagerTool {
        constructor(base) {
          super(base);
          this.ui = new ui_1.UITool(this);
        }
        /**
         * Insert an menu item/menu(with popup)/menuseprator into a menupopup
         * @remarks
         * options:
         * ```ts
         * export interface MenuitemOptions {
         *   tag: "menuitem" | "menu" | "menuseparator";
         *   id?: string;
         *   label?: string;
         *   // data url (chrome://xxx.png) or base64 url (data:image/png;base64,xxx)
         *   icon?: string;
         *   class?: string;
         *   styles?: { [key: string]: string };
         *   hidden?: boolean;
         *   disabled?: boolean;
         *   oncommand?: string;
         *   commandListener?: EventListenerOrEventListenerObject;
         *   // Attributes below are used when type === "menu"
         *   popupId?: string;
         *   onpopupshowing?: string;
         *   subElementOptions?: Array<MenuitemOptions>;
         * }
         * ```
         * @param menuPopup
         * @param options
         * @param insertPosition
         * @param anchorElement The menuitem will be put before/after `anchorElement`. If not set, put at start/end of the menupopup.
         * @example
         * Insert menuitem with icon into item menupopup
         * ```ts
         * // base64 or chrome:// url
         * const menuIcon = "chrome://addontemplate/content/icons/favicon@0.5x.png";
         * ztoolkit.Menu.register("item", {
         *   tag: "menuitem",
         *   id: "zotero-itemmenu-addontemplate-test",
         *   label: "Addon Template: Menuitem",
         *   oncommand: "alert('Hello World! Default Menuitem.')",
         *   icon: menuIcon,
         * });
         * ```
         * @example
         * Insert menu into file menupopup
         * ```ts
         * ztoolkit.Menu.register(
         *   "menuFile",
         *   {
         *     tag: "menu",
         *     label: "Addon Template: Menupopup",
         *     subElementOptions: [
         *       {
         *         tag: "menuitem",
         *         label: "Addon Template",
         *         oncommand: "alert('Hello World! Sub Menuitem.')",
         *       },
         *     ],
         *   },
         *   "before",
         *   Zotero.getMainWindow().document.querySelector(
         *     "#zotero-itemmenu-addontemplate-test"
         *   )
         * );
         * ```
         */
        register(menuPopup, options, insertPosition = "after", anchorElement) {
          let popup;
          if (typeof menuPopup === "string") {
            popup = this.getGlobal("document").querySelector(MenuSelector[menuPopup]);
          } else {
            popup = menuPopup;
          }
          if (!popup) {
            return false;
          }
          const doc = popup.ownerDocument;
          const generateElementOptions = (menuitemOption) => {
            var _a;
            const elementOption = {
              tag: menuitemOption.tag,
              id: menuitemOption.id,
              namespace: "xul",
              attributes: {
                label: menuitemOption.label || "",
                hidden: Boolean(menuitemOption.hidden),
                disaled: Boolean(menuitemOption.disabled),
                class: menuitemOption.class || "",
                oncommand: menuitemOption.oncommand || ""
              },
              classList: menuitemOption.classList,
              styles: menuitemOption.styles || {},
              listeners: [],
              children: []
            };
            if (menuitemOption.icon) {
              if (!this.getGlobal("Zotero").isMac) {
                if (menuitemOption.tag === "menu") {
                  elementOption.attributes["class"] += " menu-iconic";
                } else {
                  elementOption.attributes["class"] += " menuitem-iconic";
                }
              }
              elementOption.styles["list-style-image"] = `url(${menuitemOption.icon})`;
            }
            if (menuitemOption.tag === "menu") {
              elementOption.children.push({
                tag: "menupopup",
                id: menuitemOption.popupId,
                attributes: { onpopupshowing: menuitemOption.onpopupshowing || "" },
                children: (menuitemOption.children || menuitemOption.subElementOptions || []).map(generateElementOptions)
              });
            }
            if (menuitemOption.commandListener) {
              (_a = elementOption.listeners) === null || _a === void 0 ? void 0 : _a.push({
                type: "command",
                listener: menuitemOption.commandListener
              });
            }
            return elementOption;
          };
          const props = generateElementOptions(options);
          const menuItem = this.ui.createElement(doc, options.tag, props);
          if (!anchorElement) {
            anchorElement = insertPosition === "after" ? popup.lastElementChild : popup.firstElementChild;
          }
          anchorElement[insertPosition](menuItem);
          if (options.getVisibility) {
            popup.addEventListener("popupshowing", (ev) => {
              const showing = options.getVisibility(menuItem, ev);
              if (showing) {
                menuItem.removeAttribute("hidden");
              } else {
                menuItem.setAttribute("hidden", "true");
              }
            });
          }
        }
        unregister(menuId) {
          var _a;
          (_a = this.getGlobal("document").querySelector(`#${menuId}`)) === null || _a === void 0 ? void 0 : _a.remove();
        }
        unregisterAll() {
          this.ui.unregisterAll();
        }
      };
      exports.MenuManager = MenuManager;
      var MenuSelector;
      (function(MenuSelector2) {
        MenuSelector2["menuFile"] = "#menu_FilePopup";
        MenuSelector2["menuEdit"] = "#menu_EditPopup";
        MenuSelector2["menuView"] = "#menu_viewPopup";
        MenuSelector2["menuGo"] = "#menu_goPopup";
        MenuSelector2["menuTools"] = "#menu_ToolsPopup";
        MenuSelector2["menuHelp"] = "#menu_HelpPopup";
        MenuSelector2["collection"] = "#zotero-collectionmenu";
        MenuSelector2["item"] = "#zotero-itemmenu";
      })(MenuSelector || (MenuSelector = {}));
    }
  });

  // node_modules/zotero-plugin-toolkit/dist/managers/preferencePane.js
  var require_preferencePane = __commonJS({
    "node_modules/zotero-plugin-toolkit/dist/managers/preferencePane.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PreferencePaneManager = void 0;
      var ui_1 = require_ui();
      var basic_1 = require_basic();
      var PreferencePaneManager = class extends basic_1.ManagerTool {
        constructor(base) {
          super(base);
          this.alive = true;
          this.ui = new ui_1.UITool(this);
          this.prefPaneCache = { win: void 0, listeners: {} };
        }
        /**
         * Register a preference pane from an xhtml, for Zotero 6 & 7.
         * @remarks
         * Don't forget to call `unregisterPrefPane` on exit.
         * @remarks
         * options:
         * ```ts
         * export interface PrefPaneOptions {
         *   pluginID: string;
         *   src: string;
         *   id?: string;
         *   parent?: string;
         *   label?: string;
         *   image?: string;
         *   extraDTD?: string[];
         *   scripts?: string[];
         *   defaultXUL?: boolean;
         *   // Only for Zotero 6
         *   onload?: (win: Window) => any;
         * }
         * ```
         *
         * @param options See {@link PrefPaneOptions}
         * @example
         * ```ts
         * const prefsManager = new PreferencePaneManager();
         * function initPrefs() {
         *   const prefOptions = {
         *     pluginID: addonID,
         *     src: rootURI + "chrome/content/preferences.xhtml",
         *     label: "Template",
         *     image: `chrome://${addonRef}/content/icons/favicon.png`,
         *     extraDTD: [`chrome://${addonRef}/locale/overlay.dtd`],
         *     defaultXUL: true
         *   };
         *   prefsManager.register(prefOptions);
         * };
         *
         * function unInitPrefs() {
         *   prefsManager.unregisterAll();
         * };
         * ```
         * // bootstrap.js:startup
         * initPrefs();
         *
         * // bootstrap.js:shutdown
         * unInitPrefs();
         */
        register(options) {
          if (this.isZotero7()) {
            this.getGlobal("Zotero").PreferencePanes.register(options);
            return;
          }
          const _initImportedNodesPostInsert = (container) => {
            var _a;
            const _observerSymbols = /* @__PURE__ */ new Map();
            const Zotero2 = this.getGlobal("Zotero");
            const window2 = container.ownerGlobal;
            let useChecked = (elem) => elem instanceof window2.HTMLInputElement && elem.type == "checkbox" || elem.tagName == "checkbox";
            let syncFromPref = (elem, preference) => {
              let value = Zotero2.Prefs.get(preference, true);
              if (useChecked(elem)) {
                elem.checked = value;
              } else {
                elem.value = value;
              }
              elem.dispatchEvent(new window2.Event("syncfrompreference"));
            };
            let syncToPrefOnModify = (event) => {
              const targetNode = event.currentTarget;
              if (targetNode === null || targetNode === void 0 ? void 0 : targetNode.getAttribute("preference")) {
                let value = useChecked(targetNode) ? targetNode.checked : targetNode.value;
                Zotero2.Prefs.set(targetNode.getAttribute("preference") || "", value, true);
                targetNode.dispatchEvent(new window2.Event("synctopreference"));
              }
            };
            let attachToPreference = (elem, preference) => {
              Zotero2.debug(`Attaching <${elem.tagName}> element to ${preference}`);
              let symbol = Zotero2.Prefs.registerObserver(preference, () => syncFromPref(elem, preference), true);
              _observerSymbols.set(elem, symbol);
            };
            let detachFromPreference = (elem) => {
              if (_observerSymbols.has(elem)) {
                Zotero2.debug(`Detaching <${elem.tagName}> element from preference`);
                Zotero2.Prefs.unregisterObserver(this._observerSymbols.get(elem));
                _observerSymbols.delete(elem);
              }
            };
            for (let elem of Array.from(container.querySelectorAll("[preference]"))) {
              let preference = elem.getAttribute("preference");
              if (container.querySelector("preferences > preference#" + preference)) {
                this.log("<preference> is deprecated -- `preference` attribute values should be full preference keys, not <preference> IDs");
                preference = (_a = container.querySelector("preferences > preference#" + preference)) === null || _a === void 0 ? void 0 : _a.getAttribute("name");
              }
              attachToPreference(elem, preference);
              elem.addEventListener(this.isXULElement(elem) ? "command" : "input", syncToPrefOnModify);
              window2.setTimeout(() => {
                syncFromPref(elem, preference);
              });
            }
            new window2.MutationObserver((mutations) => {
              for (let mutation of mutations) {
                if (mutation.type == "attributes") {
                  let target = mutation.target;
                  detachFromPreference(target);
                  if (target.hasAttribute("preference")) {
                    attachToPreference(target, target.getAttribute("preference") || "");
                    target.addEventListener(this.isXULElement(target) ? "command" : "input", syncToPrefOnModify);
                  }
                } else if (mutation.type == "childList") {
                  for (let node of Array.from(mutation.removedNodes)) {
                    detachFromPreference(node);
                  }
                  for (let node of Array.from(mutation.addedNodes)) {
                    if (node.nodeType == window2.Node.ELEMENT_NODE && node.hasAttribute("preference")) {
                      attachToPreference(node, node.getAttribute("preference") || "");
                      node.addEventListener(this.isXULElement(node) ? "command" : "input", syncToPrefOnModify);
                    }
                  }
                }
              }
            }).observe(container, {
              childList: true,
              subtree: true,
              attributeFilter: ["preference"]
            });
            for (let elem of Array.from(container.querySelectorAll("[oncommand]"))) {
              elem.oncommand = elem.getAttribute("oncommand");
            }
            for (let child of Array.from(container.children)) {
              child.dispatchEvent(new window2.Event("load"));
            }
          };
          const windowListener = {
            onOpenWindow: (xulWindow) => {
              if (!this.alive) {
                return;
              }
              const win = xulWindow.QueryInterface(Components.interfaces.nsIInterfaceRequestor).getInterface(Components.interfaces.nsIDOMWindow);
              win.addEventListener("load", async () => {
                var _a;
                if (win.location.href === "chrome://zotero/content/preferences/preferences.xul") {
                  this.log("registerPrefPane:detected", options);
                  const Zotero2 = this.getGlobal("Zotero");
                  options.id || (options.id = `plugin-${Zotero2.Utilities.randomString()}-${(/* @__PURE__ */ new Date()).getTime()}`);
                  const contentOrXHR = await Zotero2.File.getContentsAsync(options.src);
                  const content = typeof contentOrXHR === "string" ? contentOrXHR : contentOrXHR.response;
                  const src = `<prefpane xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul" id="${options.id}" insertafter="zotero-prefpane-advanced" label="${options.label || options.pluginID}" image="${options.image || ""}">
                ${content}
                </prefpane>`;
                  const frag = this.ui.parseXHTMLToFragment(src, options.extraDTD, options.defaultXUL);
                  this.log(frag);
                  const prefWindow = win.document.querySelector("prefwindow");
                  prefWindow.appendChild(frag);
                  const prefPane = win.document.querySelector(`#${options.id}`);
                  prefWindow.addPane(prefPane);
                  const contentBox = win.document.getAnonymousNodes(win.document.querySelector(`#${options.id}`))[0];
                  contentBox.style.overflowY = "scroll";
                  contentBox.style.height = "440px";
                  win.sizeToContent();
                  if (contentBox.scrollHeight === contentBox.clientHeight) {
                    contentBox.style.overflowY = "hidden";
                  }
                  this.prefPaneCache.win = win;
                  this.prefPaneCache.listeners[options.id] = windowListener;
                  _initImportedNodesPostInsert(prefPane);
                  if ((_a = options.scripts) === null || _a === void 0 ? void 0 : _a.length) {
                    options.scripts.forEach((script) => Services.scriptloader.loadSubScript(script, win));
                  }
                  if (options.onload) {
                    options.onload(win);
                  }
                }
              }, false);
            }
          };
          Services.wm.addListener(windowListener);
        }
        unregister(id) {
          var _a;
          const idx = Object.keys(this.prefPaneCache.listeners).indexOf(id);
          if (idx < 0) {
            return false;
          }
          const listener = this.prefPaneCache.listeners[id];
          Services.wm.removeListener(listener);
          listener.onOpenWindow = void 0;
          const win = this.prefPaneCache.win;
          if (win && !win.closed) {
            (_a = win.document.querySelector(`#${id}`)) === null || _a === void 0 ? void 0 : _a.remove();
          }
          delete this.prefPaneCache.listeners[id];
          return true;
        }
        /**
         * Unregister all preference panes added with this instance
         *
         * Called on exiting
         */
        unregisterAll() {
          this.alive = false;
          for (const id in this.prefPaneCache.listeners) {
            this.unregister(id);
          }
        }
      };
      exports.PreferencePaneManager = PreferencePaneManager;
    }
  });

  // node_modules/zotero-plugin-toolkit/dist/managers/shortcut.js
  var require_shortcut = __commonJS({
    "node_modules/zotero-plugin-toolkit/dist/managers/shortcut.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ShortcutManager = void 0;
      var basic_1 = require_basic();
      var ui_1 = require_ui();
      var basic_2 = require_basic();
      var toolkitGlobal_1 = __importDefault(require_toolkitGlobal());
      var ShortcutManager = class extends basic_2.ManagerTool {
        constructor(base) {
          super(base);
          this.ui = new ui_1.UITool(this);
          this.creatorId = `${Zotero.Utilities.randomString()}-${(/* @__PURE__ */ new Date()).getTime()}`;
          this.initializeGlobal();
        }
        register(type, keyOptions) {
          const _keyOptions = keyOptions;
          _keyOptions.type = type;
          switch (_keyOptions.type) {
            case "event":
              this.registerEventKey(_keyOptions);
              return true;
            case "element":
              this.registerElementKey(_keyOptions);
              return true;
            case "prefs":
              this.getGlobal("Zotero").Prefs.set(_keyOptions.id, _keyOptions.key || "");
              return true;
            default:
              try {
                if (_keyOptions.register) {
                  return _keyOptions.register(_keyOptions);
                } else {
                  return false;
                }
              } catch (e) {
                this.log(e);
                return false;
              }
          }
        }
        /**
         * Get all shortcuts(element, event, prefs, builtin)
         */
        getAll() {
          return Array.prototype.concat(this.getMainWindowElementKeys(), this.getEventKeys(), this.getPrefsKeys(), this.getBuiltinKeys());
        }
        /**
         * Check key conflicting of `inputKeyOptions`.
         * @param inputKeyOptions
         * @param options
         * @returns conflicting keys array
         */
        checkKeyConflicting(inputKeyOptions, options = { includeEmpty: false, customKeys: [] }) {
          var _a;
          inputKeyOptions.modifiers = new KeyModifier(inputKeyOptions.modifiers || "").getRaw();
          let allKeys = this.getAll();
          if ((_a = options.customKeys) === null || _a === void 0 ? void 0 : _a.length) {
            allKeys = allKeys.concat(options.customKeys);
          }
          if (!options.includeEmpty) {
            allKeys = allKeys.filter((_keyOptions) => _keyOptions.key);
          }
          return allKeys.filter((_keyOptions) => {
            var _a2, _b;
            return _keyOptions.id !== inputKeyOptions.id && ((_a2 = _keyOptions.key) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase()) === ((_b = inputKeyOptions.key) === null || _b === void 0 ? void 0 : _b.toLowerCase()) && _keyOptions.modifiers === inputKeyOptions.modifiers;
          });
        }
        /**
         * Find all key conflicting.
         * @param options
         * @returns An array of conflicting keys arrays. Same conflicting keys are put together.
         */
        checkAllKeyConflicting(options = { includeEmpty: false, customKeys: [] }) {
          var _a;
          let allKeys = this.getAll();
          if ((_a = options.customKeys) === null || _a === void 0 ? void 0 : _a.length) {
            allKeys = allKeys.concat(options.customKeys);
          }
          if (!options.includeEmpty) {
            allKeys = allKeys.filter((_keyOptions) => _keyOptions.key);
          }
          const conflicting = [];
          while (allKeys.length > 0) {
            const checkKey = allKeys.pop();
            const conflictKeys = allKeys.filter((_keyOptions) => {
              var _a2, _b;
              return ((_a2 = _keyOptions.key) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase()) === ((_b = checkKey.key) === null || _b === void 0 ? void 0 : _b.toLowerCase()) && _keyOptions.modifiers === checkKey.modifiers;
            });
            if (conflictKeys.length) {
              conflictKeys.push(checkKey);
              conflicting.push(conflictKeys);
              const conflictingKeyIds = conflictKeys.map((key) => key.id);
              const toRemoveIds = [];
              allKeys.forEach((key, i) => conflictingKeyIds.includes(key.id) && toRemoveIds.push(i));
              toRemoveIds.sort((a, b) => b - a).forEach((id) => allKeys.splice(id, 1));
            }
          }
          return conflicting;
        }
        /**
         * Unregister a key.
         * @remarks
         * `builtin` keys cannot be unregistered.
         * @param keyOptions
         * @returns `true` for success and `false` for failure.
         */
        async unregister(keyOptions) {
          var _a;
          switch (keyOptions.type) {
            case "element":
              (_a = (keyOptions.xulData.document || this.getGlobal("document")).querySelector(`#${keyOptions.id}`)) === null || _a === void 0 ? void 0 : _a.remove();
              return true;
            case "prefs":
              this.getGlobal("Zotero").Prefs.set(keyOptions.id, "");
              return true;
            case "builtin":
              return false;
            case "event":
              let idx = this.globalCache.eventKeys.findIndex((currentKey) => currentKey.id === keyOptions.id);
              while (idx >= 0) {
                this.globalCache.eventKeys.splice(idx, 1);
                idx = this.globalCache.eventKeys.findIndex((currentKey) => currentKey.id === keyOptions.id);
              }
              return true;
            default:
              try {
                if (keyOptions.unregister) {
                  return await keyOptions.unregister(keyOptions);
                } else {
                  return false;
                }
              } catch (e) {
                this.log(e);
                return false;
              }
          }
        }
        /**
         * Unregister all keys created by this instance.
         */
        unregisterAll() {
          this.ui.unregisterAll();
          this.globalCache.eventKeys.filter((keyOptions) => keyOptions.creatorId === this.creatorId).forEach((keyOptions) => this.unregister(keyOptions));
        }
        initializeGlobal() {
          const Zotero2 = this.getGlobal("Zotero");
          const window2 = this.getGlobal("window");
          this.globalCache = toolkitGlobal_1.default.getInstance().shortcut;
          if (!this.globalCache._ready) {
            this.globalCache._ready = true;
            window2.addEventListener("keypress", (event) => {
              let eventMods = [];
              let eventModsWithAccel = [];
              if (event.altKey) {
                eventMods.push("alt");
                eventModsWithAccel.push("alt");
              }
              if (event.shiftKey) {
                eventMods.push("shift");
                eventModsWithAccel.push("shift");
              }
              if (event.metaKey) {
                eventMods.push("meta");
                Zotero2.isMac && eventModsWithAccel.push("accel");
              }
              if (event.ctrlKey) {
                eventMods.push("control");
                !Zotero2.isMac && eventModsWithAccel.push("accel");
              }
              const eventModStr = new KeyModifier(eventMods.join(",")).getRaw();
              const eventModStrWithAccel = new KeyModifier(eventMods.join(",")).getRaw();
              this.globalCache.eventKeys.forEach((keyOptions) => {
                var _a;
                if (keyOptions.disabled) {
                  return;
                }
                const modStr = new KeyModifier(keyOptions.modifiers || "").getRaw();
                if ((modStr === eventModStr || modStr === eventModStrWithAccel) && ((_a = keyOptions.key) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === event.key.toLowerCase()) {
                  keyOptions.callback();
                }
              });
            });
          }
        }
        registerEventKey(keyOptions) {
          keyOptions.creatorId = this.creatorId;
          this.globalCache.eventKeys.push(keyOptions);
        }
        /**
         * Register Element \<commandset\>. In general, use `registerElementKey` or `registerKey`.
         * @param commandSetOptions
         */
        registerElementCommandset(commandSetOptions) {
          var _a;
          (_a = commandSetOptions.document.querySelector("window")) === null || _a === void 0 ? void 0 : _a.appendChild(this.ui.createElement(commandSetOptions.document, "commandset", {
            id: commandSetOptions.id,
            skipIfExists: true,
            children: commandSetOptions.commands.map((cmd) => ({
              tag: "command",
              id: cmd.id,
              attributes: {
                oncommand: cmd.oncommand,
                disabled: cmd.disabled,
                label: cmd.label
              }
            }))
          }));
        }
        /**
         * Register Element \<command\>. In general, use `registerElementKey` or `registerKey`.
         * @param commandOptions
         */
        registerElementCommand(commandOptions) {
          var _a;
          if (commandOptions._parentId) {
            this.registerElementCommandset({
              id: commandOptions._parentId,
              document: commandOptions.document,
              commands: []
            });
          }
          (_a = commandOptions.document.querySelector(`commandset#${commandOptions._parentId}`)) === null || _a === void 0 ? void 0 : _a.appendChild(this.ui.createElement(commandOptions.document, "command", {
            id: commandOptions.id,
            skipIfExists: true,
            attributes: {
              oncommand: commandOptions.oncommand,
              disabled: commandOptions.disabled,
              label: commandOptions.label
            }
          }));
        }
        /**
         * Register Element \<keyset\>. In general, use `registerElementKey` or `registerKey`.
         * @param keySetOptions
         */
        registerElementKeyset(keySetOptions) {
          var _a;
          (_a = keySetOptions.document.querySelector("window")) === null || _a === void 0 ? void 0 : _a.appendChild(this.ui.createElement(keySetOptions.document, "keyset", {
            id: keySetOptions.id,
            skipIfExists: true,
            children: keySetOptions.keys.map((keyOptions) => ({
              tag: "key",
              id: keyOptions.id,
              attributes: {
                oncommand: keyOptions.xulData.oncommand || "//",
                command: keyOptions.xulData.command,
                modifiers: keyOptions.modifiers,
                key: this.getXULKey(keyOptions.key),
                keycode: this.getXULKeyCode(keyOptions.key),
                disabled: keyOptions.disabled
              }
            }))
          }));
        }
        /**
         * Register a shortcut key element \<key\>.
         * @remarks
         * Provide `_parentId` to register a \<keyset\>;
         *
         * Provide `_commandOptions` to register a \<command\>;
         *
         * Provide `_parentId` in `_commandOptions` to register a \<commandset\>.
         *
         * See examples for more details.
         * @param keyOptions
         * @example
         */
        registerElementKey(keyOptions) {
          var _a;
          const doc = keyOptions.xulData.document || this.getGlobal("document");
          if (keyOptions.xulData._parentId) {
            this.registerElementKeyset({
              id: keyOptions.xulData._parentId,
              document: doc,
              keys: []
            });
          }
          (_a = doc.querySelector(`keyset#${keyOptions.xulData._parentId}`)) === null || _a === void 0 ? void 0 : _a.appendChild(this.ui.createElement(doc, "key", {
            id: keyOptions.id,
            skipIfExists: true,
            attributes: {
              oncommand: keyOptions.xulData.oncommand || "//",
              command: keyOptions.xulData.command,
              modifiers: keyOptions.modifiers,
              key: this.getXULKey(keyOptions.key),
              keycode: this.getXULKeyCode(keyOptions.key),
              disabled: keyOptions.disabled
            }
          }));
          if (keyOptions.xulData._commandOptions) {
            this.registerElementCommand(keyOptions.xulData._commandOptions);
          }
        }
        getXULKey(standardKey) {
          if (standardKey.length === 1) {
            return standardKey;
          }
          return void 0;
        }
        getXULKeyCode(standardKey) {
          const idx = Object.values(XUL_KEYCODE_MAPS).findIndex((value) => value === standardKey);
          if (idx >= 0) {
            return Object.values(XUL_KEYCODE_MAPS)[idx];
          }
          return void 0;
        }
        getStandardKey(XULKey, XULKeyCode) {
          if (XULKeyCode && Object.keys(XUL_KEYCODE_MAPS).includes(XULKeyCode)) {
            return XUL_KEYCODE_MAPS[XULKeyCode];
          } else {
            return XULKey;
          }
        }
        /**
         * Get all \<commandset\> details.
         * @param doc
         */
        getElementCommandSets(doc) {
          return Array.from((doc || this.getGlobal("document")).querySelectorAll("commandset")).map((cmdSet) => ({
            id: cmdSet.id,
            commands: Array.from(cmdSet.querySelectorAll("command")).map((cmd) => ({
              id: cmd.id,
              oncommand: cmd.getAttribute("oncommand"),
              disabled: cmd.getAttribute("disabled") === "true",
              label: cmd.getAttribute("label"),
              _parentId: cmdSet.id
            }))
          }));
        }
        /**
         * Get all \<command\> details.
         * @param doc
         */
        getElementCommands(doc) {
          return Array.prototype.concat(...this.getElementCommandSets(doc).map((cmdSet) => cmdSet.commands));
        }
        /**
         * Get all \<keyset\> details.
         * @param doc
         * @param options
         */
        getElementKeySets(doc) {
          let allCommends = this.getElementCommands(doc);
          return Array.from((doc || this.getGlobal("document")).querySelectorAll("keyset")).map((keysetElem) => ({
            id: keysetElem.id,
            document: doc,
            keys: Array.from(keysetElem.querySelectorAll("key")).map((keyElem) => {
              const oncommand = keyElem.getAttribute("oncommand") || "";
              const commandId = keyElem.getAttribute("command") || "";
              const commandOptions = allCommends.find((cmd) => cmd.id === commandId);
              const key = {
                type: "element",
                id: keyElem.id,
                key: this.getStandardKey(keyElem.getAttribute("key") || "", keyElem.getAttribute("keycode") || ""),
                modifiers: new KeyModifier(keyElem.getAttribute("modifiers") || "").getRaw(),
                disabled: keyElem.getAttribute("disabled") === "true",
                xulData: {
                  document: doc,
                  oncommand,
                  command: commandId,
                  _parentId: keysetElem.id,
                  _commandOptions: commandOptions
                },
                callback: () => {
                  const win = doc.ownerGlobal;
                  const _eval = win.eval;
                  _eval(oncommand);
                  _eval((commandOptions === null || commandOptions === void 0 ? void 0 : commandOptions.oncommand) || "");
                }
              };
              return key;
            })
          }));
        }
        /**
         * Get all \<key\> details.
         * @param doc
         * @param options
         */
        getElementKeys(doc) {
          return Array.prototype.concat(...this.getElementKeySets(doc).map((keyset) => keyset.keys)).filter((elemKey) => !ELEM_KEY_IGNORE.includes(elemKey.id));
        }
        /**
         * Get \<key\> details in main window.
         * @param options
         */
        getMainWindowElementKeys() {
          return this.getElementKeys(this.getGlobal("document"));
        }
        getEventKeys() {
          return this.globalCache.eventKeys;
        }
        /**
         * Get Zotero builtin keys defined in preferences.
         */
        getPrefsKeys() {
          const Zotero2 = this.getGlobal("Zotero");
          return PREF_KEYS.map((pref) => ({
            id: pref.id,
            modifiers: pref.modifiers,
            key: Zotero2.Prefs.get(pref.id),
            callback: pref.callback,
            type: "prefs"
          }));
        }
        /**
         * Get Zotero builtin keys not defined in preferences.
         */
        getBuiltinKeys() {
          return BUILTIN_KEYS.map((builtin) => ({
            id: builtin.id,
            modifiers: builtin.modifiers,
            key: builtin.key,
            callback: builtin.callback,
            type: "builtin"
          }));
        }
      };
      exports.ShortcutManager = ShortcutManager;
      var KeyModifier = class {
        constructor(raw) {
          raw = raw || "";
          this.accel = raw.includes("accel");
          this.shift = raw.includes("shift");
          this.control = raw.includes("control");
          this.meta = raw.includes("meta");
          this.alt = raw.includes("alt");
        }
        equals(newMod) {
          this.accel === newMod.accel;
          this.shift === newMod.shift;
          this.control === newMod.control;
          this.meta === newMod.meta;
          this.alt === newMod.alt;
        }
        getRaw() {
          const enabled = [];
          this.accel && enabled.push("accel");
          this.shift && enabled.push("shift");
          this.control && enabled.push("control");
          this.meta && enabled.push("meta");
          this.alt && enabled.push("alt");
          return enabled.join(",");
        }
      };
      var XUL_KEYCODE_MAPS;
      (function(XUL_KEYCODE_MAPS2) {
        XUL_KEYCODE_MAPS2["VK_CANCEL"] = "Unidentified";
        XUL_KEYCODE_MAPS2["VK_BACK"] = "Backspace";
        XUL_KEYCODE_MAPS2["VK_TAB"] = "Tab";
        XUL_KEYCODE_MAPS2["VK_CLEAR"] = "Clear";
        XUL_KEYCODE_MAPS2["VK_RETURN"] = "Enter";
        XUL_KEYCODE_MAPS2["VK_ENTER"] = "Enter";
        XUL_KEYCODE_MAPS2["VK_SHIFT"] = "Shift";
        XUL_KEYCODE_MAPS2["VK_CONTROL"] = "Control";
        XUL_KEYCODE_MAPS2["VK_ALT"] = "Alt";
        XUL_KEYCODE_MAPS2["VK_PAUSE"] = "Pause";
        XUL_KEYCODE_MAPS2["VK_CAPS_LOCK"] = "CapsLock";
        XUL_KEYCODE_MAPS2["VK_ESCAPE"] = "Escape";
        XUL_KEYCODE_MAPS2["VK_SPACE"] = " ";
        XUL_KEYCODE_MAPS2["VK_PAGE_UP"] = "PageUp";
        XUL_KEYCODE_MAPS2["VK_PAGE_DOWN"] = "PageDown";
        XUL_KEYCODE_MAPS2["VK_END"] = "End";
        XUL_KEYCODE_MAPS2["VK_HOME"] = "Home";
        XUL_KEYCODE_MAPS2["VK_LEFT"] = "ArrowLeft";
        XUL_KEYCODE_MAPS2["VK_UP"] = "ArrowUp";
        XUL_KEYCODE_MAPS2["VK_RIGHT"] = "ArrowRight";
        XUL_KEYCODE_MAPS2["VK_DOWN"] = "ArrowDown";
        XUL_KEYCODE_MAPS2["VK_PRINTSCREEN"] = "PrintScreen";
        XUL_KEYCODE_MAPS2["VK_INSERT"] = "Insert";
        XUL_KEYCODE_MAPS2["VK_DELETE"] = "Backspace";
        XUL_KEYCODE_MAPS2["VK_0"] = "0";
        XUL_KEYCODE_MAPS2["VK_1"] = "1";
        XUL_KEYCODE_MAPS2["VK_2"] = "2";
        XUL_KEYCODE_MAPS2["VK_3"] = "3";
        XUL_KEYCODE_MAPS2["VK_4"] = "4";
        XUL_KEYCODE_MAPS2["VK_5"] = "5";
        XUL_KEYCODE_MAPS2["VK_6"] = "6";
        XUL_KEYCODE_MAPS2["VK_7"] = "7";
        XUL_KEYCODE_MAPS2["VK_8"] = "8";
        XUL_KEYCODE_MAPS2["VK_9"] = "9";
        XUL_KEYCODE_MAPS2["VK_A"] = "A";
        XUL_KEYCODE_MAPS2["VK_B"] = "B";
        XUL_KEYCODE_MAPS2["VK_C"] = "C";
        XUL_KEYCODE_MAPS2["VK_D"] = "D";
        XUL_KEYCODE_MAPS2["VK_E"] = "E";
        XUL_KEYCODE_MAPS2["VK_F"] = "F";
        XUL_KEYCODE_MAPS2["VK_G"] = "G";
        XUL_KEYCODE_MAPS2["VK_H"] = "H";
        XUL_KEYCODE_MAPS2["VK_I"] = "I";
        XUL_KEYCODE_MAPS2["VK_J"] = "J";
        XUL_KEYCODE_MAPS2["VK_K"] = "K";
        XUL_KEYCODE_MAPS2["VK_L"] = "L";
        XUL_KEYCODE_MAPS2["VK_M"] = "M";
        XUL_KEYCODE_MAPS2["VK_N"] = "N";
        XUL_KEYCODE_MAPS2["VK_O"] = "O";
        XUL_KEYCODE_MAPS2["VK_P"] = "P";
        XUL_KEYCODE_MAPS2["VK_Q"] = "Q";
        XUL_KEYCODE_MAPS2["VK_R"] = "R";
        XUL_KEYCODE_MAPS2["VK_S"] = "S";
        XUL_KEYCODE_MAPS2["VK_T"] = "T";
        XUL_KEYCODE_MAPS2["VK_U"] = "U";
        XUL_KEYCODE_MAPS2["VK_V"] = "V";
        XUL_KEYCODE_MAPS2["VK_W"] = "W";
        XUL_KEYCODE_MAPS2["VK_X"] = "X";
        XUL_KEYCODE_MAPS2["VK_Y"] = "Y";
        XUL_KEYCODE_MAPS2["VK_Z"] = "Z";
        XUL_KEYCODE_MAPS2["VK_SEMICOLON"] = "Unidentified";
        XUL_KEYCODE_MAPS2["VK_EQUALS"] = "Unidentified";
        XUL_KEYCODE_MAPS2["VK_NUMPAD0"] = "0";
        XUL_KEYCODE_MAPS2["VK_NUMPAD1"] = "1";
        XUL_KEYCODE_MAPS2["VK_NUMPAD2"] = "2";
        XUL_KEYCODE_MAPS2["VK_NUMPAD3"] = "3";
        XUL_KEYCODE_MAPS2["VK_NUMPAD4"] = "4";
        XUL_KEYCODE_MAPS2["VK_NUMPAD5"] = "5";
        XUL_KEYCODE_MAPS2["VK_NUMPAD6"] = "6";
        XUL_KEYCODE_MAPS2["VK_NUMPAD7"] = "7";
        XUL_KEYCODE_MAPS2["VK_NUMPAD8"] = "8";
        XUL_KEYCODE_MAPS2["VK_NUMPAD9"] = "9";
        XUL_KEYCODE_MAPS2["VK_MULTIPLY"] = "Multiply";
        XUL_KEYCODE_MAPS2["VK_ADD"] = "Add";
        XUL_KEYCODE_MAPS2["VK_SEPARATOR"] = "Separator";
        XUL_KEYCODE_MAPS2["VK_SUBTRACT"] = "Subtract";
        XUL_KEYCODE_MAPS2["VK_DECIMAL"] = "Decimal";
        XUL_KEYCODE_MAPS2["VK_DIVIDE"] = "Divide";
        XUL_KEYCODE_MAPS2["VK_F1"] = "F1";
        XUL_KEYCODE_MAPS2["VK_F2"] = "F2";
        XUL_KEYCODE_MAPS2["VK_F3"] = "F3";
        XUL_KEYCODE_MAPS2["VK_F4"] = "F4";
        XUL_KEYCODE_MAPS2["VK_F5"] = "F5";
        XUL_KEYCODE_MAPS2["VK_F6"] = "F6";
        XUL_KEYCODE_MAPS2["VK_F7"] = "F7";
        XUL_KEYCODE_MAPS2["VK_F8"] = "F8";
        XUL_KEYCODE_MAPS2["VK_F9"] = "F9";
        XUL_KEYCODE_MAPS2["VK_F10"] = "F10";
        XUL_KEYCODE_MAPS2["VK_F11"] = "F11";
        XUL_KEYCODE_MAPS2["VK_F12"] = "F12";
        XUL_KEYCODE_MAPS2["VK_F13"] = "F13";
        XUL_KEYCODE_MAPS2["VK_F14"] = "F14";
        XUL_KEYCODE_MAPS2["VK_F15"] = "F15";
        XUL_KEYCODE_MAPS2["VK_F16"] = "F16";
        XUL_KEYCODE_MAPS2["VK_F17"] = "F17";
        XUL_KEYCODE_MAPS2["VK_F18"] = "F18";
        XUL_KEYCODE_MAPS2["VK_F19"] = "F19";
        XUL_KEYCODE_MAPS2["VK_F20"] = "F20";
        XUL_KEYCODE_MAPS2["VK_F21"] = "Soft1";
        XUL_KEYCODE_MAPS2["VK_F22"] = "Soft2";
        XUL_KEYCODE_MAPS2["VK_F23"] = "Soft3";
        XUL_KEYCODE_MAPS2["VK_F24"] = "Soft4";
        XUL_KEYCODE_MAPS2["VK_NUM_LOCK"] = "NumLock";
        XUL_KEYCODE_MAPS2["VK_SCROLL_LOCK"] = "ScrollLock";
        XUL_KEYCODE_MAPS2["VK_COMMA"] = ",";
        XUL_KEYCODE_MAPS2["VK_PERIOD"] = ".";
        XUL_KEYCODE_MAPS2["VK_SLASH"] = "Divide";
        XUL_KEYCODE_MAPS2["VK_BACK_QUOTE"] = "`";
        XUL_KEYCODE_MAPS2["VK_OPEN_BRACKET"] = "[";
        XUL_KEYCODE_MAPS2["VK_CLOSE_BRACKET"] = "]";
        XUL_KEYCODE_MAPS2["VK_QUOTE"] = "\\";
        XUL_KEYCODE_MAPS2["VK_HELP"] = "Help";
      })(XUL_KEYCODE_MAPS || (XUL_KEYCODE_MAPS = {}));
      function getElementKeyCallback(keyId) {
        return function() {
          var _a;
          const win = basic_1.BasicTool.getZotero().getMainWindow();
          const keyElem = win.document.querySelector(`#${keyId}`);
          if (!keyElem) {
            return function() {
            };
          }
          const _eval = win.eval;
          _eval(keyElem.getAttribute("oncommand") || "//");
          const cmdId = keyElem.getAttribute("command");
          if (!cmdId) {
            return;
          }
          _eval(((_a = win.document.querySelector(`#${cmdId}`)) === null || _a === void 0 ? void 0 : _a.getAttribute("oncommand")) || "//");
        };
      }
      function getBuiltinEventKeyCallback(eventId) {
        return function() {
          const Zotero2 = basic_1.BasicTool.getZotero();
          const ZoteroPane2 = Zotero2.getActiveZoteroPane();
          ZoteroPane2.handleKeyPress({
            metaKey: true,
            ctrlKey: true,
            shiftKey: true,
            originalTarget: { id: "" },
            preventDefault: () => {
            },
            key: Zotero2.Prefs.get(`extensions.zotero.keys.${eventId}`, true)
          });
        };
      }
      var ELEM_KEY_IGNORE = ["key_copyCitation", "key_copyBibliography"];
      var PREF_KEYS = [
        {
          id: "extensions.zotero.keys.copySelectedItemCitationsToClipboard",
          modifiers: "accel,shift",
          elemId: "key_copyCitation",
          callback: getElementKeyCallback("key_copyCitation")
        },
        {
          id: "extensions.zotero.keys.copySelectedItemsToClipboard",
          modifiers: "accel,shift",
          elemId: "key_copyBibliography",
          callback: getElementKeyCallback("key_copyBibliography")
        },
        {
          id: "extensions.zotero.keys.library",
          modifiers: "accel,shift",
          callback: getBuiltinEventKeyCallback("library")
        },
        {
          id: "extensions.zotero.keys.newItem",
          modifiers: "accel,shift",
          callback: getBuiltinEventKeyCallback("newItem")
        },
        {
          id: "extensions.zotero.keys.newNote",
          modifiers: "accel,shift",
          callback: getBuiltinEventKeyCallback("newNote")
        },
        {
          id: "extensions.zotero.keys.quicksearch",
          modifiers: "accel,shift",
          callback: getBuiltinEventKeyCallback("quicksearch")
        },
        {
          id: "extensions.zotero.keys.saveToZotero",
          modifiers: "accel,shift",
          callback: getBuiltinEventKeyCallback("saveToZotero")
        },
        {
          id: "extensions.zotero.keys.sync",
          modifiers: "accel,shift",
          callback: getBuiltinEventKeyCallback("sync")
        },
        {
          id: "extensions.zotero.keys.toggleAllRead",
          modifiers: "accel,shift",
          callback: getBuiltinEventKeyCallback("toggleAllRead")
        },
        {
          id: "extensions.zotero.keys.toggleRead",
          modifiers: "accel,shift",
          callback: getBuiltinEventKeyCallback("toggleRead")
        }
      ];
      var BUILTIN_KEYS = [
        {
          id: "showItemCollection",
          modifiers: "",
          key: "Ctrl",
          callback: () => {
            const Zotero2 = basic_1.BasicTool.getZotero();
            const ZoteroPane2 = Zotero2.getActiveZoteroPane();
            ZoteroPane2.handleKeyUp({
              originalTarget: { id: ZoteroPane2.itemsView.id },
              keyCode: Zotero2.isWin ? 17 : 18
            });
          }
        },
        {
          id: "closeSelectedTab",
          modifiers: "accel",
          key: "W",
          callback: () => {
            const ztabs = basic_1.BasicTool.getZotero().getMainWindow().Zotero_Tabs;
            if (ztabs.selectedIndex > 0) {
              ztabs.close("");
            }
          }
        },
        {
          id: "undoCloseTab",
          modifiers: "accel,shift",
          key: "T",
          callback: () => {
            const ztabs = basic_1.BasicTool.getZotero().getMainWindow().Zotero_Tabs;
            ztabs.undoClose();
          }
        },
        {
          id: "selectNextTab",
          modifiers: "control",
          key: "Tab",
          callback: () => {
            const ztabs = basic_1.BasicTool.getZotero().getMainWindow().Zotero_Tabs;
            ztabs.selectPrev();
          }
        },
        {
          id: "selectPreviousTab",
          modifiers: "control,shift",
          key: "Tab",
          callback: () => {
            const ztabs = basic_1.BasicTool.getZotero().getMainWindow().Zotero_Tabs;
            ztabs.selectNext();
          }
        },
        {
          id: "selectTab1",
          modifiers: "accel",
          key: "1",
          callback: () => {
            const ztabs = basic_1.BasicTool.getZotero().getMainWindow().Zotero_Tabs;
            ztabs.jump(0);
          }
        },
        {
          id: "selectTab2",
          modifiers: "accel",
          key: "2",
          callback: () => {
            const ztabs = basic_1.BasicTool.getZotero().getMainWindow().Zotero_Tabs;
            ztabs.jump(1);
          }
        },
        {
          id: "selectTab3",
          modifiers: "accel",
          key: "3",
          callback: () => {
            const ztabs = basic_1.BasicTool.getZotero().getMainWindow().Zotero_Tabs;
            ztabs.jump(2);
          }
        },
        {
          id: "selectTab4",
          modifiers: "accel",
          key: "4",
          callback: () => {
            const ztabs = basic_1.BasicTool.getZotero().getMainWindow().Zotero_Tabs;
            ztabs.jump(3);
          }
        },
        {
          id: "selectTab5",
          modifiers: "accel",
          key: "5",
          callback: () => {
            const ztabs = basic_1.BasicTool.getZotero().getMainWindow().Zotero_Tabs;
            ztabs.jump(4);
          }
        },
        {
          id: "selectTab6",
          modifiers: "accel",
          key: "6",
          callback: () => {
            const ztabs = basic_1.BasicTool.getZotero().getMainWindow().Zotero_Tabs;
            ztabs.jump(5);
          }
        },
        {
          id: "selectTab7",
          modifiers: "accel",
          key: "7",
          callback: () => {
            const ztabs = basic_1.BasicTool.getZotero().getMainWindow().Zotero_Tabs;
            ztabs.jump(6);
          }
        },
        {
          id: "selectTab8",
          modifiers: "accel",
          key: "8",
          callback: () => {
            const ztabs = basic_1.BasicTool.getZotero().getMainWindow().Zotero_Tabs;
            ztabs.jump(7);
          }
        },
        {
          id: "selectTabLast",
          modifiers: "accel",
          key: "9",
          callback: () => {
            const ztabs = basic_1.BasicTool.getZotero().getMainWindow().Zotero_Tabs;
            ztabs.selectLast();
          }
        }
      ];
    }
  });

  // node_modules/zotero-plugin-toolkit/dist/helpers/clipboard.js
  var require_clipboard = __commonJS({
    "node_modules/zotero-plugin-toolkit/dist/helpers/clipboard.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ClipboardHelper = void 0;
      var basic_1 = require_basic();
      var ClipboardHelper = class {
        constructor() {
          this.transferable = Components.classes["@mozilla.org/widget/transferable;1"].createInstance(Components.interfaces.nsITransferable);
          this.clipboardService = Components.classes["@mozilla.org/widget/clipboard;1"].getService(Components.interfaces.nsIClipboard);
          this.transferable.init(null);
        }
        addText(source, type) {
          const str = Components.classes["@mozilla.org/supports-string;1"].createInstance(Components.interfaces.nsISupportsString);
          str.data = source;
          this.transferable.addDataFlavor(type);
          this.transferable.setTransferData(type, str, source.length * 2);
          return this;
        }
        addImage(source) {
          let parts = source.split(",");
          if (!parts[0].includes("base64")) {
            return this;
          }
          const basicTool2 = new basic_1.BasicTool();
          let mime = parts[0].match(/:(.*?);/)[1];
          let bstr = basicTool2.getGlobal("window").atob(parts[1]);
          let n = bstr.length;
          let u8arr = new Uint8Array(n);
          while (n--) {
            u8arr[n] = bstr.charCodeAt(n);
          }
          let imgTools = Components.classes["@mozilla.org/image/tools;1"].getService(Components.interfaces.imgITools);
          let mimeType;
          let img;
          if (basicTool2.getGlobal("Zotero").platformMajorVersion >= 102) {
            img = imgTools.decodeImageFromArrayBuffer(u8arr.buffer, mime);
            mimeType = "application/x-moz-nativeimage";
          } else {
            mimeType = `image/png`;
            img = Components.classes["@mozilla.org/supports-interface-pointer;1"].createInstance(Components.interfaces.nsISupportsInterfacePointer);
            img.data = imgTools.decodeImageFromArrayBuffer(u8arr.buffer, mimeType);
          }
          this.transferable.addDataFlavor(mimeType);
          this.transferable.setTransferData(mimeType, img, 0);
          return this;
        }
        copy() {
          this.clipboardService.setData(this.transferable, null, Components.interfaces.nsIClipboard.kGlobalClipboard);
          return this;
        }
      };
      exports.ClipboardHelper = ClipboardHelper;
    }
  });

  // node_modules/zotero-plugin-toolkit/dist/helpers/filePicker.js
  var require_filePicker = __commonJS({
    "node_modules/zotero-plugin-toolkit/dist/helpers/filePicker.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FilePickerHelper = void 0;
      var basic_1 = require_basic();
      var FilePickerHelper = class {
        constructor(title, mode, filters, suggestion, window2, filterMask) {
          this.title = title;
          this.mode = mode;
          this.filters = filters;
          this.suggestion = suggestion;
          this.window = window2;
          this.filterMask = filterMask;
        }
        async open() {
          const basicTool2 = new basic_1.BasicTool();
          const backend = basicTool2.getGlobal("require")("zotero/modules/filePicker").default;
          const fp = new backend();
          fp.init(this.window || basicTool2.getGlobal("window"), this.title, this.getMode(fp));
          for (const [label, ext] of this.filters || []) {
            fp.appendFilter(label, ext);
          }
          if (this.filterMask)
            fp.appendFilters(this.getFilterMask(fp));
          if (this.suggestion)
            fp.defaultString = this.suggestion;
          const userChoice = await fp.show();
          switch (userChoice) {
            case fp.returnOK:
            case fp.returnReplace:
              return this.mode === "multiple" ? fp.files : fp.file;
            default:
              return false;
          }
        }
        getMode(fp) {
          switch (this.mode) {
            case "open":
              return fp.modeOpen;
            case "save":
              return fp.modeSave;
            case "folder":
              return fp.modeGetFolder;
            case "multiple":
              return fp.modeOpenMultiple;
            default:
              return 0;
          }
        }
        getFilterMask(fp) {
          switch (this.filterMask) {
            case "all":
              return fp.filterAll;
            case "html":
              return fp.filterHTML;
            case "text":
              return fp.filterText;
            case "images":
              return fp.filterImages;
            case "xml":
              return fp.filterXML;
            case "apps":
              return fp.filterApps;
            case "urls":
              return fp.filterAllowURLs;
            case "audio":
              return fp.filterAudio;
            case "video":
              return fp.filterVideo;
            default:
              return 1;
          }
        }
      };
      exports.FilePickerHelper = FilePickerHelper;
    }
  });

  // node_modules/zotero-plugin-toolkit/dist/helpers/progressWindow.js
  var require_progressWindow = __commonJS({
    "node_modules/zotero-plugin-toolkit/dist/helpers/progressWindow.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProgressWindowHelper = void 0;
      var basic_1 = require_basic();
      var ProgressWindowHelper = class extends Zotero.ProgressWindow {
        /**
         *
         * @param header window header
         * @param options
         */
        constructor(header, options = {
          closeOnClick: true,
          closeTime: 5e3
        }) {
          super(options);
          this.lines = [];
          this.closeTime = options.closeTime || 5e3;
          this.changeHeadline(header);
          this.originalShow = this.show;
          this.show = this.showWithTimer;
          if (options.closeOtherProgressWindows) {
            basic_1.BasicTool.getZotero().ProgressWindowSet.closeAll();
          }
        }
        /**
         * Create a new line
         * @param options
         */
        createLine(options) {
          const icon = this.getIcon(options.type, options.icon);
          const line = new this.ItemProgress(icon || "", options.text || "");
          if (typeof options.progress === "number") {
            line.setProgress(options.progress);
          }
          this.lines.push(line);
          return this;
        }
        /**
         * Change the line content
         * @param options
         */
        changeLine(options) {
          var _a;
          if (((_a = this.lines) === null || _a === void 0 ? void 0 : _a.length) === 0) {
            return this;
          }
          const idx = typeof options.idx !== "undefined" && options.idx >= 0 && options.idx < this.lines.length ? options.idx : 0;
          const icon = this.getIcon(options.type, options.icon);
          options.text && this.lines[idx].setText(options.text);
          icon && this.lines[idx].setIcon(icon);
          typeof options.progress === "number" && this.lines[idx].setProgress(options.progress);
          return this;
        }
        showWithTimer(closeTime = void 0) {
          this.originalShow();
          typeof closeTime !== "undefined" && (this.closeTime = closeTime);
          if (this.closeTime && this.closeTime > 0) {
            this.startCloseTimer(this.closeTime);
          }
          return this;
        }
        /**
         * Set custom icon uri for progress window
         * @param key
         * @param uri
         */
        static setIconURI(key, uri) {
          icons[key] = uri;
        }
        getIcon(type, defaultIcon) {
          return type && type in icons ? icons[type] : defaultIcon;
        }
      };
      exports.ProgressWindowHelper = ProgressWindowHelper;
      var icons = {
        success: "chrome://zotero/skin/tick.png",
        fail: "chrome://zotero/skin/cross.png"
      };
    }
  });

  // node_modules/zotero-plugin-toolkit/dist/helpers/virtualizedTable.js
  var require_virtualizedTable = __commonJS({
    "node_modules/zotero-plugin-toolkit/dist/helpers/virtualizedTable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.VirtualizedTableHelper = void 0;
      var basic_1 = require_basic();
      var VirtualizedTableHelper = class {
        constructor(win) {
          this.window = win;
          this.basicTool = new basic_1.BasicTool();
          const Zotero2 = this.basicTool.getGlobal("Zotero");
          const _require = win.require;
          this.React = _require("react");
          this.ReactDOM = _require("react-dom");
          this.VirtualizedTable = _require("components/virtualized-table");
          this.IntlProvider = _require("react-intl").IntlProvider;
          this.props = {
            id: `${Zotero2.Utilities.randomString()}-${(/* @__PURE__ */ new Date()).getTime()}`,
            getRowCount: () => 0
          };
          this.localeStrings = Zotero2.Intl.strings;
        }
        setProp(...args) {
          if (args.length === 1) {
            Object.assign(this.props, args[0]);
          } else if (args.length === 2) {
            this.props[args[0]] = args[1];
          }
          return this;
        }
        /**
         * Set locale strings, which replaces the table header's label if matches. Default it's `Zotero.Intl.strings`
         * @param localeStrings
         */
        setLocale(localeStrings) {
          Object.assign(this.localeStrings, localeStrings);
          return this;
        }
        /**
         * Set container element id that the table will be rendered on.
         * @param id element id
         */
        setContainerId(id) {
          this.containerId = id;
          return this;
        }
        /**
         * Render the table.
         * @param selectId Which row to select after rendering
         * @param onfulfilled callback after successfully rendered
         * @param onrejected callback after rendering with error
         */
        render(selectId, onfulfilled, onrejected) {
          const refreshSelection = () => {
            this.treeInstance.invalidate();
            if (typeof selectId !== "undefined" && selectId >= 0) {
              this.treeInstance.selection.select(selectId);
            } else {
              this.treeInstance.selection.clearSelection();
            }
          };
          if (!this.treeInstance) {
            const vtableProps = Object.assign({}, this.props, {
              ref: (ref) => this.treeInstance = ref
            });
            if (vtableProps.getRowData && !vtableProps.renderItem) {
              Object.assign(vtableProps, {
                renderItem: this.VirtualizedTable.makeRowRenderer(vtableProps.getRowData)
              });
            }
            const elem = this.React.createElement(this.IntlProvider, { locale: Zotero.locale, messages: Zotero.Intl.strings }, this.React.createElement(this.VirtualizedTable, vtableProps));
            const container = this.window.document.getElementById(this.containerId);
            new Promise((resolve) => this.ReactDOM.render(elem, container, resolve)).then(() => {
              this.basicTool.getGlobal("setTimeout")(() => {
                refreshSelection();
              });
            }).then(onfulfilled, onrejected);
          } else {
            refreshSelection();
          }
          return this;
        }
      };
      exports.VirtualizedTableHelper = VirtualizedTableHelper;
    }
  });

  // node_modules/zotero-plugin-toolkit/dist/helpers/dialog.js
  var require_dialog = __commonJS({
    "node_modules/zotero-plugin-toolkit/dist/helpers/dialog.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DialogHelper = void 0;
      var ui_1 = require_ui();
      var DialogHelper = class {
        /**
         * Create a dialog helper with row \* column grids.
         * @param row
         * @param column
         */
        constructor(row, column) {
          if (row <= 0 || column <= 0) {
            throw Error(`row and column must be positive integers.`);
          }
          this.elementProps = {
            tag: "vbox",
            attributes: { flex: 1 },
            styles: {
              width: "100%",
              height: "100%"
            },
            children: []
          };
          for (let i = 0; i < Math.max(row, 1); i++) {
            this.elementProps.children.push({
              tag: "hbox",
              attributes: { flex: 1 },
              children: []
            });
            for (let j = 0; j < Math.max(column, 1); j++) {
              this.elementProps.children[i].children.push({
                tag: "vbox",
                attributes: { flex: 1 },
                children: []
              });
            }
          }
          this.elementProps.children.push({
            tag: "hbox",
            attributes: { flex: 0, pack: "end" },
            children: []
          });
          this.dialogData = {};
        }
        /**
         * Add a cell at (row, column). Index starts from 0.
         * @param row
         * @param column
         * @param elementProps Cell element props. See {@link ElementProps}
         * @param cellFlex If the cell is flex. Default true.
         */
        addCell(row, column, elementProps, cellFlex = true) {
          if (row >= this.elementProps.children.length || column >= this.elementProps.children[row].children.length) {
            throw Error(`Cell index (${row}, ${column}) is invalid, maximum (${this.elementProps.children.length}, ${this.elementProps.children[0].children.length})`);
          }
          this.elementProps.children[row].children[column].children = [
            elementProps
          ];
          this.elementProps.children[row].children[column].attributes.flex = cellFlex ? 1 : 0;
          return this;
        }
        /**
         * Add a control button to the bottom of the dialog.
         * @param label Button label
         * @param id Button id.
         * The corresponding id of the last button user clicks before window exit will be set to `dialogData._lastButtonId`.
         * @param options.noClose Don't close window when clicking this button.
         * @param options.callback Callback of button click event.
         */
        addButton(label, id, options = {}) {
          id = id || `${Zotero.Utilities.randomString()}-${(/* @__PURE__ */ new Date()).getTime()}`;
          this.elementProps.children[this.elementProps.children.length - 1].children.push({
            tag: "vbox",
            styles: {
              margin: "10px"
            },
            children: [
              {
                tag: "button",
                namespace: "html",
                id,
                attributes: {
                  type: "button"
                },
                listeners: [
                  {
                    type: "click",
                    listener: (e) => {
                      this.dialogData._lastButtonId = id;
                      if (options.callback) {
                        options.callback(e);
                      }
                      if (!options.noClose) {
                        this.window.close();
                      }
                    }
                  }
                ],
                children: [
                  {
                    tag: "div",
                    styles: {
                      padding: "2.5px 15px"
                    },
                    properties: {
                      innerHTML: label
                    }
                  }
                ]
              }
            ]
          });
          return this;
        }
        /**
         * Dialog data.
         * @remarks
         * This object is passed to the dialog window.
         *
         * The control button id is in `dialogData._lastButtonId`;
         *
         * The data-binding values are in `dialogData`.
         * ```ts
         * interface DialogData {
         *   [key: string | number | symbol]: any;
         *   loadLock?: _ZoteroTypes.PromiseObject; // resolve after window load (auto-generated)
         *   loadCallback?: Function; // called after window load
         *   unloadLock?: _ZoteroTypes.PromiseObject; // resolve after window unload (auto-generated)
         *   unloadCallback?: Function; // called after window unload
         *   beforeUnloadCallback?: Function; // called before window unload when elements are accessable.
         * }
         * ```
         * @param dialogData
         */
        setDialogData(dialogData) {
          this.dialogData = dialogData;
          return this;
        }
        /**
         * Open the dialog
         * @param title Window title
         * @param windowFeatures.width Ignored if fitContent is `true`.
         * @param windowFeatures.height Ignored if fitContent is `true`.
         * @param windowFeatures.left
         * @param windowFeatures.top
         * @param windowFeatures.centerscreen Open window at the center of screen.
         * @param windowFeatures.resizable If window is resizable.
         * @param windowFeatures.fitContent Resize the window to content size after elements are loaded.
         * @param windowFeatures.noDialogMode Dialog mode window only has a close button. Set `true` to make maximize and minimize button visible.
         * @param windowFeatures.alwaysRaised Is the window always at the top.
         */
        open(title, windowFeatures = {
          centerscreen: true,
          resizable: true,
          fitContent: true
        }) {
          this.window = openDialog(`${Zotero.Utilities.randomString()}-${(/* @__PURE__ */ new Date()).getTime()}`, title, this.elementProps, this.dialogData, windowFeatures);
          return this;
        }
      };
      exports.DialogHelper = DialogHelper;
      function openDialog(targetId, title, elementProps, dialogData, windowFeatures = {
        centerscreen: true,
        resizable: true,
        fitContent: true
      }) {
        var _a, _b;
        const uiTool = new ui_1.UITool();
        uiTool.basicOptions.ui.enableElementJSONLog = false;
        uiTool.basicOptions.ui.enableElementRecord = false;
        const Zotero2 = uiTool.getGlobal("Zotero");
        dialogData = dialogData || {};
        if (!dialogData.loadLock) {
          dialogData.loadLock = Zotero2.Promise.defer();
        }
        if (!dialogData.unloadLock) {
          dialogData.unloadLock = Zotero2.Promise.defer();
        }
        let featureString = `resizable=${windowFeatures.resizable ? "yes" : "no"},`;
        if (windowFeatures.width || windowFeatures.height) {
          featureString += `width=${windowFeatures.width || 100},height=${windowFeatures.height || 100},`;
        }
        if (windowFeatures.left) {
          featureString += `left=${windowFeatures.left},`;
        }
        if (windowFeatures.top) {
          featureString += `top=${windowFeatures.top},`;
        }
        if (windowFeatures.centerscreen) {
          featureString += "centerscreen,";
        }
        if (windowFeatures.noDialogMode) {
          featureString += "dialog=no,";
        }
        if (windowFeatures.alwaysRaised) {
          featureString += "alwaysRaised=yes,";
        }
        const win = uiTool.getGlobal("openDialog")("about:blank", targetId || "_blank", featureString, dialogData);
        dialogData.loadLock.promise.then(() => {
          win.document.head.appendChild(uiTool.createElement(win.document, "title", {
            properties: { innerText: title }
          }));
          win.document.head.appendChild(uiTool.createElement(win.document, "style", {
            properties: {
              innerHTML: style
            }
          }));
          replaceElement(elementProps, uiTool);
          win.document.body.appendChild(uiTool.createElement(win.document, "fragment", {
            children: [elementProps]
          }));
          Array.from(win.document.querySelectorAll("*[data-bind]")).forEach((elem) => {
            const bindKey = elem.getAttribute("data-bind");
            const bindAttr = elem.getAttribute("data-attr");
            const bindProp = elem.getAttribute("data-prop");
            if (bindKey && dialogData && dialogData[bindKey]) {
              if (bindProp) {
                elem[bindProp] = dialogData[bindKey];
              } else {
                elem.setAttribute(bindAttr || "value", dialogData[bindKey]);
              }
            }
          });
          if (windowFeatures.fitContent) {
            win.sizeToContent();
          }
          win.focus();
        }).then(() => {
          (dialogData === null || dialogData === void 0 ? void 0 : dialogData.loadCallback) && dialogData.loadCallback();
        });
        dialogData.unloadLock.promise.then(() => {
          (dialogData === null || dialogData === void 0 ? void 0 : dialogData.unloadCallback) && dialogData.unloadCallback();
        });
        win.addEventListener("DOMContentLoaded", function onWindowLoad(ev) {
          var _a2, _b2;
          (_b2 = (_a2 = win.arguments[0]) === null || _a2 === void 0 ? void 0 : _a2.loadLock) === null || _b2 === void 0 ? void 0 : _b2.resolve();
          win.removeEventListener("DOMContentLoaded", onWindowLoad, false);
        }, false);
        win.addEventListener("beforeunload", function onWindowBeforeUnload(ev) {
          Array.from(win.document.querySelectorAll("*[data-bind]")).forEach((elem) => {
            const dialogData2 = this.window.arguments[0];
            const bindKey = elem.getAttribute("data-bind");
            const bindAttr = elem.getAttribute("data-attr");
            const bindProp = elem.getAttribute("data-prop");
            if (bindKey && dialogData2) {
              if (bindProp) {
                dialogData2[bindKey] = elem[bindProp];
              } else {
                dialogData2[bindKey] = elem.getAttribute(bindAttr || "value");
              }
            }
          });
          this.window.removeEventListener("beforeunload", onWindowBeforeUnload, false);
          (dialogData === null || dialogData === void 0 ? void 0 : dialogData.beforeUnloadCallback) && dialogData.beforeUnloadCallback();
        });
        win.addEventListener("unload", function onWindowUnload(ev) {
          var _a2, _b2, _c;
          if ((_a2 = this.window.arguments[0]) === null || _a2 === void 0 ? void 0 : _a2.loadLock.promise.isPending()) {
            return;
          }
          (_c = (_b2 = this.window.arguments[0]) === null || _b2 === void 0 ? void 0 : _b2.unloadLock) === null || _c === void 0 ? void 0 : _c.resolve();
          this.window.removeEventListener("unload", onWindowUnload, false);
        });
        if (win.document.readyState === "complete") {
          (_b = (_a = win.arguments[0]) === null || _a === void 0 ? void 0 : _a.loadLock) === null || _b === void 0 ? void 0 : _b.resolve();
        }
        return win;
      }
      function replaceElement(elementProps, uiTool) {
        var _a, _b, _c, _d, _e, _f, _g;
        let checkChildren = true;
        if (elementProps.tag === "select" && uiTool.isZotero7()) {
          checkChildren = false;
          const customSelectProps = {
            tag: "div",
            classList: ["dropdown"],
            listeners: [
              {
                type: "mouseleave",
                listener: (ev) => {
                  const select = ev.target.querySelector("select");
                  select === null || select === void 0 ? void 0 : select.blur();
                }
              }
            ],
            children: [
              Object.assign({}, elementProps, {
                tag: "select",
                listeners: [
                  {
                    type: "focus",
                    listener: (ev) => {
                      var _a2;
                      const select = ev.target;
                      const dropdown = (_a2 = select.parentElement) === null || _a2 === void 0 ? void 0 : _a2.querySelector(".dropdown-content");
                      dropdown && (dropdown.style.display = "block");
                      select.setAttribute("focus", "true");
                    }
                  },
                  {
                    type: "blur",
                    listener: (ev) => {
                      var _a2;
                      const select = ev.target;
                      const dropdown = (_a2 = select.parentElement) === null || _a2 === void 0 ? void 0 : _a2.querySelector(".dropdown-content");
                      dropdown && (dropdown.style.display = "none");
                      select.removeAttribute("focus");
                    }
                  }
                ]
              }),
              {
                tag: "div",
                classList: ["dropdown-content"],
                children: (_a = elementProps.children) === null || _a === void 0 ? void 0 : _a.map((option) => {
                  var _a2, _b2, _c2;
                  return {
                    tag: "p",
                    attributes: {
                      value: (_a2 = option.properties) === null || _a2 === void 0 ? void 0 : _a2.value
                    },
                    properties: {
                      innerHTML: ((_b2 = option.properties) === null || _b2 === void 0 ? void 0 : _b2.innerHTML) || ((_c2 = option.properties) === null || _c2 === void 0 ? void 0 : _c2.innerText)
                    },
                    classList: ["dropdown-item"],
                    listeners: [
                      {
                        type: "click",
                        listener: (ev) => {
                          var _a3;
                          const select = (_a3 = ev.target.parentElement) === null || _a3 === void 0 ? void 0 : _a3.previousElementSibling;
                          select && (select.value = ev.target.getAttribute("value") || "");
                          select === null || select === void 0 ? void 0 : select.blur();
                        }
                      }
                    ]
                  };
                })
              }
            ]
          };
          for (const key in elementProps) {
            delete elementProps[key];
          }
          Object.assign(elementProps, customSelectProps);
        } else if (elementProps.tag === "a") {
          const href = ((_b = elementProps === null || elementProps === void 0 ? void 0 : elementProps.properties) === null || _b === void 0 ? void 0 : _b.href) || "";
          (_c = elementProps.properties) !== null && _c !== void 0 ? _c : elementProps.properties = {};
          elementProps.properties.href = "javascript:void(0);";
          (_d = elementProps.attributes) !== null && _d !== void 0 ? _d : elementProps.attributes = {};
          elementProps.attributes["zotero-href"] = href;
          (_e = elementProps.listeners) !== null && _e !== void 0 ? _e : elementProps.listeners = [];
          elementProps.listeners.push({
            type: "click",
            listener: (ev) => {
              var _a2;
              const href2 = (_a2 = ev.target) === null || _a2 === void 0 ? void 0 : _a2.getAttribute("zotero-href");
              href2 && uiTool.getGlobal("Zotero").launchURL(href2);
            }
          });
          (_f = elementProps.classList) !== null && _f !== void 0 ? _f : elementProps.classList = [];
          elementProps.classList.push("zotero-text-link");
        }
        if (checkChildren) {
          (_g = elementProps.children) === null || _g === void 0 ? void 0 : _g.forEach((child) => replaceElement(child, uiTool));
        }
      }
      var style = `
html,
body {
  font-size: calc(12px * 1);
}
.zotero-text-link {
  -moz-user-focus: normal;
  color: -moz-nativehyperlinktext;
  text-decoration: underline;
  border: 1px solid transparent;
  cursor: pointer;
}
.dropdown {
  position: relative;
  display: inline-block;
}
.dropdown-content {
  display: none;
  position: absolute;
  background-color: #f9f9fb;
  min-width: 160px;
  box-shadow: 0px 0px 5px 0px rgba(0, 0, 0, 0.5);
  border-radius: 5px;
  padding: 5px 0 5px 0;
  z-index: 999;
}
.dropdown-item {
  margin: 0px;
  padding: 5px 10px 5px 10px;
}
.dropdown-item:hover {
  background-color: #efeff3;
}
`;
    }
  });

  // node_modules/zotero-plugin-toolkit/dist/managers/readerInstance.js
  var require_readerInstance = __commonJS({
    "node_modules/zotero-plugin-toolkit/dist/managers/readerInstance.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ReaderInstanceManager = void 0;
      var basic_1 = require_basic();
      var toolkitGlobal_1 = __importDefault(require_toolkitGlobal());
      var ReaderInstanceManager = class extends basic_1.ManagerTool {
        constructor(base) {
          super(base);
          this.cachedHookIds = [];
          this.initializeGlobal();
        }
        /**
         * Register a reader instance hook
         * @remarks
         * initialized: called when reader instance is ready
         * @param type hook type
         * @param id hook id
         * @param hook
         */
        register(type, id, hook) {
          const Zotero2 = this.getGlobal("Zotero");
          switch (type) {
            case "initialized":
              {
                this.globalCache.initializedHooks[id] = hook;
                Zotero2.Reader._readers.forEach(hook);
              }
              break;
            default:
              break;
          }
          this.cachedHookIds.push(id);
        }
        /**
         * Unregister hook by id
         * @param id
         */
        unregister(id) {
          delete this.globalCache.initializedHooks[id];
        }
        /**
         * Unregister all hooks
         */
        unregisterAll() {
          this.cachedHookIds.forEach((id) => this.unregister(id));
        }
        initializeGlobal() {
          this.globalCache = toolkitGlobal_1.default.getInstance().readerInstance;
          if (!this.globalCache._ready) {
            this.globalCache._ready = true;
            const Zotero2 = this.getGlobal("Zotero");
            const _this = this;
            Zotero2.Reader._readers = new (this.getGlobal("Proxy"))(Zotero2.Reader._readers, {
              set(target, p, newValue, receiver) {
                target[p] = newValue;
                if (!isNaN(Number(p))) {
                  Object.values(_this.globalCache.initializedHooks).forEach((hook) => {
                    try {
                      hook(newValue);
                    } catch (e) {
                      _this.log(e);
                    }
                  });
                }
                return true;
              }
            });
          }
        }
      };
      exports.ReaderInstanceManager = ReaderInstanceManager;
    }
  });

  // node_modules/zotero-plugin-toolkit/dist/managers/itemBox.js
  var require_itemBox = __commonJS({
    "node_modules/zotero-plugin-toolkit/dist/managers/itemBox.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ItemBoxManager = void 0;
      var basic_1 = require_basic();
      var fieldHook_1 = require_fieldHook();
      var patch_1 = require_patch();
      var toolkitGlobal_1 = __importDefault(require_toolkitGlobal());
      var ItemBoxManager = class extends basic_1.ManagerTool {
        constructor(base) {
          super(base);
          this.initializationLock = this.getGlobal("Zotero").Promise.defer();
          this.localCache = [];
          this.fieldHooks = new fieldHook_1.FieldHookManager();
          this.patcherManager = new patch_1.PatcherManager();
          this.initializeGlobal();
        }
        /**
         * Register a custom row
         * @param field Field name. Used in `getField` and `setField`.
         * @param displayName The row header display text.
         * @param getFieldHook Called when loading row content.
         * If you registered the getField hook somewhere else (in ItemBox or FieldHooks), leave it undefined.
         * @param options
         * @param options.editable If the row is editable.
         * To edit a row, either the `options.setFieldHook` or a custom hook for `setField` created by FieldHookManager is required.
         * @param options.setFieldHook The `setField` hook.
         * @param options.index Target index. By default it's placed at the end of rows.
         * @param options.multiline If the row content is multiline.
         * @param options.collapsible If the row content is collapsible (like abstract field).
         */
        async register(field, displayName, getFieldHook, options = {}) {
          this.fieldHooks.register("isFieldOfBase", field, () => false);
          if (getFieldHook) {
            this.fieldHooks.register("getField", field, getFieldHook);
          }
          if (options.editable && options.setFieldHook) {
            this.fieldHooks.register("setField", field, options.setFieldHook);
          }
          this.globalCache.fieldOptions[field] = {
            field,
            displayName,
            editable: options.editable || false,
            index: options.index || -1,
            multiline: options.multiline || false,
            collapsible: options.collapsible || false
          };
          this.localCache.push(field);
          await this.initializationLock.promise;
          this.refresh();
        }
        /**
         * Unregister a row of specific field.
         * @param field
         * @param options Skip unregister of certain hooks.
         * This is useful when the hook is not initialized by this instance
         * @param options.skipRefresh Skip refresh after unregister.
         */
        unregister(field, options = {}) {
          delete this.globalCache.fieldOptions[field];
          if (!options.skipIsFieldOfBase) {
            this.fieldHooks.unregister("isFieldOfBase", field);
          }
          if (!options.skipGetField) {
            this.fieldHooks.unregister("getField", field);
          }
          if (!options.skipSetField) {
            this.fieldHooks.unregister("setField", field);
          }
          const idx = this.localCache.indexOf(field);
          if (idx > -1) {
            this.localCache.splice(idx, 1);
          }
          if (!options.skipRefresh) {
            this.refresh();
          }
        }
        unregisterAll() {
          [...this.localCache].forEach((field) => this.unregister(field, {
            skipGetField: true,
            skipSetField: true,
            skipIsFieldOfBase: true,
            skipRefresh: true
          }));
          this.fieldHooks.unregisterAll();
          this.refresh();
        }
        /**
         * Refresh all item boxes.
         */
        refresh() {
          try {
            Array.from(this.getGlobal("document").querySelectorAll(this.isZotero7() ? "item-box" : "zoteroitembox")).forEach((elem) => elem.refresh());
          } catch (e) {
            this.log(e);
          }
        }
        async initializeGlobal() {
          const Zotero2 = this.getGlobal("Zotero");
          await Zotero2.uiReadyPromise;
          const window2 = this.getGlobal("window");
          this.globalCache = toolkitGlobal_1.default.getInstance().itemBox;
          const globalCache = this.globalCache;
          const inZotero7 = this.isZotero7();
          if (!globalCache._ready) {
            globalCache._ready = true;
            let itemBoxInstance;
            if (inZotero7) {
              itemBoxInstance = new (this.getGlobal("customElements").get("item-box"))();
            } else {
              itemBoxInstance = window2.document.querySelector("#zotero-editpane-item-box");
              const wait = 5e3;
              let t = 0;
              while (!itemBoxInstance && t < wait) {
                itemBoxInstance = window2.document.querySelector("#zotero-editpane-item-box");
                await Zotero2.Promise.delay(10);
                t += 10;
              }
              if (!itemBoxInstance) {
                globalCache._ready = false;
                this.log("ItemBox initialization failed");
                return;
              }
            }
            this.patcherManager.register(itemBoxInstance.__proto__, "refresh", (original) => function() {
              const originalThis = this;
              original.apply(originalThis, arguments);
              for (const extraField of Object.values(globalCache.fieldOptions)) {
                const fieldHeader = document.createElement(inZotero7 ? "th" : "label");
                fieldHeader.setAttribute("fieldname", extraField.field);
                const prefKey = `extensions.zotero.pluginToolkit.fieldCollapsed.${extraField.field}`;
                const collapsed = extraField.multiline && extraField.collapsible && Zotero2.Prefs.get(prefKey, true);
                let headerContent = extraField.displayName;
                if (collapsed) {
                  headerContent = `(...)${headerContent}`;
                }
                if (inZotero7) {
                  let label = document.createElement("label");
                  label.className = "key";
                  label.textContent = headerContent;
                  fieldHeader.appendChild(label);
                } else {
                  fieldHeader.setAttribute("value", headerContent);
                }
                const _clickable = originalThis.clickable;
                originalThis.clickable = extraField.editable;
                const fieldValue = originalThis.createValueElement(originalThis.item.getField(extraField.field), extraField.field, 1099);
                originalThis.clickable = _clickable;
                if (extraField.multiline && !Zotero2.Prefs.get(prefKey, true)) {
                  fieldValue.classList.add("multiline");
                } else if (!inZotero7) {
                  fieldValue.setAttribute("crop", "end");
                  fieldValue.setAttribute("value", fieldValue.innerHTML);
                  fieldValue.innerHTML = "";
                }
                if (extraField.collapsible) {
                  fieldHeader.addEventListener("click", function(ev) {
                    Zotero2.Prefs.set(prefKey, !(Zotero2.Prefs.get(prefKey, true) || false), true);
                    originalThis.refresh();
                  });
                }
                fieldHeader.addEventListener("click", inZotero7 ? function(ev) {
                  var _a;
                  const inputField = (_a = ev.currentTarget.nextElementSibling) === null || _a === void 0 ? void 0 : _a.querySelector("input, textarea");
                  if (inputField) {
                    inputField.blur();
                  }
                } : function(ev) {
                  var _a;
                  const inputField = (_a = ev.currentTarget.nextElementSibling) === null || _a === void 0 ? void 0 : _a.inputField;
                  if (inputField) {
                    inputField.blur();
                  }
                });
                const table = inZotero7 ? originalThis._infoTable : originalThis._dynamicFields;
                let fieldIndex = extraField.index;
                if (fieldIndex === 0) {
                  fieldIndex = 1;
                }
                if (fieldIndex && fieldIndex >= 0 && fieldIndex < table.children.length) {
                  originalThis._beforeRow = table.children[fieldIndex];
                  originalThis.addDynamicRow(fieldHeader, fieldValue, true);
                } else {
                  originalThis.addDynamicRow(fieldHeader, fieldValue);
                }
              }
            });
          }
          this.initializationLock.resolve();
        }
      };
      exports.ItemBoxManager = ItemBoxManager;
    }
  });

  // node_modules/zotero-plugin-toolkit/dist/helpers/largePref.js
  var require_largePref = __commonJS({
    "node_modules/zotero-plugin-toolkit/dist/helpers/largePref.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LargePrefHelper = void 0;
      var LargePrefHelper = class {
        /**
         *
         * @param keyPref The preference name for storing the keys of the data.
         * @param valuePrefPrefix The preference name prefix for storing the values of the data.
         * @param hooks Hooks for parsing the values of the data.
         * - `afterGetValue`: A function that takes the value of the data as input and returns the parsed value.
         * - `beforeSetValue`: A function that takes the key and value of the data as input and returns the parsed key and value.
         * If `hooks` is `"default"`, no parsing will be done.
         * If `hooks` is `"parser"`, the values will be parsed as JSON.
         * If `hooks` is an object, the values will be parsed by the hooks.
         */
        constructor(keyPref, valuePrefPrefix, hooks = "default") {
          this.keyPref = keyPref;
          this.valuePrefPrefix = valuePrefPrefix;
          if (hooks === "default") {
            this.hooks = defaultHooks;
          } else if (hooks === "parser") {
            this.hooks = parserHooks;
          } else {
            this.hooks = Object.assign(Object.assign({}, defaultHooks), hooks);
          }
          this.innerObj = {};
        }
        /**
         * Get the object that stores the data.
         * @returns The object that stores the data.
         */
        asObject() {
          return this.constructTempObj();
        }
        /**
         * Get the Map that stores the data.
         * @returns The Map that stores the data.
         */
        asMapLike() {
          const mapLike = {
            get: (key) => this.getValue(key),
            set: (key, value) => {
              this.setValue(key, value);
              return mapLike;
            },
            has: (key) => this.hasKey(key),
            delete: (key) => this.deleteKey(key),
            clear: () => {
              for (const key of this.getKeys()) {
                this.deleteKey(key);
              }
            },
            forEach: (callback) => {
              return this.constructTempMap().forEach(callback);
            },
            get size() {
              return this._this.getKeys().length;
            },
            entries: () => {
              return this.constructTempMap().values();
            },
            keys: () => {
              const keys = this.getKeys();
              return keys[Symbol.iterator]();
            },
            values: () => {
              return this.constructTempMap().values();
            },
            [Symbol.iterator]: () => {
              return this.constructTempMap()[Symbol.iterator]();
            },
            [Symbol.toStringTag]: "MapLike",
            _this: this
          };
          return mapLike;
        }
        /**
         * Get the keys of the data.
         * @returns The keys of the data.
         */
        getKeys() {
          const rawKeys = Zotero.Prefs.get(this.keyPref, true);
          const keys = rawKeys ? JSON.parse(rawKeys) : [];
          for (const key of keys) {
            const value = "placeholder";
            this.innerObj[key] = value;
          }
          return keys;
        }
        /**
         * Set the keys of the data.
         * @param keys The keys of the data.
         */
        setKeys(keys) {
          keys = [...new Set(keys.filter((key) => key))];
          Zotero.Prefs.set(this.keyPref, JSON.stringify(keys), true);
          for (const key of keys) {
            const value = "placeholder";
            this.innerObj[key] = value;
          }
        }
        /**
         * Get the value of a key.
         * @param key The key of the data.
         * @returns The value of the key.
         */
        getValue(key) {
          const value = Zotero.Prefs.get(`${this.valuePrefPrefix}${key}`, true);
          if (typeof value === "undefined") {
            return;
          }
          let { value: newValue } = this.hooks.afterGetValue({ value });
          this.innerObj[key] = newValue;
          return newValue;
        }
        /**
         * Set the value of a key.
         * @param key The key of the data.
         * @param value The value of the key.
         */
        setValue(key, value) {
          let { key: newKey, value: newValue } = this.hooks.beforeSetValue({
            key,
            value
          });
          this.setKey(newKey);
          Zotero.Prefs.set(`${this.valuePrefPrefix}${newKey}`, newValue, true);
          this.innerObj[newKey] = newValue;
        }
        /**
         * Check if a key exists.
         * @param key The key of the data.
         * @returns Whether the key exists.
         */
        hasKey(key) {
          return this.getKeys().includes(key);
        }
        /**
         * Add a key.
         * @param key The key of the data.
         */
        setKey(key) {
          const keys = this.getKeys();
          if (!keys.includes(key)) {
            keys.push(key);
            this.setKeys(keys);
          }
        }
        /**
         * Delete a key.
         * @param key The key of the data.
         */
        deleteKey(key) {
          const keys = this.getKeys();
          const index = keys.indexOf(key);
          if (index > -1) {
            keys.splice(index, 1);
            delete this.innerObj[key];
            this.setKeys(keys);
          }
          Zotero.Prefs.clear(`${this.valuePrefPrefix}${key}`, true);
          return true;
        }
        constructTempObj() {
          return new Proxy(this.innerObj, {
            get: (target, prop, receiver) => {
              this.getKeys();
              if (typeof prop === "string" && prop in target) {
                this.getValue(prop);
              }
              return Reflect.get(target, prop, receiver);
            },
            set: (target, p, newValue, receiver) => {
              if (typeof p === "string") {
                if (newValue === void 0) {
                  this.deleteKey(p);
                  return true;
                }
                this.setValue(p, newValue);
                return true;
              }
              return Reflect.set(target, p, newValue, receiver);
            },
            has: (target, p) => {
              this.getKeys();
              return Reflect.has(target, p);
            },
            deleteProperty: (target, p) => {
              if (typeof p === "string") {
                this.deleteKey(p);
                return true;
              }
              return Reflect.deleteProperty(target, p);
            }
          });
        }
        constructTempMap() {
          const map = /* @__PURE__ */ new Map();
          for (const key of this.getKeys()) {
            map.set(key, this.getValue(key));
          }
          return map;
        }
      };
      exports.LargePrefHelper = LargePrefHelper;
      var defaultHooks = {
        afterGetValue: ({ value }) => ({ value }),
        beforeSetValue: ({ key, value }) => ({ key, value })
      };
      var parserHooks = {
        afterGetValue: ({ value }) => {
          try {
            value = JSON.parse(value);
          } catch (e) {
            return { value };
          }
          return { value };
        },
        beforeSetValue: ({ key, value }) => {
          value = JSON.stringify(value);
          return { key, value };
        }
      };
    }
  });

  // node_modules/zotero-plugin-toolkit/dist/index.js
  var require_dist = __commonJS({
    "node_modules/zotero-plugin-toolkit/dist/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ZoteroToolkit = void 0;
      var basic_1 = require_basic();
      var ui_1 = require_ui();
      var reader_1 = require_reader();
      var extraField_1 = require_extraField();
      var itemTree_1 = require_itemTree();
      var prompt_1 = require_prompt();
      var libraryTabPanel_1 = require_libraryTabPanel();
      var readerTabPanel_1 = require_readerTabPanel();
      var menu_1 = require_menu();
      var preferencePane_1 = require_preferencePane();
      var shortcut_1 = require_shortcut();
      var clipboard_1 = require_clipboard();
      var filePicker_1 = require_filePicker();
      var progressWindow_1 = require_progressWindow();
      var virtualizedTable_1 = require_virtualizedTable();
      var dialog_1 = require_dialog();
      var readerInstance_1 = require_readerInstance();
      var fieldHook_1 = require_fieldHook();
      var itemBox_1 = require_itemBox();
      var largePref_1 = require_largePref();
      var ZoteroToolkit2 = class extends basic_1.BasicTool {
        constructor() {
          super();
          this.UI = new ui_1.UITool(this);
          this.Reader = new reader_1.ReaderTool(this);
          this.ExtraField = new extraField_1.ExtraFieldTool(this);
          this.FieldHooks = new fieldHook_1.FieldHookManager(this);
          this.ItemTree = new itemTree_1.ItemTreeManager(this);
          this.ItemBox = new itemBox_1.ItemBoxManager(this);
          this.Prompt = new prompt_1.PromptManager(this);
          this.LibraryTabPanel = new libraryTabPanel_1.LibraryTabPanelManager(this);
          this.ReaderTabPanel = new readerTabPanel_1.ReaderTabPanelManager(this);
          this.ReaderInstance = new readerInstance_1.ReaderInstanceManager(this);
          this.Menu = new menu_1.MenuManager(this);
          this.PreferencePane = new preferencePane_1.PreferencePaneManager(this);
          this.Shortcut = new shortcut_1.ShortcutManager(this);
          this.Clipboard = clipboard_1.ClipboardHelper;
          this.FilePicker = filePicker_1.FilePickerHelper;
          this.ProgressWindow = progressWindow_1.ProgressWindowHelper;
          this.VirtualizedTable = virtualizedTable_1.VirtualizedTableHelper;
          this.Dialog = dialog_1.DialogHelper;
          this.LargePrefObject = largePref_1.LargePrefHelper;
        }
        /**
         * Unregister everything created by managers.
         */
        unregisterAll() {
          (0, basic_1.unregister)(this);
        }
      };
      exports.ZoteroToolkit = ZoteroToolkit2;
      exports.default = ZoteroToolkit2;
    }
  });

  // src/index.ts
  var import_basic = __toESM(require_basic());

  // package.json
  var config = {
    addonName: "Crush Reference",
    addonID: "zoteroreference@polygon.org",
    addonRef: "zoteroreference",
    addonInstance: "ZoteroReference",
    releasepage: "https://github.com/muisedestiny/zotero-reference/releases/latest/download/zotero-reference.xpi",
    updaterdf: "https://raw.githubusercontent.com/muisedestiny/zotero-reference/bootstrap/update.json"
  };

  // src/modules/prefs.ts
  function registerPrefs() {
    const prefOptions = {
      pluginID: config.addonID,
      src: rootURI + "chrome/content/preferences.xhtml",
      label: "Reference",
      image: `chrome://${config.addonRef}/content/icons/favicon.png`
      // extraDTD: [`chrome://${config.addonRef}/locale/overlay.dtd`],
      // defaultXUL: true,
    };
    ztoolkit.PreferencePane.register(prefOptions);
  }
  function registerPrefsScripts(_window) {
    if (!addon.data.prefs) {
      addon.data.prefs = {
        window: _window
      };
    } else {
      addon.data.prefs.window = _window;
    }
    const doc = addon.data.prefs.window.document;
  }

  // src/utils/locale.ts
  function initLocale() {
    const l10n = new (typeof Localization === "undefined" ? ztoolkit.getGlobal("Localization") : Localization)([`${config.addonRef}-addon.ftl`], true);
    addon.data.locale = {
      current: l10n
    };
  }
  function getString(...inputs) {
    if (inputs.length === 1) {
      return _getString(inputs[0]);
    } else if (inputs.length === 2) {
      if (typeof inputs[1] === "string") {
        return _getString(inputs[0], { branch: inputs[1] });
      } else {
        return _getString(inputs[0], inputs[1]);
      }
    } else {
      throw new Error("Invalid arguments");
    }
  }
  function _getString(localeString, options = {}) {
    const localStringWithPrefix = `${config.addonRef}-${localeString}`;
    const { branch, args } = options;
    const pattern = addon.data.locale?.current.formatMessagesSync([
      { id: localStringWithPrefix, args }
    ])[0];
    if (!pattern) {
      return localStringWithPrefix;
    }
    if (branch && pattern.attributes) {
      return pattern.attributes[branch] || localStringWithPrefix;
    } else {
      return pattern.value || localStringWithPrefix;
    }
  }

  // src/modules/requests.ts
  var Requests = class {
    constructor() {
      /**
       * Record api response
       */
      this.cache = {};
    }
    async get(url, responseType = "json", headers = {}) {
      const k = JSON.stringify(arguments);
      if (this.cache[k]) {
        return this.cache[k];
      }
      let res = await Zotero.HTTP.request(
        "GET",
        url,
        {
          responseType,
          headers,
          credentials: "include"
        }
      );
      if (res.status == 200) {
        this.cache[k] = res.response;
        return res.response;
      } else {
        ztoolkit.log(`get ${url} error`, res);
      }
    }
    async post(url, body = {}, responseType = "json") {
      const k = JSON.stringify(arguments);
      if (this.cache[k]) {
        return this.cache[k];
      }
      let res = await Zotero.HTTP.request(
        "POST",
        url,
        Object.assign({
          responseType
        }, Object.keys(body).length > 0 ? {
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify(body)
          // credentials: "include"
        } : {})
      );
      if (res.status == 200) {
        this.cache[k] = res.response;
        return res.response;
      } else {
        ztoolkit.log(`post ${url} error`, res);
      }
    }
  };

  // src/modules/api.ts
  var xml2js = require_xml2js();
  var API = class {
    constructor(utils) {
      this.utils = utils;
      this.requests = new Requests();
      this.Info = {
        crossref: (item) => {
          const types = {
            "journal-article": "journalArticle",
            "report": "report",
            "posted-content": "preprint",
            "book-chapter": "bookSection"
          };
          let references = item.reference?.map((item2) => {
            let identifiers;
            let url;
            let text;
            let textInfo = {};
            if (item2.unstructured) {
              text = item2.unstructured;
              textInfo = this.utils.refText2Info(text);
            } else {
              if (item2["article-title"] && item2.year && item2.author) {
                text = `${item2.author} et al., ${item2.year}, ${item2["article-title"]}`;
              } else {
                let textArray = [];
                for (let key in item2) {
                  textArray.push(`${key}: ${item2[key]}`);
                }
                text = textArray.join("; ");
              }
            }
            if (item2.DOI) {
              identifiers = { DOI: item2.DOI };
              url = this.utils.identifiers2URL(identifiers);
            }
            let info2 = {
              identifiers: identifiers || textInfo.identifiers || {},
              title: item2["article-title"],
              authors: [item2?.author],
              year: item2.year,
              text,
              type: types[item2.type] || "journalArticle",
              url: textInfo?.url || url
            };
            return info2;
          });
          const refCount = item["is-referenced-by-count"];
          let info = {
            identifiers: { DOI: item.DOI },
            authors: item?.author?.map((i) => i.family),
            title: Array.isArray(item.title) ? item.title[0] : item.title,
            year: item.published && item.published["date-parts"][0][0],
            type: types[item.type] || "journalArticle",
            text: item.title[0],
            url: item.URL,
            abstract: item.abstract,
            publishDate: item.published && item.published["date-parts"][0].join("-"),
            source: item.source.toLowerCase(),
            primaryVenue: item["container-title"] ? item["container-title"][0] : [],
            references,
            tags: [
              ...refCount && refCount > 0 ? [{
                text: refCount,
                color: "#2fb8cb",
                tip: "is-referenced-by-count"
              }] : []
            ]
          };
          return info;
        },
        connectedpapers: (item) => {
          let info = {
            identifiers: { DOI: item.doiInfo.doi },
            authors: item?.authors?.map((i) => i[0].name),
            title: item.title.text,
            year: item.year.text,
            type: "journalArticle",
            text: item.title.text,
            url: item.doiInfo.doiUrl,
            abstract: item.paperAbstract.text,
            source: "connectedpapers",
            primaryVenue: item.venue.text,
            references: [],
            tags: [
              { text: item.citationStats.numCitations, tip: "citationStats.numCitations", color: "rgba(53, 153, 154, 0.5)" },
              { text: item.citationStats.numReferences, tip: "citationStats.numReferences", color: "rgba(53, 153, 154, 0.75)" }
            ]
          };
          return info;
        },
        readpaper: (data) => {
          let info = {
            identifiers: {},
            title: this.utils.Html2Text(data.title),
            year: data.year,
            publishDate: data.publishDate,
            authors: data?.authorList.map((i) => this.utils.Html2Text(i.name)),
            abstract: this.utils.Html2Text(data.summary),
            primaryVenue: this.utils.Html2Text(data.primaryVenue),
            tags: [
              ...data.venueTags || [],
              ...data.citationCount && data.citationCount > 0 ? [
                {
                  text: data.citationCount,
                  tip: "citationCount",
                  color: "#1f71e0"
                }
              ] : []
            ],
            source: "readpaper",
            type: "journalArticle"
          };
          return info;
        },
        semanticscholar(data) {
          let info = {
            identifiers: { DOI: data.DOI },
            title: data.title,
            authors: data.authors.map((i) => i.name),
            year: data.year,
            publishDate: data.publicationDate,
            abstract: data.abstract,
            source: "semanticscholar",
            type: "journalArticle",
            tags: data.fieldsOfStudy || [],
            primaryVenue: data.journal?.name,
            url: data.DOI ? `http://doi.org/${data.DOI}` : void 0
          };
          return info;
        },
        unpaywall(data) {
          const types = {
            "journal-article": "journalArticle",
            "report": "report",
            "posted-content": "preprint",
            "book-chapter": "bookSection"
          };
          let info = {
            identifiers: { DOI: data.DOI },
            authors: data.z_authors.map((i) => i.family),
            title: data.title,
            year: data.year,
            type: types[data.genre],
            primaryVenue: data.journal_name,
            source: "unpaywall",
            publishDate: data.published_date,
            abstract: void 0
          };
          return info;
        },
        arXiv: (data) => {
          let info = {
            identifiers: { arXiv: data.arXiv },
            title: data.title[0].replace(/\n/g, ""),
            year: data.year,
            authors: data.author.map((e) => e.name[0]),
            abstract: data.summary[0].replace(/\n/g, ""),
            url: this.utils.identifiers2URL({ arXiv: data.arXiv }),
            type: "preprint",
            tags: data.category.map((e) => e["$"].term),
            publishDate: data.published && data.published[0],
            primaryVenue: data["arxiv:comment"] && data["arxiv:comment"][0]["_"].replace(/\n/g, "")
          };
          return info;
        }
      };
      this.BaseInfo = {
        readcube: (data) => {
          let identifiers;
          if (data.doi && this.utils.regex.arXiv.test(data.doi)) {
            data.arxiv = data.doi.match(this.utils.regex.arXiv).slice(-1)[0];
            data.doi = void 0;
          }
          let type = "journalArticle";
          if (data.arxiv && !data.doi) {
            identifiers = { arXiv: data.arxiv };
            type = "preprint";
          } else {
            identifiers = { DOI: data.doi };
          }
          let url = this.utils.identifiers2URL(identifiers);
          let related = {
            identifiers,
            title: data.title,
            authors: data?.authors,
            year: data.year,
            type,
            text: data.title,
            url
          };
          return related;
        }
      };
    }
    // For DOI
    async getDOIBaseInfo(DOI) {
      const routes = {
        semanticscholar: `https://api.semanticscholar.org/graph/v1/paper/${DOI}?fields=title,year,authors`,
        unpaywall: `https://api.unpaywall.org/v2/${DOI}?email=ZoteroReference@polygon.org`
      };
      for (let route in routes) {
        let response = await this.requests.get(routes[route]);
        if (response) {
          response.DOI = DOI;
          return this.Info[route](response);
        }
      }
    }
    /**
     * From semanticscholar API
     * @param DOI 
     */
    async getDOIInfoBySemanticscholar(DOI) {
      const api = `https://api.semanticscholar.org/graph/v1/paper/${DOI}?fields=title,authors,abstract,year,journal,fieldsOfStudy,publicationVenue,publicationDate`;
      let response = await this.requests.get(api);
      if (response) {
        response.DOI = DOI;
        if (!response.abstract) {
          let text = await this.requests.get(
            `https://www.semanticscholar.org/paper/${response.paperId}`,
            "text/html"
          );
          let parser = ztoolkit.getDOMParser();
          let doc = parser.parseFromString(text, "text/html");
          const abstract = doc.head.querySelector("meta[name=description]")?.getAttribute("content");
          if (!abstract?.startsWith("Semantic Scholar")) {
            response.abstract = abstract;
          }
        }
        return this.Info.semanticscholar(response);
      }
    }
    async getDOIInfoByCrossref(DOI) {
      const api = `https://api.crossref.org/works/${DOI}/transform/application/vnd.citationstyles.csl+json`;
      let response = await this.requests.get(api);
      if (response) {
        response.DOI = DOI;
        let info = this.Info.crossref(response);
        return info;
      }
    }
    // async getDOIRelatedArray(DOI: string): Promise<ItemBaseInfo[] | undefined> {
    //   const api = `https://services.readcube.com/reader/related?doi=${DOI}`
    //   let response = await this.requests.get(api)
    //   if (response) {
    //     let arr: ItemBaseInfo[] = response.map((i: any) => {
    //       return this.BaseInfo.readcube(i) as ItemBaseInfo
    //     })
    //     return arr
    //   }
    // }
    async getDOIRelatedArray(DOI, limit = 20) {
      let res = await this.requests.get(
        `https://rest.connectedpapers.com/id_translator/doi/${DOI}`,
        "json",
        {
          "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 e/107.0.0.0 Safari/537.36"
        }
      );
      const api = `https://www.semanticscholar.org/api/1/paper/${res.paperId}/related-papers?limit=20&recommenderType=relatedPapers`;
      let response = await this.requests.get(api, "json", {
        cookie: "aws-waf-token=fcf9f43b-d494-44a8-8806-da20c50d9457:AQoAaIgZ+Q0AAAAA:z/ZtlDV2Oz/Ymw+RFbJ0vnEAl1/wBKTH6I4/INUou3Qqkm00bibIWkYKq0w3qq4yxB2EtdBTtRT7Q2MBPjx17WmPmcVznf7mTMTwFQjmJOB2VgQeoBzsmuzVlI/l/NBlyTFdH8xEKYYWbXB8R5oK9o7JxolugTzDKvLX4Pc57cdkbCA5A6AIExi/Wm16"
      });
      ztoolkit.log(response);
      if (response) {
        let arr = response.papers.map((i) => {
          let info = {
            title: i.title.text,
            identifiers: {},
            year: i.year.text,
            text: i.title.text,
            type: "journalArticle",
            authors: i.authors.map((e) => e[1].text),
            abstract: i.paperAbstract?.text || i?.paperAbstractTruncated
          };
          if (i.citationContexts?.length > 0) {
            let descriptions = [];
            i.citationContexts.slice(0, 1).forEach((ctx) => {
              try {
                descriptions.push(
                  `${ctx.intents.length > 0 ? ctx.intents[0].id : "unknown"}: ${i.citationContexts[0].context.text}`
                );
              } catch {
                ztoolkit.log(ctx);
              }
            });
            info.description = descriptions.join("\n");
          }
          return info;
        });
        return arr;
      }
    }
    /**
     * API失效
     */
    async _getDOIRelatedArray(DOI, limit = 20) {
      let res = await this.requests.get(
        `https://rest.connectedpapers.com/id_translator/doi/${DOI}`,
        "json",
        {
          "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 e/107.0.0.0 Safari/537.36"
        }
      );
      const api = `https://www.semanticscholar.org/api/1/search/paper/${res.paperId}/citations`;
      let response = await this.requests.post(api, {
        "page": 1,
        "pageSize": 20,
        "sort": "relevance",
        "authors": [],
        "coAuthors": [],
        "venues": [],
        "yearFilter": null,
        "requireViewablePdf": false,
        "fieldsOfStudy": [],
        "useS2FosFields": true
      });
      ztoolkit.log(response);
      if (response) {
        let arr = response.results.map((i) => {
          let info = {
            title: i.title.text,
            identifiers: {},
            year: i.year,
            text: i.title.text,
            type: "journalArticle",
            authors: i.authors.map((e) => e[1].text)
          };
          if (i.citationContexts?.length > 0) {
            let descriptions = [];
            i.citationContexts.slice(0, 1).forEach((ctx) => {
              try {
                descriptions.push(
                  `${ctx.intents.length > 0 ? ctx.intents[0].id : "unknown"}: ${i.citationContexts[0].context.text}`
                );
              } catch {
                ztoolkit.log(ctx);
              }
            });
            info.description = descriptions.join("\n");
          }
          return info;
        });
        return arr;
      }
    }
    // For arXiv
    async getArXivInfo(arXiv) {
      const api = `https://export.arxiv.org/api/query?id_list=${arXiv}`;
      let response = await this.requests.get(
        api,
        "application/xhtml+xml"
      );
      if (response) {
        let data = (await xml2js.parseStringPromise(response))?.feed?.entry[0];
        if (data) {
          data.arXiv = arXiv;
          return this.Info.arXiv(data);
        }
      }
    }
    // For title
    /**
     * From crossref
     * @param title 
     * @returns 
     */
    async getTitleInfoByCrossref(title) {
      const api = `https://api.crossref.org/works?query=${title}`;
      let response = await this.requests.get(api);
      if (response) {
        const skipTypes = ["component"];
        let item = response.message.items.filter((e) => skipTypes.indexOf(e.type) == -1)[0];
        let info = this.Info.crossref(item);
        return info;
      }
    }
    async getTitleInfoByConnectedpapers(text) {
      let title = text;
      if (this.utils.isDOI(text)) {
        let DOI = text;
        let res = await this.requests.get(
          `https://rest.connectedpapers.com/id_translator/doi/${DOI}`
        );
        title = res.title;
      }
      const api = `https://rest.connectedpapers.com/search/${escape(title)}/1`;
      let response = await this.requests.post(api);
      if (response) {
        if (response?.results?.length) {
          let item = response.results[0];
          let info = this.Info.connectedpapers(item);
          return info;
        }
      }
    }
    async getTitleInfoByReadpaper(title, body = {}, doi = void 0) {
      const api = "https://readpaper.com/api/microService-app-aiKnowledge/aiKnowledge/paper/search";
      let _body = {
        keywords: title,
        page: 1,
        pageSize: 1,
        searchType: Number(Object.values(body).length > 0)
      };
      body = { ..._body, ...body };
      let response = await this.requests.post(api, body);
      if (response && response?.data?.list?.[0]) {
        let data = response?.data?.list?.[0];
        if (doi) {
          let _res = await this.requests.post(
            "https://readpaper.com/api/microService-app-aiKnowledge/aiKnowledge/paper/getPaperDetailInfo",
            { paperId: data.id }
          );
          ztoolkit.log(doi, _res.data.doi);
          if (_res.data.doi.toUpperCase() != doi.toUpperCase()) {
            return;
          }
        }
        let info = this.Info.readpaper(data);
        if (doi) {
          info.identifiers = { DOI: doi };
        }
        return info;
      }
    }
    // For CNKI
    async _getCNKIURL(title, author) {
      ztoolkit.log("getCNKIURL", title, author);
      let cnkiURL;
      let oldFunc = Zotero.Jasminum.Scrape.getItemFromSearch;
      ztoolkit.patch(
        Zotero.Jasminum.Scrape,
        "createPostData",
        config.addonRef,
        (original) => (arg) => {
          let text = original.call(Zotero.Jasminum.Scrape, arg);
          ztoolkit.log(text);
          text = escape(
            unescape(text).replace(/SCDB/g, "CFLS")
          );
          ztoolkit.log(text);
          return text;
        }
      );
      Zotero.Jasminum.Scrape.getItemFromSearch = function(htmlString) {
        try {
          let res = htmlString.match(/href='(.+FileName=.+?&DbName=.+?)'/i);
          if (res.length) {
            return res[1];
          }
        } catch {
          return;
        }
      }.bind(Zotero.Jasminum);
      cnkiURL = await Zotero.Jasminum.Scrape.search({ keyword: title });
      Zotero.Jasminum.Scrape.getItemFromSearch = oldFunc.bind(Zotero.Jasminum);
      if (!cnkiURL) {
        ztoolkit.log("cnkiURL", cnkiURL);
        return;
      }
      let args = this.utils.parseCNKIURL(cnkiURL);
      if (args) {
        cnkiURL = `https://kns.cnki.net/kcms/detail/detail.aspx?FileName=${args.fileName}&DbName=${args.dbName}&DbCode=${args.dbCode}`;
        return cnkiURL;
      }
    }
    async getCNKIURL(keywords, slience = false) {
      if (!slience) {
        new ztoolkit.ProgressWindow("[Pending] API", { closeOtherProgressWindows: true }).createLine({ text: `Get CNKI URL`, type: "default" }).show();
      }
      const res = await Zotero.HTTP.request(
        "POST",
        "https://kns.cnki.net/kns8/Brief/GetGridTableHtml",
        {
          headers: {
            Accept: "text/html, */*; q=0.01",
            "Accept-Encoding": "gzip, deflate, br",
            "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8,zh-TW;q=0.7",
            Connection: "keep-alive",
            "Content-Length": "2085",
            "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
            Host: "kns.cnki.net",
            Origin: "https://kns.cnki.net",
            Referer: "https://kns.cnki.net/kns8/AdvSearch?dbprefix=SCDB&&crossDbcodes=CJFQ%2CCDMD%2CCIPD%2CCCND%2CCISD%2CSNAD%2CBDZK%2CCJFN%2CCCJD",
            "Sec-Fetch-Dest": "empty",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Site": "same-origin",
            "X-Requested-With": "XMLHttpRequest"
          },
          body: `IsSearch=true&QueryJson={"Platform":"","DBCode":"CFLS","KuaKuCode":"CJFQ,CDMD,CIPD,CCND,CISD,SNAD,BDZK,CCJD,CCVD,CJFN","QNode":{"QGroup":[{"Key":"Subject","Title":"","Logic":1,"Items":[{"Title":"\u4E3B\u9898","Name":"SU","Value":"${keywords}","Operate":"%=","BlurType":""}],"ChildItems":[]}]},"CodeLang":"ch"}&PageName=defaultresult&DBCode=CFLS&CurPage=1&RecordsCntPerPage=20&CurDisplayMode=listmode&CurrSortField=&CurrSortFieldType=desc&IsSentenceSearch=false&Subject=`
        }
      );
      try {
        if (res) {
          let cnkiURL = res.responseText.match(/href='(.+FileName=.+?&DbName=.+?)'/i);
          if (cnkiURL) {
            let args = this.utils.parseCNKIURL(cnkiURL[1]);
            if (args) {
              cnkiURL = `https://kns.cnki.net/kcms/detail/detail.aspx?FileName=${args.fileName}&DbName=${args.dbName}&DbCode=${args.dbCode}`;
              return cnkiURL;
            }
          }
        }
      } catch {
      }
      if (!slience) {
        new ztoolkit.ProgressWindow("[Pending] API", { closeOtherProgressWindows: true }).createLine({ text: `Get CNKI URL Fail`, type: "fail" }).show();
      }
    }
    async getTitleInfoByCNKI(refText) {
      if (!this.utils.isChinese(refText)) {
        return;
      }
      let res = this.utils.parseRefText(refText);
      const key = `${res.title}${res.authors}${refText}`;
      if (this.requests.cache[key]) {
        return this.requests.cache[key];
      }
      ztoolkit.log("parseRefText", refText, res);
      let url = await this.getCNKIURL(res.title, true);
      if (!url) {
        return;
      }
      let htmlString = await this.requests.get(url, "text");
      ztoolkit.log(url, htmlString);
      const parser = ztoolkit.getDOMParser();
      let doc = parser.parseFromString(htmlString, "text/html").childNodes[1];
      let aTags = doc.querySelectorAll(".top-tip span a");
      let info = {
        identifiers: { CNKI: url },
        title: doc.querySelector(".brief h1").innerText,
        abstract: doc.querySelector("span#ChDivSummary").innerText,
        authors: [...doc.querySelectorAll("#authorpart span a")].map((a) => a.innerText),
        type: "journalArticle",
        primaryVenue: aTags[0].innerText,
        year: aTags[1].innerText.split(",")[0],
        //2020,32(10)
        url,
        source: "CNKI",
        tags: [...doc.querySelectorAll(".keywords a")].map((a) => a.innerText.replace(/(\n|\s+|;)/g, "")).concat([
          {
            text: [...doc.querySelectorAll("p.total-inform span")].find((span) => span.innerText.includes("\u4E0B\u8F7D")).innerText.match(/\d+/)[0],
            color: "#cc7c08",
            tip: "\u77E5\u7F51\u4E0B\u8F7D\u91CF"
          }
        ])
      };
      this.requests.cache[key] = info;
      return info;
    }
    async getCNKIFileInfo(fileName, count = 0) {
      const prefsKey = `${config.addonRef}.CNKI.token`;
      const username = Zotero.Prefs.get(`${config.addonRef}.CNKI.username`);
      const password = Zotero.Prefs.get(`${config.addonRef}.CNKI.password`);
      if (username.length * password.length == 0) {
        new ztoolkit.ProgressWindow("[Fail] API", { closeOtherProgressWindows: true }).createLine({ text: "\u8BF7\u914D\u7F6E\u77E5\u7F51\u7814\u5B66\u8D26\u53F7\u5BC6\u7801\u540E\u91CD\u8BD5", type: "fail" }).show();
      }
      let updateToken = async () => {
        function getRandomIP() {
          let ip = "";
          for (var i = 0; i < 4; i++) {
            if (i < 3) {
              ip = ip + String(Math.floor(Math.random() * 256)) + ".";
            } else {
              ip = ip + String(Math.floor(Math.random() * 256));
            }
          }
          return ip;
        }
        let res = await this.requests.post(
          "https://apix.cnki.net/databusapi/api/v1.0/credential/namepasswithcleartext/personalaccount",
          {
            Username: username,
            Password: password,
            Clientip: getRandomIP()
          }
        );
        const token2 = res.Content;
        Zotero.Prefs.set(prefsKey, token2);
      };
      const infoApi = `https://x.cnki.net/readApi/api/v1/paperInfo?fileName=${fileName}&tableName=CJFDTOTAL&dbCode=CJFD&from=ReadingHistory&type=psmc&fsType=1&taskId=0`;
      const refApi = `https://x.cnki.net/readApi/api/v1/paperRefreNotes?appId=CRSP_BASIC_PSMC&dbcode=CJFD&tablename=CJFDTOTAL&filename=${fileName}&type=1&page=1`;
      const userAgent = "user-agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36";
      const token = Zotero.Prefs.get(prefsKey);
      const infoData = await this.requests.get(infoApi, "json", {
        token,
        "user-agent": userAgent
      });
      const refData = await this.requests.get(refApi, "json", {
        token,
        "user-agent": userAgent
      });
      ztoolkit.log(refData);
      if (String(refData.code) != "200") {
        if (count < 3) {
          await updateToken();
          return await this.getCNKIFileInfo(fileName, count + 1);
        } else {
          new ztoolkit.ProgressWindow("[Fail] API", { closeOtherProgressWindows: true }).createLine({ text: `${refData.code}: ${refData.promptMessage}`, type: "fail" }).show();
          return;
        }
      }
      let info = {
        identifiers: {},
        authors: [],
        type: "",
        references: [],
        title: ""
      };
      const typeMap = {
        "journal": "journalArticle"
      };
      if (String(infoData.code) == "200") {
        infoData.content.paper.bibliography.forEach((ref) => {
          let _ref = refData.content.refer.find((_ref2) => {
            return ref.title.indexOf(_ref2.title) != -1;
          });
          const refText = ref.title.replace(/^\[\d+\]/, "");
          if (_ref) {
            const cnkiURL = `https://kns.cnki.net/kcms/detail/detail.aspx?FileName=${_ref.fileName}&DbName=${_ref.tableName}&DbCode=${_ref.dbSource.split("_")[0]}`;
            info.references?.push({
              identifiers: {
                CNKI: cnkiURL
              },
              text: refText,
              title: _ref.title,
              authors: [],
              type: typeMap[_ref.type] || "journalArticle",
              url: cnkiURL
            });
          } else {
            info.references?.push({
              identifiers: {},
              text: refText,
              authors: [],
              type: "journalArticle",
              title: refText
            });
          }
        });
      } else {
        refData.content.refer.sort((a, b) => Number(a.citationNumber) - Number(b.citationNumber)).forEach((ref) => {
          const title = ref.title.replace(/^\[\d+\]/, "");
          const cnkiURL = `https://kns.cnki.net/kcms/detail/detail.aspx?FileName=${ref.fileName}&DbName=${ref.tableName}&DbCode=${ref.dbSource.split("_")[0]}`;
          info.references?.push(
            {
              identifiers: {
                CNKI: cnkiURL
              },
              authors: ref.author.split(";").filter((s) => s.length),
              type: typeMap[ref.type] || "journalArticle",
              text: `${ref.author}. ${title}[${ref.type[0]}]. ${ref.source}, ${ref.year}, ${ref.volumn}:${ref.pageNumber}.`,
              title: ref.title,
              year: ref.year,
              url: cnkiURL,
              number: Number(ref.citationNumber)
            }
          );
        });
      }
      return info;
    }
  };
  var api_default = API;

  // src/modules/pdf.ts
  var PDF = class {
    constructor(utils) {
      this.utils = utils || new utils_default();
      this.refRegex = [
        [/^\(\d+\)\s?/],
        // (1)
        [/^\[\d{0,3}\].+?[\,\.\uff0c\uff0e]?/],
        // [10] Polygon
        [/^\uff3b\d{0,3}\uff3d.+?[\,\.\uff0c\uff0e]?/],
        // ［1］
        [/^\d+[\,\.\uff0c\uff0e]/],
        // 1. Polygon
        [/^\d+[^\d\w]+?[\,\.\uff0c\uff0e]?/],
        // 1. Polygon
        [/^\[.+?\].+?[\,\.\uff0c\uff0e]?/],
        // [RCK + 20] 
        [/^\d+\s+/],
        // 1 Polygon
        [/^[A-Z]\w.+?\(\d+[a-z]?\)/, /^[A-Z][A-Za-z]+[\,\.\uff0c\uff0e]?/, /^.+?,.+.,/, /^[\u4e00-\u9fa5]{1,4}[\,\.\uff0c\uff0e]?/]
        // 中文
      ];
    }
    async getReferences(reader, fromCurrentPage) {
      let refLines = await this.getRefLines(reader, fromCurrentPage);
      const maxHeight = reader._internalReader._lastView._iframeWindow.PDFViewerApplication.pdfViewer._pages[0].viewport.viewBox[3];
      if (refLines.length == 0) {
        new ztoolkit.ProgressWindow("[Fail] PDF", { closeOtherProgressWindows: true }).createLine({
          text: "Function getRefLines: 0 refLines",
          type: "fail"
        }).show();
        return [];
      }
      let references = this.mergeSameRef(refLines);
      if (references.length > 0) {
        new ztoolkit.ProgressWindow("[Done] PDF", { closeOtherProgressWindows: true }).createLine({
          text: `${references.length} references`,
          type: "success"
        }).show();
      } else {
        new ztoolkit.ProgressWindow("[Fail] PDF", { closeOtherProgressWindows: true }).createLine({
          text: "Function mergeSameRef: 0 reference",
          type: "fail"
        }).show();
      }
      ztoolkit.log("references", references);
      for (let i = 0; i < references.length; i++) {
        let ref = { ...references[i] };
        ref.text = ref.text.trim().replace(/^[^0-9a-zA-Z]\s*\d+\s*[^0-9a-zA-Z]/, "").replace(/^\d+[\.\s]?/, "").trim();
        references[i] = {
          text: ref.text,
          ...this.utils.refText2Info(ref.text),
          x: ref._x,
          y: ref.y + ref.height
        };
        references[i].url = ref.url || references[i].url;
      }
      return references;
    }
    /**
     * Merge patrs with the same height to one part
     * @param items 
     * @returns 
     */
    mergeSameLine(items) {
      let toLine = (item) => {
        let line = {
          x: parseFloat(item.transform[4].toFixed(1)),
          y: parseFloat(item.transform[5].toFixed(1)),
          text: item.str || "",
          height: item.height,
          width: item.width,
          url: item?.url,
          _height: [item.height]
        };
        if (line.width < 0) {
          line.x += line.width;
          line.width = -line.width;
        }
        return line;
      };
      let j = 0;
      let lines = [toLine(items[j])];
      for (j = 1; j < items.length; j++) {
        let line = toLine(items[j]);
        let lastLine = lines.slice(-1)[0];
        if (line.y == lastLine.y || line.y >= lastLine.y && line.y < lastLine.y + lastLine.height || line.y + line.height > lastLine.y && line.y + line.height <= lastLine.y + lastLine.height) {
          lastLine.text += " " + line.text;
          lastLine.width += line.width;
          lastLine.url = lastLine.url || line.url;
          lastLine._height.push(line.height);
        } else {
          let hh = lastLine._height;
          const num = {};
          for (let i = 0; i < hh.length; i++) {
            num[String(hh[i])] ??= 0;
            num[String(hh[i])] += 1;
          }
          lastLine.height = Number(
            Object.keys(num).sort((h1, h2) => {
              return num[h2] - num[h1];
            })[0]
          );
          lines.push(line);
        }
      }
      return lines;
    }
    /**
     * 如果是参考文献格式的开头，返回类型；否则返回-1
     * @param text 
     * @returns 
     */
    getRefType(text) {
      for (let i = 0; i < this.refRegex.length; i++) {
        let flags = new Set(this.refRegex[i].map((regex) => {
          return regex.test(text.trim()) || regex.test(text.replace(/\s+/g, ""));
        }));
        if (flags.has(true)) {
          ztoolkit.log(text, i);
          return i;
        }
      }
      return -1;
    }
    /**
     * 把多行合并为一个完整的参考文献
     * @param refLines 
     * @returns 
     */
    mergeSameRef(refLines) {
      const _refLines = [...refLines];
      ztoolkit.log(this.copy(_refLines));
      let firstLine = refLines[0];
      let firstX = firstLine.x;
      let secondLine = refLines.slice(1).find((line) => {
        return line.x != firstX && this.abs(line.x - firstX) < 10 * firstLine.height;
      });
      ztoolkit.log(secondLine);
      let indent = secondLine ? firstX - secondLine.x : 0;
      ztoolkit.log("indent", indent);
      let refType = this.getRefType(firstLine.text);
      ztoolkit.log(firstLine.text, refType);
      let ref;
      for (let i = 0; i < refLines.length; i++) {
        let line = refLines[i];
        let text = line.text;
        let lineRefType = this.getRefType(text);
        if (
          // this.abs(line.x - firstX) < line.height * 1.2 &&
          // 跳过验证其它，特别小心
          lineRefType == refType && refType <= 2 || indent == 0 && lineRefType != -1 && lineRefType == refType && this.abs(firstX - line.x) < (this.abs(indent) || line.height) * 0.5 || indent != 0 && lineRefType == refType && _refLines.find(
            (_line) => line != _line && (line.x - _line.x) * indent > 0 && this.abs(line.x - _line.x) >= this.abs(indent) && this.abs(this.abs(line.x - _line.x) - this.abs(indent)) < 2 * line.height
          ) !== void 0
        ) {
          ref = line;
          ztoolkit.log("->", line.text);
        } else if (ref) {
          if (ref && i / refLines.length > 0.9 && this.abs(this.abs(ref.x - line.x) - this.abs(indent)) > 5 * line.height) {
            refLines = refLines.slice(0, i);
            ztoolkit.log("x", line.text, this.abs(this.abs(ref.x - line.x) - this.abs(indent)), 5 * line.height);
            break;
          }
          ztoolkit.log("+", text);
          ref.text = ref.text.replace(/-$/, "") + (ref.text.endsWith("-") ? "" : " ") + text;
          if (line.url) {
            ref.url = line.url;
          }
          refLines[i] = false;
        }
      }
      return refLines.filter((e) => e);
    }
    /**
     * 判断A和B两个矩形是否几何相交
     * @param A 
     * @param B 
     * @returns 
     */
    isIntersect(A, B) {
      if (B.right < A.left || B.left > A.right || B.bottom > A.top || B.top < A.bottom) {
        return false;
      } else {
        return true;
      }
    }
    /**
     * 为items每个item更新对应annotations中annotation的链接信息
     */
    updateItemsAnnotions(items, annotations) {
      let toBox = (rect) => {
        let [left, bottom, right, top] = rect;
        return { left, bottom, right, top };
      };
      annotations.forEach((annotation) => {
        let annoBox = toBox(annotation.rect);
        items.forEach((item) => {
          let [x, y] = item.transform.slice(4);
          let itemBox = toBox([x, y, x + item.width, y + item.height]);
          if (this.isIntersect(annoBox, itemBox)) {
            item["url"] = annotation?.url || annotation?.unsafeUrl;
          }
        });
      });
    }
    /**
     * 读取PDF一页面为lines对象
     * @param pdfPage 
     * @returns 
     */
    async readPdfPage(pdfPage) {
      let textContent = await pdfPage.getTextContent();
      let items = textContent.items.filter((item) => item.str.trim().length);
      if (items.length == 0) {
        return [];
      }
      let annotations = await pdfPage.getAnnotations();
      ztoolkit.log("items", this.copy(items));
      this.updateItemsAnnotions(items, annotations);
      let lines = this.mergeSameLine(items);
      return lines;
    }
    async getRefLines(reader, fromCurrentPage, fullText = false) {
      const PDFViewerApplication = reader._internalReader._lastView._iframeWindow.PDFViewerApplication;
      await PDFViewerApplication.pdfLoadingTask.promise;
      await PDFViewerApplication.pdfViewer.pagesPromise;
      let pages = PDFViewerApplication.pdfViewer._pages;
      let pageLines = {};
      let maxWidth, maxHeight;
      let offset = 0;
      if (fromCurrentPage) {
        offset = pages.length - PDFViewerApplication.page;
      }
      const totalPageNum = pages.length - offset;
      const minPreLoadPageNum = parseInt(Zotero.Prefs.get(`${config.addonRef}.preLoadingPageNum`));
      let preLoadPageNum = totalPageNum > minPreLoadPageNum ? minPreLoadPageNum : totalPageNum;
      const popupWin = new ztoolkit.ProgressWindow("[Pending] PDF", { closeTime: -1, closeOtherProgressWindows: true });
      popupWin.createLine({
        text: `[0/${preLoadPageNum}] Analysis PDF`,
        type: "success",
        progress: 1
      }).show();
      for (let pageNum = totalPageNum - 1; pageNum >= totalPageNum - preLoadPageNum; pageNum--) {
        let pdfPage = pages[pageNum].pdfPage;
        maxWidth = pdfPage._pageInfo.view[2];
        maxHeight = pdfPage._pageInfo.view[3];
        let lines = await this.readPdfPage(pdfPage);
        if (lines.length == 0) {
          continue;
        }
        pageLines[pageNum] = lines;
        let pct = (totalPageNum - pageNum) / preLoadPageNum * 100;
        popupWin.changeLine({
          text: `[${totalPageNum - pageNum}/${preLoadPageNum}] Read text`,
          progress: pct > 90 ? 90 : pct
        });
      }
      let parts = [];
      let part = [];
      let refPart = [];
      let _refPart = { done: false, parts: [] };
      let sep = "\n\n===current page===\n\n";
      for (let pageNum = totalPageNum - 1; pageNum >= 1; pageNum--) {
        ztoolkit.log(sep, pageNum + 1);
        let pdfPage = pages[pageNum].pdfPage;
        maxWidth = pdfPage._pageInfo.view[2];
        maxHeight = pdfPage._pageInfo.view[3];
        ztoolkit.log(`maxWidth=${maxWidth}, maxHeight=${maxHeight}`);
        let lines;
        if (pageNum in pageLines) {
          lines = [...pageLines[pageNum]];
        } else {
          lines = await this.readPdfPage(pdfPage);
          pageLines[pageNum] = [...lines];
          let p = totalPageNum - pageNum;
          popupWin.changeLine({ text: `[${p}/${p}] Read PDF` });
        }
        if (lines.length == 0) {
          continue;
        }
        let removeNumber = (text) => {
          if (/^[A-Z]{1,3}$/.test(text)) {
            text = "";
          }
          text = text.replace(/\s+/g, "").replace(/\d+/g, "");
          return text;
        };
        const isSamePosition = (lineA, lineB) => {
          const round = (n) => Math.round(n);
          if (round(lineA.x) == round(lineB.x) && round(lineA.y) == round(lineB.y) && round(lineA.width) == round(lineB.width) && round(lineA.height) == round(lineB.height)) {
            return true;
          } else {
            return false;
          }
        };
        const isSameText = (lineA, lineB) => {
          const textA = removeNumber(lineA.text);
          const textB = removeNumber(lineB.text);
          return textA == textB;
        };
        lines.forEach((line) => {
          if (line.x / maxWidth > 0.2 && line.y / maxHeight > 0.2 && (line.x + line.width) / maxWidth < 0.8 && (line.y + line.height) / maxHeight < 0.8 || line.same) {
            return;
          }
          for (const _pageIndex in pageLines) {
            if (Number(_pageIndex) == pageNum) {
              continue;
            }
            pageLines[_pageIndex].find((_line) => {
              if (isSameText(line, _line) && isSamePosition(line, _line)) {
                ztoolkit.log(line, _line);
                line.same = _line;
                return true;
              }
            });
          }
        });
        lines = lines.filter((e) => !e.same);
        if (lines.length == 0) {
          continue;
        }
        ztoolkit.log("remove", [...lines.filter((e) => e.same)]);
        let isFigureOrTable = (text) => {
          text = text.replace(/\s+/g, "");
          const flag = /^(Table|Fig|Figure).*\d/i.test(text);
          if (flag) {
            ztoolkit.log(`isFigureOrTable - skip - ${text}`);
          }
          return flag;
        };
        lines = lines.filter((e) => isFigureOrTable(e.text) == false);
        let columns = [[lines[0]]];
        for (let i = 1; i < lines.length; i++) {
          let line = lines[i];
          let column = columns.slice(-1)[0];
          if (line.y > column.slice(-1)[0].y || column.map((_line) => Number(line.x > _line.x + _line.width)).reduce((a, b) => a + b) == column.length || column.map((_line) => Number(line.x + line.width < _line.x)).reduce((a, b) => a + b) == column.length) {
            columns.push([line]);
          } else {
            column.push(line);
          }
        }
        ztoolkit.log("columns", this.copy(columns));
        columns.forEach((column, columnIndex) => {
          column.forEach((line) => {
            line["column"] = columnIndex;
            line["pageNum"] = pageNum;
          });
        });
        ztoolkit.log("remove indent", this.copy(lines));
        let isStart = false;
        let donePart = (part2) => {
          part2.reverse();
          let columns2 = [[part2[0]]];
          for (let i = 1; i < part2.length; i++) {
            let line = part2[i];
            if (line.column == columns2.slice(-1)[0].slice(-1)[0].column && line.pageNum == columns2.slice(-1)[0].slice(-1)[0].pageNum) {
              columns2.slice(-1)[0].push(line);
            } else {
              columns2.push([line]);
            }
          }
          columns2.forEach((column) => {
            let offset2 = column.map((line) => line.x).sort((a, b) => a - b)[0];
            column.forEach((line) => {
              line["_x"] = line.x;
              line["_offset"] = offset2;
              line.x = parseInt((line.x - offset2).toFixed(1));
            });
          });
          parts.push(part2);
          return part2;
        };
        let isRefBreak = (text) => {
          text = text.replace(/\s+/g, "");
          if (fullText) {
            return false;
          } else {
            return /(\u53c2\u8003\u6587\u732e|reference|bibliography)/i.test(text) && text.length < 20;
          }
        };
        let doneRefPart = (part2) => {
          part2 = donePart(part2);
          _refPart.parts.push(part2);
          ztoolkit.log("doneRefPart", part2[0].text);
          let res = part2[0].text.trim().match(/^\d+/);
          if (res && res[0] != "1") {
            _refPart.done = false;
          } else {
            _refPart.done = true;
          }
        };
        let endLines = lines.filter((line) => {
          return lines.every((_line) => {
            if (_line == line) {
              return true;
            }
            return _line.x + _line.width < line.x + line.width || _line.y > line.y;
          });
        });
        let heightOverlap = (hh1, hh2) => {
          return hh1.some((h1) => {
            return hh2.some((h2) => h1 - h2 < (h1 > h2 ? h2 : h1) * 0.3);
          });
        };
        const endLine = endLines.slice(-1)[0];
        ztoolkit.log("endLine", endLine);
        for (let i = lines.length - 1; i >= 0; i--) {
          let line = lines[i];
          if (
            // !isStart && pageNum < totalPageNum - 1 &&
            // 考虑到有些PDF最后一页以图表结尾
            !isStart && // 图表等
            // 我们认为上一页的正文（非图表）应从页面最低端开始
            (line != endLine || // ((line.x + line.width) / maxWidth < 0.7 && line.y > pageYmin) ||
            /(图|fig|Fig|Figure).*\d+/.test(line.text.replace(/\s+/g, "")))
          ) {
            ztoolkit.log("Not the endLine, skip", line.text);
            if (part.length && pageNum == totalPageNum - 1) {
              donePart(part);
              part = [];
            }
            continue;
          } else {
            isStart = true;
          }
          if (part.length > 0 && // part.slice(-1)[0].height != line.height
          !heightOverlap(part.slice(-1)[0]._height, line._height)) {
            donePart(part);
            part = [line];
            continue;
          }
          if (isRefBreak(line.text)) {
            ztoolkit.log("isRefBreak", line.text);
            doneRefPart(part);
            part = [];
            break;
          }
          part.push(line);
          if (
            // 以下条件满足则页内断开
            lines[i - 1] && // line.height != lines[i - 1].height ||
            // this.abs(line.height - lines[i - 1].height) > line.height * .5 ||
            (!heightOverlap(line._height, lines[i - 1]._height) || lines[i].column < lines[i - 1].column || line.pageNum == lines[i - 1].pageNum && line.column == lines[i - 1].column && // 增大行间距阈值
            this.abs(line.y - lines[i - 1].y) > line.height * 3)
          ) {
            if (isRefBreak(lines[i - 1].text)) {
              ztoolkit.log("isRefBreak", lines[i - 1].text);
              doneRefPart(part);
              part = [];
              break;
            }
            donePart(part);
            part = [];
            ztoolkit.log("break", line.text, " - ", lines[i - 1].text, this.copy(line), this.copy(lines[i - 1]));
          }
        }
        if (_refPart.done) {
          ztoolkit.log(_refPart);
          _refPart.parts.reverse().forEach((part2) => {
            refPart = [...refPart, ...part2];
          });
          break;
        }
      }
      popupWin.changeLine({ progress: 100 });
      ztoolkit.log("parts", this.copy(parts));
      ztoolkit.log(refPart);
      if (refPart.length == 0) {
        let partRefNum = [];
        for (let i2 = 0; i2 < parts.length; i2++) {
          let isRefs = parts[i2].map((line) => Number(this.getRefType(line.text) != -1));
          partRefNum.push([i2, isRefs.reduce((a, b) => a + b)]);
        }
        ztoolkit.log(partRefNum);
        let i = partRefNum.sort((a, b) => b[1] - a[1])[0][0];
        refPart = parts[i];
      }
      ztoolkit.log("refPart", this.copy(refPart));
      popupWin.changeHeadline("[Done] PDF");
      popupWin.changeLine({ progress: 100 });
      popupWin.startCloseTimer(3e3);
      if (fullText) {
        return parts;
      } else {
        return refPart;
      }
    }
    copy(obj) {
      try {
        return JSON.parse(JSON.stringify(obj));
      } catch (e) {
        ztoolkit.log("Error copy", e, obj);
      }
    }
    abs(v) {
      return v > 0 ? v : -v;
    }
  };
  var pdf_default = PDF;

  // src/modules/utils.ts
  var Utils = class {
    constructor() {
      this.cache = {};
      this.regex = {
        DOI: /10\.\d{4,9}\/[-\._;\(\)\/:A-z0-9><]+[^\.\]]/,
        arXiv: /arXiv[\.:](\d+\.\d+)/,
        URL: /https?:\/\/[^\s\.]+/
      };
      this.copyText = (text, show = true) => {
        new ztoolkit.Clipboard().addText(text, "text/unicode").copy();
        if (show) {
          new ztoolkit.ProgressWindow("Copy").createLine({ text, type: "success" }).show();
        }
      };
      this.API = new api_default(this);
      this.PDF = new pdf_default(this);
    }
    getIdentifiers(text) {
      const targets = [
        {
          key: "DOI",
          ignoreSpace: true,
          regex: this.regex.DOI
        },
        {
          key: "arXiv",
          ignoreSpace: true,
          regex: this.regex.arXiv
        }
      ];
      let identifiers = {};
      for (let target of targets) {
        let res = (target.ignoreSpace ? text.replace(/\s+/g, "") : text).match(target.regex);
        if (res) {
          identifiers[target.key] = res.slice(-1)[0];
        }
      }
      return identifiers;
    }
    extractURL(text) {
      let res = text.match(this.regex.URL);
      if (res) {
        return res.slice(-1)[0];
      }
    }
    parseRefText(text) {
      try {
        text = text.replace(/^\[\d+?\]/, "");
        text = text.replace(/\s+/g, " ");
        let title, titleMatch;
        if (/\u201c(.+)\u201d/.test(text)) {
          [titleMatch, title] = text.match(/\u201c(.+)\u201d/);
          if (title.endsWith(",")) {
            title = title.slice(0, -1);
          }
        } else {
          title = titleMatch = (text.indexOf(". ") != -1 && text.match(/\.\s/g).length >= 2 && text.split(". ") || text.split(".")).sort((a, b) => b.length - a.length).map((s) => {
            let count = 0;
            [/[A-Z]\./g, /[,\.\-\(\)\:]/g, /\d/g].forEach((regex) => {
              let res2 = s.match(regex);
              count += res2 ? res2.length : 0;
            });
            return [count / s.length, s];
          }).filter((s) => s[1].match(/\s+/g)?.length >= 3).sort((a, b) => a[0] - b[0])[0][1];
          if (/\[[A-Z]\]$/.test(title)) {
            title = title.replace(/\[[A-Z]\]$/, "");
          }
        }
        title = title.trim();
        let splitByTitle = text.split(titleMatch);
        let authorInfo = splitByTitle[0].trim();
        let publicationVenue = splitByTitle[1].match(/[^.\s].+[^\.]/)[0].split(/[,\d]/)[0].trim();
        if (authorInfo.indexOf("et al.") != -1) {
          authorInfo = authorInfo.split("et al.")[0] + "et al.";
        }
        const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
        let res = text.match(/[^\d]\d{4}[^\d-]/g)?.map((s) => s.match(/\d+/)[0]);
        let year = res?.find((s) => {
          return Number(s) <= Number(currentYear) + 1;
        });
        authorInfo = authorInfo.replace(`${year}.`, "").replace(year, "").trim();
        return { year, title, authors: [authorInfo], publicationVenue };
      } catch {
        return {
          title: text
        };
      }
    }
    _parseRefText(text) {
      let year;
      let _years = text.match(/[^\d]?(\d{4})[^\d]?/g);
      if (_years) {
        let years = _years.map((year2) => Number(year2.match(/\d{4}/)[0])).filter((year2) => year2 > 1900 && year2 < (/* @__PURE__ */ new Date()).getFullYear());
        if (years.length > 0) {
          year = String(years[0]);
        }
      }
      year = year;
      if (this.isChinese(text)) {
        let parts = text.replace(/\[.+?\]/g, "").replace(/\s+/g, " ").split(/[\.,\uff0c\uff0e\uff3b\[\]]/).map((e) => e.trim()).filter((e) => e);
        let authors = [];
        let titles = [];
        for (let part of parts) {
          if (part.length <= 3 && part.length >= 2) {
            authors.push(part);
          } else {
            titles.push(part);
          }
        }
        let title = titles.sort((a, b) => b.length - a.length)[0];
        return { title, authors, year };
      } else {
        let authors = [];
        text = text.replace(/[\u4e00-\u9fa5]/g, "");
        const authorRegexs = [/[A-Za-z,\.\s]+?\.?[\.,;]/g, /[A-Z][a-z]+ et al.,/];
        authorRegexs.forEach((regex) => {
          text.match(regex)?.forEach((author) => {
            authors.push(author.slice(0, -1));
          });
        });
        let title = text.split(/[,\.]\s/g).filter((e) => !e.includes("http")).sort((a, b) => b.length - a.length)[0];
        return { title, authors, year };
      }
    }
    identifiers2URL(identifiers) {
      let url;
      if (identifiers.DOI) {
        url = `https://doi.org/${identifiers.DOI}`;
      }
      if (identifiers.arXiv) {
        url = `https://arxiv.org/abs/${identifiers.arXiv}`;
      }
      return url;
    }
    refText2Info(text) {
      let identifiers = this.getIdentifiers(text);
      return {
        identifiers,
        url: this.extractURL(text) || this.identifiers2URL(identifiers),
        authors: [],
        ...this.parseRefText(text),
        type: identifiers.arXiv ? "preprint" : "journalArticle"
      };
    }
    parseCNKIURL(cnkiURL) {
      try {
        let fileName = cnkiURL.match(/fileName=(\w+)/i)[1];
        let dbName = cnkiURL.match(/dbName=(\w+)/i)[1];
        let dbCode = cnkiURL.match(/dbCode=(\w+)/i)[1];
        return { fileName, dbName, dbCode };
      } catch {
      }
    }
    async createItemByZotero(identifiers, collections) {
      var translate = new Zotero.Translate.Search();
      translate.setIdentifier(identifiers);
      let translators = await translate.getTranslators();
      translate.setTranslator(translators);
      let libraryID = ZoteroPane.getSelectedLibraryID();
      return (await translate.translate({
        libraryID,
        collections,
        saveAttachments: true
      }))[0];
    }
    async createItemByJasminum(title) {
      let cnkiURL = await this.API.getCNKIURL(title, true);
      ztoolkit.log("cnkiURL", cnkiURL);
      let articleId = Zotero.Jasminum.Scrape.getIDFromURL(cnkiURL);
      let postData = Zotero.Jasminum.Scrape.createRefPostData([articleId]);
      let data = await Zotero.Jasminum.Scrape.getRefText(postData);
      let items = await Zotero.Jasminum.Utils.trans2Items(data, 1);
      if (items) {
        let item = items[0];
        item.setField("url", cnkiURL);
        await item.saveTx();
        return item;
      }
    }
    searchRelatedItem(item, refItem) {
      if (!item) {
        return;
      }
      let relatedItems = item.relatedItems.map((key) => Zotero.Items.getByLibraryAndKey(1, key));
      if (refItem) {
        let relatedItem = relatedItems.find((item2) => refItem.id == item2.id);
        return relatedItem;
      }
    }
    async searchItem(info) {
      if (!info) {
        return;
      }
      let s = new Zotero.Search();
      s.addCondition("joinMode", "any");
      if (info.identifiers.DOI) {
        s.addCondition("DOI", "is", info.identifiers.DOI);
        s.addCondition("DOI", "is", info.identifiers.DOI.toLowerCase());
        s.addCondition("DOI", "is", info.identifiers.DOI.toUpperCase());
      } else {
        if (info.title && info.title?.length > 8) {
          s.addCondition("title", "contains", info.title);
        }
        s.addCondition("url", "contains", info.identifiers.arXiv);
        s.addCondition("url", "contains", info.identifiers.CNKI);
      }
      var ids = await s.search();
      let items = (await Zotero.Items.getAsync(ids)).filter((i) => {
        return !i.itemType.startsWith("attachment") && i.isRegularItem && i.isRegularItem();
      });
      if (items.length) {
        return items[0];
      }
    }
    /**
     * 搜索本地，获取参考文献的本地item引用
     * @param info 
     * @returns 
     */
    async searchLibraryItem(info) {
      await Zotero.Promise.delay(0);
      const key = JSON.stringify(info.identifiers) + info.text + "library-item";
      if (key in this.cache) {
        info._item = this.cache[key];
        return this.cache[key];
      } else {
        let items = await Zotero.Items.getAll(1);
        let getPureText = (s) => this.cache["getPureText" + s] ??= s.toLowerCase().match(/[0-9a-z\u4e00-\u9fa5]+/g)?.join("");
        let item = await this.searchItem(info) || items.filter((i) => i.isRegularItem() && i.getField("title") && ["journalArtical", "preprint", "book"].indexOf(i.itemType) != -1).find((item2) => {
          try {
            let title = item2.getField("title");
            if (!this.isChinese(title) && title.split(" ").length < 4) {
              return false;
            }
            title = getPureText(title);
            const searchTitle = getPureText(info.title || info.text);
            if (searchTitle.length > 10 && title && searchTitle && (title?.indexOf(searchTitle) != -1 || searchTitle?.indexOf(title) != -1)) {
              return item2;
            }
          } catch (e) {
          }
        });
        if (item) {
          info._item = item;
          this.cache[key] = item;
          info.title = item.getField("title");
          let DOI = item.getField("DOI");
          if (DOI) {
            info.identifiers = { DOI };
          }
        }
        return item;
      }
    }
    selectItemInLibrary(item) {
      Zotero_Tabs.select("zotero-pane");
      ZoteroPane.selectItem(item.id);
    }
    getItemType(item) {
      if (!item) {
        return;
      }
      return Zotero.ItemTypes.getName(
        item.getField("itemTypeID")
      );
    }
    isChinese(text) {
      text = text.replace(/\s+/g, "");
      return (text.match(/[\u4E00-\u9FA5]/g)?.length || 0) / text.length > 0.5;
    }
    isDOI(text) {
      if (!text) {
        return false;
      }
      let res = text.match(this.regex.DOI);
      if (res) {
        return res[0] == text && !/(cnki|issn)/i.test(text);
      } else {
        return false;
      }
    }
    matchArXiv(text) {
      let res = text.match(this.regex.arXiv);
      if (res != null && res.length >= 2) {
        return res[1];
      } else {
        return false;
      }
    }
    Html2Text(html) {
      if (!html) {
        return "";
      }
      let text;
      try {
        let span = document.createElement("span");
        span.innerHTML = html;
        text = span.innerText || span.textContent;
        span = null;
      } catch (e) {
        text = html;
      }
      if (text) {
        text = text.replace(/<([\w:]+?)>([\s\S]+?)<\/\1>/g, (match, p1, p2) => p2).replace(/\n+/g, "");
      }
      return text;
    }
    getReader() {
      return Zotero.Reader.getByTabID(Zotero_Tabs.selectedID);
    }
    getItem() {
      let reader = this.getReader();
      if (reader) {
        return reader._item.parentItem;
      }
    }
    abs(v) {
      return v > 0 ? v : -v;
    }
  };
  var utils_default = Utils;

  // src/modules/tip.ts
  var TipUI = class {
    constructor() {
      this.option = {
        size: 8,
        color: {
          active: "#FF597B",
          default: "#F9B5D0"
        }
      };
      this.shadeMillisecond = parseInt(Zotero.Prefs.get(`${config.addonRef}.shadeMillisecond`));
      this.removeTipAfterMillisecond = parseInt(Zotero.Prefs.get(`${config.addonRef}.removeTipAfterMillisecond`));
      this.utils = new utils_default();
    }
    onInit(refRect, position) {
      this.refRect = refRect;
      this.position = position;
      this.clear();
      this.buildContainer();
    }
    clear() {
      document.querySelectorAll(".zotero-reference-tip-container").forEach((e) => {
        e.style.opacity = "0";
        window.setTimeout(() => {
          e.remove();
        }, this.shadeMillisecond);
      });
    }
    /**
     * 放置container到合适位置
     * 
     */
    place() {
      `
		winRect = {
			bottom: 792
			height: 792
			left: 0
			right: 1536
			top: 0
			width: 1536
			x: 0
			y: 0
		}
		eleRect = {
			bottom: 188
			height: 16
			left: 1196
			right: 1507
			top: 172
			width: 310
			x: 1196
			y: 172
		}
		\u53F3\u4E0A(x=0, y=0)
		`;
      let setStyles = (styles2) => {
        for (let k in styles2) {
          this.container.style[k] = styles2[k];
        }
        return this.container.getBoundingClientRect();
      };
      const winRect = document.documentElement.getBoundingClientRect();
      const maxWidth = winRect.width;
      const maxHeight = winRect.height;
      const refRect = this.refRect;
      let styles;
      if (this.position == "left") {
        styles = {
          // right: `${maxWidth - refRect.x + maxWidth * .014}px`,
          right: `${maxWidth - refRect.x}px`,
          bottom: "",
          top: `${refRect.y}px`,
          width: `${refRect.x * 0.7}px`
        };
      } else if (this.position == "top center") {
        let width = maxWidth * 0.7;
        styles = {
          width: `${width}px`,
          left: `${refRect.x + refRect.width / 2 - width / 2}px`,
          bottom: `${maxHeight - refRect.y}px`,
          top: ""
        };
        this.container.style.flexDirection = "column-reverse";
      }
      let rect = setStyles(styles);
      if (rect.bottom > maxHeight) {
        setStyles({
          top: "",
          bottom: "0px"
        });
        this.container.style.flexDirection = "column-reverse";
      }
      if (rect.top < 0) {
        setStyles({
          bottom: "",
          top: "0px"
        });
      }
      if (rect.left < 30) {
        setStyles({
          right: "",
          left: "30px"
        });
      }
      if (maxWidth - rect.right < 30) {
        setStyles({
          left: "",
          right: "30px"
        });
      }
      this.container.style.opacity = "1";
      return;
    }
    buildContainer() {
      this.container = ztoolkit.UI.createElement(
        document,
        "div",
        {
          namespace: "html",
          classList: ["zotero-reference-tip-container"],
          styles: {
            display: "flex",
            flexDirection: "column",
            justifyContent: "center",
            position: "fixed",
            zIndex: "999",
            // border: "2px solid transparent",
            padding: "1em",
            backgroundColor: Zotero.Prefs.get(`${config.addonRef}.tipBackgroundColor`),
            opacity: "0",
            transition: `opacity ${this.shadeMillisecond / 1e3}s linear`,
            "-moz-user-select": "text",
            boxShadow: "0 4px 24px rgb(0 0 0 / 20%)",
            borderRadius: "8px"
          },
          listeners: [
            {
              type: "DOMMouseScroll",
              listener: (event) => {
                if (event.ctrlKey) {
                  this.zoom(event);
                }
              }
            },
            {
              type: "mouseenter",
              listener: () => {
                window.clearTimeout(this.tipTimer);
              }
            },
            {
              type: "mouseleave",
              listener: () => {
                this.tipTimer = window.setTimeout(() => {
                  this.container.remove();
                }, this.removeTipAfterMillisecond);
              }
            }
          ],
          children: [
            {
              tag: "box",
              id: "option-container",
              styles: {
                width: "100%",
                height: `${this.option.size}px`,
                display: "flex",
                flexDirection: "row",
                alignItems: "center",
                justifyContent: "center",
                marginBottom: ".25em",
                marginTop: ".25em"
              }
            },
            {
              tag: "box",
              id: "content-container",
              styles: {
                width: "100%"
              }
            }
          ]
        }
      );
      document.documentElement.appendChild(this.container);
    }
    /**
     * @param title 标题
     * @param tags 标签
     * @param descriptions 描述，一般是期刊，年份作者等
     * @param content 正文，一般是摘要
     * @returns 
     */
    addTip(title, tags, descriptions, content, according, index, prefIndex) {
      const translate = async (text) => {
        if (Zotero.ZoteroPDFTranslate) {
          Zotero.ZoteroPDFTranslate._sourceText = text;
          const success = await Zotero.ZoteroPDFTranslate.translate.getTranslation();
          if (!success) {
            Zotero.ZoteroPDFTranslate.view.showProgressWindow(
              "Translate Failed",
              success,
              "fail"
            );
            return;
          }
          return Zotero.ZoteroPDFTranslate._translatedText;
        } else if (Zotero.PDFTranslate) {
          return (await Zotero.PDFTranslate.api.translate(text))?.result;
        }
      };
      let translateNode = async function(event) {
        if ((Zotero.isMac && event.metaKey && !event.ctrlKey || !Zotero.isMac && event.ctrlKey) && Zotero.Prefs.get(`${config.addonRef}.ctrlClickTranslate`)) {
          let node = this;
          let sourceText = node.getAttribute("sourceText");
          let translatedText = node.getAttribute("translatedText");
          ztoolkit.log(sourceText, translatedText);
          if (!sourceText) {
            sourceText = node.innerText;
            node.setAttribute("sourceText", sourceText);
          }
          if (!translatedText) {
            translatedText = await translate(sourceText);
            node.setAttribute("translatedText", translatedText);
          }
          if (node.innerText == sourceText) {
            ztoolkit.log("-> translatedText");
            node.innerText = translatedText;
          } else if (node.innerText == translatedText) {
            node.innerText = sourceText;
            ztoolkit.log("-> sourceText");
          }
        }
      };
      const isSelect = index !== void 0 && prefIndex !== void 0 && index == prefIndex || this.container.querySelector("#option-container").childNodes.length == 0;
      if (isSelect) {
        this.reset();
      }
      const contentNode = ztoolkit.UI.createElement(
        document,
        "div",
        {
          classList: ["zotero-reference-tip"],
          styles: {
            padding: "0px",
            width: "100%",
            display: isSelect ? "" : "none"
          },
          subElementOptions: [
            {
              tag: "span",
              classList: ["title"],
              styles: {
                display: "block",
                fontWeight: "bold",
                marginBottom: ".25em",
                fontSize: "1.2em",
                color: Zotero.Prefs.get(`${config.addonRef}.tipTitleColor`)
              },
              directAttributes: {
                innerText: title
              },
              listeners: [
                {
                  type: "click",
                  listener: translateNode
                }
              ]
            },
            ...tags && tags.length > 0 ? [{
              tag: "div",
              id: "tags",
              styles: {
                width: "100%"
                // margin: "0.5em 0",
              },
              subElementOptions: ((tags2) => {
                if (!tags2) {
                  return [];
                }
                let arr = [];
                for (let tag of tags2) {
                  arr.push({
                    tag: "span",
                    directAttributes: {
                      innerText: tag.text
                    },
                    styles: {
                      backgroundColor: tag.color,
                      borderRadius: "10px",
                      margin: "0.5em 1em 0.5em 0px",
                      display: "inline-block",
                      padding: "0 8px",
                      color: "white",
                      cursor: "pointer",
                      userSelect: "none"
                    },
                    listeners: [
                      {
                        type: "click",
                        listener: () => {
                          if (tag.url) {
                            new ztoolkit.ProgressWindow("Launching URL").createLine({ text: tag.url, type: "default" }).show();
                            Zotero.launchURL(tag.url);
                          } else if (tag.item) {
                            this.clear();
                            Zotero.ProgressWindowSet.closeAll();
                            this.utils.selectItemInLibrary(tag.item);
                          } else {
                            this.utils.copyText(tag.text);
                          }
                        }
                      },
                      {
                        type: "mouseenter",
                        listener: () => {
                          if (!tag.tip) {
                            return;
                          }
                          Zotero.ProgressWindowSet.closeAll();
                          new ztoolkit.ProgressWindow("Reference", { closeTime: -1 }).createLine({ text: tag.tip, type: "default" }).show();
                        }
                      },
                      {
                        type: "mouseleave",
                        listener: () => {
                          if (!tag.tip) {
                            return;
                          }
                          Zotero.ProgressWindowSet.closeAll();
                        }
                      }
                    ]
                  });
                }
                return arr;
              })(tags)
            }] : [],
            ...descriptions && descriptions.length > 0 ? [{
              tag: "div",
              id: "descriptions",
              styles: {
                marginBottom: "0.25em"
              },
              children: ((descriptions2) => {
                if (!descriptions2) {
                  return [];
                }
                let arr = [];
                for (let text of descriptions2) {
                  arr.push({
                    tag: "span",
                    id: "content",
                    styles: {
                      display: "block",
                      lineHeight: "1.5em",
                      opacity: "0.5",
                      cursor: "pointer",
                      userSelect: "none"
                    },
                    properties: {
                      innerText: text
                    },
                    listeners: [
                      {
                        type: "click",
                        listener: () => {
                          this.utils.copyText(text);
                        }
                      }
                    ]
                  });
                }
                return arr;
              })(descriptions)
            }] : [],
            {
              tag: "span",
              id: "content",
              properties: {
                innerText: content
              },
              styles: {
                display: "block",
                lineHeight: "1.5em",
                textAlign: "justify",
                opacity: "0.8",
                maxHeight: "300px",
                overflowY: "auto",
                marginTop: ".25em"
              },
              listeners: [
                {
                  type: "click",
                  listener: translateNode
                }
              ]
            }
          ]
        }
      );
      const optionNode = ztoolkit.UI.createElement(
        document,
        "div",
        {
          id: `option-${index}`,
          styles: {
            width: `${this.option.size}px`,
            height: `${this.option.size}px`,
            borderRadius: "50%",
            backgroundColor: isSelect ? this.option.color.active : this.option.color.default,
            marginLeft: `${this.option.size * 0.5}px`,
            marginRight: `${this.option.size * 0.5}px`,
            cursor: "pointer",
            transition: "background-color 0.23s linear"
          },
          listeners: [
            {
              type: "click",
              listener: () => {
                this.reset();
                optionNode.style.backgroundColor = this.option.color.active;
                contentNode.style.display = "";
                Zotero.Prefs.set(`${config.addonRef}.${according}InfoIndex`, index);
                this.place();
              }
            },
            {
              type: "mouseenter",
              listener: () => {
                let tag = tags.find((tag2) => tag2.source);
                let source = tag && tag.source && according && `${tag.source} view according to ${according}` || "reference view";
                Zotero.ProgressWindowSet.closeAll();
                new ztoolkit.ProgressWindow("Reference", { closeTime: -1 }).createLine({ text: source, type: "default" }).show();
              }
            },
            {
              type: "mouseleave",
              listener: () => {
                Zotero.ProgressWindowSet.closeAll();
              }
            }
          ]
        }
      );
      const optionContainer = this.container.querySelector("#option-container");
      const optionNodes = [...optionContainer.querySelectorAll("[id^=option]")];
      if (optionNodes.length == 0) {
        optionContainer.appendChild(optionNode);
      } else {
        let getIndex = (node) => Number(node.id.split("-")[1]);
        for (let i = 0; i < optionNodes.length; i++) {
          if (index > getIndex(optionNodes[i])) {
            if (i + 1 < optionNodes.length) {
              if (index < getIndex(optionNodes[i + 1])) {
                optionContainer.insertBefore(optionNode, optionNodes[i + 1]);
                break;
              }
            } else {
              optionContainer.appendChild(optionNode);
              break;
            }
          } else {
            optionContainer.insertBefore(optionNode, optionNodes[i]);
            break;
          }
        }
      }
      this.container.querySelector("#content-container").appendChild(contentNode);
      this.place();
    }
    reset() {
      this.container.querySelector("#content-container").childNodes.forEach((e) => {
        e.style.display = "none";
      });
      this.container.querySelector("#option-container").childNodes.forEach((e) => {
        e.style.backgroundColor = this.option.color.default;
      });
    }
    zoom(event) {
      let _scale = this.container.style.transform.match(/scale\((.+)\)/);
      let scale = _scale ? parseFloat(_scale[1]) : 1;
      let minScale = 1, maxScale = 1.7, step = 0.05;
      if (this.container.style.bottom == "0px") {
        this.container.style.transformOrigin = "center bottom";
      } else {
        this.container.style.transformOrigin = "center center";
      }
      if (event.detail > 0) {
        scale = scale - step;
        this.container.style.transform = `scale(${scale < minScale ? minScale : scale})`;
      } else {
        scale = scale + step;
        this.container.style.transform = `scale(${scale > maxScale ? maxScale : scale})`;
      }
    }
  };

  // src/modules/localStorage.ts
  var LocalStorage = class {
    constructor(filename) {
      this.lock = Zotero.Promise.defer();
      this.init(filename);
    }
    async init(filename) {
      const window2 = Zotero.getMainWindow();
      const OS = window2.OS;
      if (!await OS.File.exists(filename)) {
        const temp = Zotero.getTempDirectory();
        this.filename = OS.Path.join(temp.path.replace(temp.leafName, ""), `${filename}.json`);
      } else {
        this.filename = filename;
      }
      try {
        const rawString = await Zotero.File.getContentsAsync(this.filename);
        this.cache = JSON.parse(rawString);
        ztoolkit.log(this.cache);
      } catch {
        this.cache = {};
      }
      this.lock.resolve();
    }
    get(item, key) {
      if (this.cache == void 0) {
        ztoolkit.log("cache is undefined");
        return;
      }
      return (this.cache[item.key] ??= {})[key];
    }
    async set(item, key, value) {
      await this.lock.promise;
      (this.cache[item.key] ??= {})[key] = value;
      window.setTimeout(async () => {
        await Zotero.File.putContentsAsync(this.filename, JSON.stringify(this.cache));
      });
    }
  };
  var localStorage_default = LocalStorage;

  // src/modules/views.ts
  var localStorage = new localStorage_default(config.addonRef);
  var Views = class {
    constructor() {
      initLocale();
      this.utils = new utils_default();
      this.addStyle();
    }
    addStyle() {
      const styles = ztoolkit.UI.createElement(document, "style", {
        id: "reference-style",
        properties: {
          innerHTML: `
          .reference-search-box .icon {
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0.8;
          }
          .reference-search-box .icon:hover {
            opacity: 1
          }
        `
        }
      });
      document.documentElement.appendChild(styles);
    }
    /**
     * 注册阅读侧边栏
     */
    async onInit() {
      ztoolkit.ReaderTabPanel.register(
        getString("tabpanel-reader-tab-label"),
        (panel, deck, win, reader) => {
          if (!panel) {
            ztoolkit.log(
              "This reader do not have right-side bar. Adding reader tab skipped."
            );
            return;
          }
          let timer;
          const id = `${config.addonRef}-${reader._instanceID}-extra-reader-tab-div`;
          window.setTimeout(async () => {
            const relatedbox = ztoolkit.UI.createElement(
              document,
              "related-box",
              {
                id,
                classList: ["zotero-editpane-related"],
                namespace: "xul",
                ignoreIfExists: true,
                attributes: {
                  flex: "1"
                },
                styles: {
                  alignItems: "center"
                },
                children: [
                  {
                    tag: "box",
                    namespace: "xul",
                    classList: ["reference"],
                    attributes: {
                      flex: "1"
                    },
                    styles: {
                      display: "flex"
                      // paddingLeft: "0px",
                      // paddingRight: "0px"
                    },
                    children: [
                      {
                        tag: "div",
                        namespace: "html",
                        styles: {
                          flexGrow: "1"
                        },
                        children: [
                          {
                            tag: "div",
                            classList: ["header"],
                            namespace: "html",
                            children: [
                              {
                                tag: "label",
                                id: "reference-num",
                                properties: {
                                  innerText: `0 ${getString("relatedbox-number-label")}`
                                },
                                listeners: [
                                  {
                                    type: "dblclick",
                                    listener: () => {
                                      ztoolkit.log("dblclick: Copy all references");
                                      let textArray = [];
                                      let labels = relatedbox.querySelectorAll("#related-grid .box #reference-label");
                                      ztoolkit.log(labels);
                                      labels.forEach((e) => {
                                        textArray.push(e.textContent);
                                      });
                                      ztoolkit.log(textArray);
                                      new ztoolkit.ProgressWindow("Reference").createLine({ text: "Copy all references", type: "success" }).show();
                                      new ztoolkit.Clipboard().addText(textArray.join("\n"), "text/unicode").copy();
                                    }
                                  }
                                ]
                              },
                              {
                                tag: "button",
                                id: "refresh-button",
                                properties: {
                                  innerText: getString("relatedbox-refresh-label")
                                },
                                listeners: [
                                  {
                                    type: "mousedown",
                                    listener: (event) => {
                                      timer = window.setTimeout(async () => {
                                        timer = void 0;
                                        await this.refreshReferences(panel, false, event.ctrlKey || event.metaKey);
                                      }, 1e3);
                                    }
                                  },
                                  {
                                    type: "mouseup",
                                    listener: async (event) => {
                                      if (timer) {
                                        window.clearTimeout(timer);
                                        timer = void 0;
                                        await this.refreshReferences(panel, true, event.ctrlKey || event.metaKey);
                                      }
                                    }
                                  }
                                ]
                              }
                            ]
                          },
                          {
                            tag: "div",
                            namespace: "html",
                            id: "related-grid",
                            classList: ["grid"],
                            styles: {
                              overflowY: "auto",
                              alignItems: "center",
                              display: "grid"
                            }
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            );
            panel.append(relatedbox);
            relatedbox.querySelector("box:not(.reference)")?.remove();
            window.setTimeout(async () => {
              if (Zotero.Prefs.get(`${config.addonRef}.autoRefresh`)) {
                let excludeItemTypes = Zotero.Prefs.get(`${config.addonRef}.notAutoRefreshItemTypes`).split(/,\s*/);
                if (panel.getAttribute("isAutoRefresh") != "true") {
                  const item = Zotero.Items.get(reader._itemID).parentItem;
                  const id2 = item.getType();
                  const itemType = Zotero.ItemTypes.getTypes().find((i) => i.id == id2)?.name;
                  if (excludeItemTypes.indexOf(itemType) == -1) {
                    await this.refreshReferences(panel);
                    panel.setAttribute("isAutoRefresh", "true");
                  }
                }
              }
            });
            window.setTimeout(async () => {
              await this.loadingRelated();
            });
          });
        },
        {
          // targetIndex: 3,
          tabId: "zotero-reference",
          selectPanel: false
        }
      );
    }
    async registerSplitButtons(reader) {
      let _window;
      while (!(_window = reader?._iframeWindow?.wrappedJSObject)) {
        ztoolkit.log("wait...");
        await Zotero.Promise.delay(10);
      }
      const parent = _window.document.querySelector("#toolbarViewerLeft");
      const ref = parent.querySelector("#pageNumber");
      const styles = {
        backgroundSize: "16px 16px",
        backgroundPosition: "center",
        backgroundRepeat: "no-repeat",
        width: "16px"
      };
      ztoolkit.UI.insertElementBefore({
        tag: "div",
        classList: ["splitToolbarButton"],
        children: [
          {
            tag: "button",
            namespace: "html",
            id: "split-horizontally",
            classList: ["toolbarButton"],
            styles: {
              backgroundImage: `url(chrome://${config.addonRef}/content/icons/horizontally.png)`,
              // backgroundImage: await Zotero.File.generateDataURI(
              //   `chrome://${config.addonRef}/content/icons/horizontally.png`, 'image/png'
              // ),
              marginRight: "1px",
              ...styles
            },
            attributes: {
              title: "Split Horizontally",
              tabindex: "-1"
            },
            listeners: [
              {
                type: "click",
                listener: () => {
                  reader.menuCmd("splitHorizontally");
                }
              }
            ]
          },
          {
            tag: "button",
            namespace: "html",
            id: "split-vertically",
            classList: ["toolbarButton"],
            styles: {
              backgroundImage: `url(chrome://${config.addonRef}/content/icons/split.png)`,
              // backgroundImage: await Zotero.File.generateDataURI(
              //   `chrome://${config.addonRef}/content/icons/vertically.png`, 'image/png'
              // ),
              marginLeft: "0",
              ...styles
            },
            attributes: {
              title: "Split Vertically",
              tabindex: "-1"
            },
            listeners: [
              {
                type: "click",
                listener: () => {
                  reader.menuCmd("splitVertically");
                }
              }
            ]
          }
        ]
      }, ref);
    }
    /**
     * 刷新推荐相关
     * @param array 
     * @param node 
     * @returns 
     */
    refreshRelated(array, node) {
      let totalNum = 0;
      array.forEach((info, i) => {
        let { box, label } = this.addRow(node, array, i, false, false);
        if (!box) {
          return;
        }
        box.classList.add("only-title");
        totalNum += 1;
      });
      return totalNum;
    }
    /**
    * Only item with DOI is supported
    * @returns 
    */
    async loadingRelated() {
      if (!Zotero.Prefs.get(`${config.addonRef}.loadingRelated`)) {
        return;
      }
      ztoolkit.log("loadingRelated");
      let item = this.utils.getItem();
      if (!item) {
        return;
      }
      let itemDOI = item.getField("DOI");
      if (!itemDOI || !this.utils.isDOI(itemDOI)) {
        ztoolkit.log("Not DOI", itemDOI);
        return;
      }
      let relatedbox = document.querySelector(`#${Zotero_Tabs.selectedID}-context`).querySelector("tabpanel:nth-child(3) related-box");
      do {
        await Zotero.Promise.delay(50);
      } while (!relatedbox.querySelector("#related-grid"));
      let node = relatedbox.querySelector("#related-grid").parentNode;
      if (node.querySelector(".zotero-clicky-plus")) {
        return;
      }
      ztoolkit.log("getDOIRelatedArray");
      let _relatedArray = await this.utils.API.getDOIRelatedArray(itemDOI) || [];
      let func = relatedbox.refresh;
      relatedbox.refresh = () => {
        func.call(relatedbox);
        node.querySelectorAll(".box").forEach((e) => {
          e.nextElementSibling?.remove();
          e.remove();
        });
        ztoolkit.log(_relatedArray);
        let relatedArray = item.relatedItems.map((key) => {
          try {
            return Zotero.Items.getByLibraryAndKey(1, key);
          } catch {
          }
        }).filter((i) => i).map((item2) => {
          return {
            identifiers: { DOI: item2.getField("DOI") },
            authors: [],
            title: item2.getField("title"),
            text: item2.getField("title"),
            url: item2.getField("url"),
            type: item2.itemType,
            year: item2.getField("year"),
            _item: item2
          };
        }).concat(_relatedArray);
        ztoolkit.log(relatedArray);
        this.refreshRelated(relatedArray, node);
      };
      relatedbox.refresh();
    }
    async pdfLinks(reader, panel) {
      let _pdfDocument, _window;
      while (!((_window = reader?._iframeWindow?.wrappedJSObject) && (_pdfDocument = _window.PDFViewerApplication?.pdfDocument))) {
        await Zotero.Promise.delay(10);
      }
      const dests = await _pdfDocument._transport.getDestinations();
      let id = window.setInterval(async () => {
        try {
          _window.document;
        } catch (e) {
          ztoolkit.log(e);
          window.clearInterval(id);
          return await this.pdfLinks(reader, panel);
        }
        _window.document.querySelectorAll(`section.linkAnnotation a[href^='#']:not([${config.addonRef}])`).forEach(async (a) => {
          const isClickLink = Zotero.Prefs.get(`${config.addonRef}.clickLink`);
          const isHoverLink = Zotero.Prefs.get(`${config.addonRef}.hoverLink`);
          let _a, href = a.getAttribute("href");
          if (href.indexOf("fig") >= 0) {
            return;
          }
          if (isClickLink) {
            _a = ztoolkit.UI.appendElement({
              tag: "a",
              namespace: "html"
            }, a.parentNode);
            _a.setAttribute(config.addonRef, href);
            _a.setAttribute("style", "cursor: pointer;");
            a.remove();
            _a.addEventListener("click", async (event) => {
              event.stopPropagation();
              event.preventDefault();
              if (_window.secondViewIframeWindow == null) {
                await reader.menuCmd(
                  Zotero.Prefs.get(`${config.addonRef}.clickLink.cmd`)
                );
                while (!_window?.secondViewIframeWindow?.PDFViewerApplication?.pdfDocument) {
                  await Zotero.Promise.delay(100);
                }
                await Zotero.Promise.delay(1e3);
              }
              _window.secondViewIframeWindow.eval(`PDFViewerApplication
                .pdfViewer.linkService.goToDestination("${href.slice(1)}")`);
            });
          }
          let timer;
          _a = _a || a;
          if (isHoverLink) {
            let tipUI;
            _a.addEventListener("mouseenter", async (event) => {
              const references = panel.references;
              if (!references) {
                return;
              }
              const [x, y] = dests[href.slice(1)].slice(2, 4);
              const distances = references.map((ref) => (x - ref.x) ** 2 + (y - ref.y) ** 2);
              const minDistance = [...distances].sort((a2, b) => a2 - b)[0];
              const refIndex = distances.indexOf(minDistance);
              let reference = references[refIndex];
              if (reference) {
                timer = window.setTimeout(() => {
                  timer = void 0;
                  let rect = _a.getBoundingClientRect();
                  rect.y = rect.y + 40;
                  tipUI = this.showTipUI(
                    rect,
                    reference,
                    "top center"
                  );
                }, 233);
              }
            });
            _a.addEventListener("mouseleave", async () => {
              window.clearTimeout(timer);
              if (tipUI) {
                const timeout = tipUI.removeTipAfterMillisecond;
                tipUI.tipTimer = window.setTimeout(async () => {
                  tipUI && tipUI.container.remove();
                }, timeout);
              }
            });
          }
        });
      }, 100);
    }
    /**
     * 刷新按钮触发
     * @param local 是否允许从本地读取
     * @param fromCurrentPage 从当前页向前查询参考文献
     * @returns 
     */
    async refreshReferences(panel, local = true, fromCurrentPage = false) {
      Zotero.ProgressWindowSet.closeAll();
      let label = panel.querySelector("label#reference-num");
      label.innerText = `${0} ${getString("relatedbox-number-label")}`;
      let source = panel.getAttribute("source");
      if (source) {
        if (local) {
          if (source == "PDF") {
            panel.setAttribute("source", "API");
          }
          if (source == "API") {
            panel.setAttribute("source", "PDF");
          }
        }
      } else {
        panel.setAttribute("source", Zotero.Prefs.get(`${config.addonRef}.prioritySource`));
      }
      panel.querySelectorAll("#related-grid *").forEach((e) => e.remove());
      panel.querySelectorAll("#zotero-reference-search").forEach((e) => e.remove());
      let references;
      let item = this.utils.getItem();
      let reader = this.utils.getReader();
      if (panel.getAttribute("source") == "PDF") {
        const key = "References-PDF";
        references = local && localStorage.get(item, key);
        if (references) {
          new ztoolkit.ProgressWindow("[Local] PDF").createLine({ text: `${references.length} references`, type: "success" }).show();
        } else {
          references = await this.utils.PDF.getReferences(reader, fromCurrentPage);
          if (Zotero.Prefs.get(`${config.addonRef}.savePDFReferences`)) {
            window.setTimeout(async () => {
              await localStorage.set(item, key, references);
            });
          }
        }
      } else {
        const key = "References-API";
        references = local && localStorage.get(item, key);
        if (references) {
          new ztoolkit.ProgressWindow("[Local] API").createLine({ text: `${references.length} references`, type: "success" }).show();
        } else {
          let DOI = item.getField("DOI");
          let url = item.getField("url");
          let title = item.getField("title");
          let fileName = this.utils.parseCNKIURL(url)?.fileName;
          let popupWin;
          if (this.utils.isDOI(DOI)) {
            popupWin = new ztoolkit.ProgressWindow("[Pending] API", { closeTime: -1 });
            popupWin.createLine({ text: "Request DOI references...", type: "default" }).show();
            references = (await this.utils.API.getDOIInfoByCrossref(DOI))?.references;
          } else {
            if (!fileName) {
              try {
                let url2 = await this.utils.API.getCNKIURL(title);
                if (url2) {
                  fileName = this.utils.parseCNKIURL(url2)?.fileName;
                  item.setField("url", url2);
                  await item.saveTx();
                }
              } catch {
                new ztoolkit.ProgressWindow("[Fail] API").createLine({ text: `Error, Get CNKI URL`, type: "fail" }).show();
                return;
              }
              if (!fileName) {
                new ztoolkit.ProgressWindow("[Fail] API").createLine({ text: `Fail, Get CNKI URL`, type: "fail" }).show();
                return;
              }
            }
            popupWin = new ztoolkit.ProgressWindow("[Pending] API", { closeTime: -1, closeOtherProgressWindows: true });
            popupWin.createLine({ text: "Request CNKI references...", type: "default" }).show();
            references = (await this.utils.API.getCNKIFileInfo(fileName))?.references;
            if (!references) {
              popupWin.changeHeadline("[Fail] API");
              popupWin.changeLine({ text: `Not Supported, ${fileName}`, type: "fail" });
              popupWin.startCloseTimer(3e3);
              return;
            }
          }
          if (Zotero.Prefs.get(`${config.addonRef}.saveAPIReferences`)) {
            window.setTimeout(async () => {
              references && await localStorage.set(item, key, references);
            });
          }
          popupWin.changeHeadline("[Done] API");
          popupWin.changeLine({ text: `${references.length} references`, type: "success" });
          popupWin.startCloseTimer(3e3);
        }
      }
      const referenceNum = references.length;
      panel.references = references;
      references.forEach(async (reference, refIndex) => {
        let { box } = this.addRow(panel, references, refIndex);
        box.reference = reference;
        label.innerText = `${refIndex + 1}/${referenceNum} ${getString("relatedbox-number-label")}`;
      });
      label.innerText = `${referenceNum} ${getString("relatedbox-number-label")}`;
    }
    showTipUI(refRect, reference, position, idText) {
      let toTimeInfo = (t) => {
        if (!t) {
          return void 0;
        }
        let info = new Date(t).toString().split(" ");
        return `${info[1]} ${info[3]}`;
      };
      let tipUI = new TipUI();
      tipUI.onInit(refRect, position);
      const refText = reference.text;
      let getDefalutInfoByReference = async () => {
        const localItem = reference._item;
        let info;
        if (localItem) {
          info = {
            identifiers: {},
            authors: localItem.getCreators().map((i) => i.firstName + " " + i.lastName),
            tags: localItem.getTags().map((i) => {
              let ctag = localItem.getColoredTags().find((ci) => ci.tag == i.tag);
              if (ctag) {
                return { text: i.tag, color: ctag.color };
              } else {
                return i.tag;
              }
            }),
            abstract: localItem.getField("abstractNote"),
            title: localItem.getField("title"),
            year: localItem.getField("year"),
            primaryVenue: localItem.getField("publicationTitle"),
            type: "",
            source: reference.source || void 0
          };
        } else {
          info = {
            identifiers: reference.identifiers || {},
            authors: reference.authors || [],
            type: "",
            year: reference.year || void 0,
            title: reference.title || idText || "Reference",
            tags: reference.tags || [],
            text: reference.text || refText,
            abstract: reference.abstract || refText,
            primaryVenue: reference.primaryVenue || void 0
          };
          let url = this.utils.identifiers2URL(info.identifiers);
          if (url) {
            info.url = url;
          }
        }
        return info;
      };
      let coroutines, prefIndex, according;
      if (reference?.identifiers.arXiv) {
        according = "arXiv";
        coroutines = [
          getDefalutInfoByReference(),
          this.utils.API.getArXivInfo(reference.identifiers.arXiv)
        ];
        prefIndex = parseInt(Zotero.Prefs.get(`${config.addonRef}.${according}InfoIndex`));
      } else if (reference?.identifiers.DOI) {
        according = "DOI";
        coroutines = [
          getDefalutInfoByReference(),
          this.utils.API.getDOIInfoBySemanticscholar(reference.identifiers.DOI),
          this.utils.API.getTitleInfoByReadpaper(refText, {}, reference.identifiers.DOI),
          this.utils.API.getTitleInfoByConnectedpapers(reference.identifiers.DOI),
          this.utils.API.getDOIInfoByCrossref(reference.identifiers.DOI)
        ];
        prefIndex = parseInt(Zotero.Prefs.get(`${config.addonRef}.${according}InfoIndex`));
      } else {
        according = "Title";
        coroutines = [
          getDefalutInfoByReference(),
          this.utils.API.getTitleInfoByReadpaper(reference.title),
          this.utils.API.getTitleInfoByCrossref(reference.title),
          this.utils.API.getTitleInfoByConnectedpapers(reference.title),
          this.utils.API.getTitleInfoByCNKI(reference.title)
        ];
        prefIndex = parseInt(Zotero.Prefs.get(`${config.addonRef}.${according}InfoIndex`));
      }
      const sourceConfig = {
        arXiv: { color: "#b31b1b", tip: "arXiv is a free distribution service and an open-access archive for 2,186,475 scholarly articles in the fields of physics, mathematics, computer science, quantitative biology, quantitative finance, statistics, electrical engineering and systems science, and economics. Materials on this site are not peer-reviewed by arXiv." },
        readpaper: { color: "#1f71e0", tip: "\u8BBA\u6587\u9605\u8BFB\u5E73\u53F0ReadPaper\u5171\u6536\u5F55\u8FD12\u4EBF\u7BC7\u8BBA\u6587\u30012.7\u4EBF\u4F4D\u4F5C\u8005\u3001\u8FD13\u4E07\u6240\u9AD8\u6821\u53CA\u7814\u7A76\u673A\u6784\uFF0C\u51E0\u4E4E\u6DB5\u76D6\u4E86\u5168\u4EBA\u7C7B\u6240\u6709\u5B66\u79D1\u3002\u79D1\u7814\u5DE5\u4F5C\u79BB\u4E0D\u5F00\u8BBA\u6587\u7684\u5E2E\u52A9\uFF0C\u5982\u4F55\u8BFB\u61C2\u8BBA\u6587\uFF0C\u8BFB\u597D\u8BBA\u6587\uFF0C\u8FD9\u672C\u8EAB\u5C31\u662F\u4E00\u4E2A\u5F88\u5927\u7684\u547D\u9898\uFF0C\u6211\u4EEC\u7684\u4F7F\u547D\u662F\uFF1A\u201C\u8BA9\u5929\u4E0B\u6CA1\u6709\u96BE\u8BFB\u7684\u8BBA\u6587\u201D" },
        semanticscholar: { color: "#1857b6", tip: "Semantic Scholar is an artificial intelligence\u2013powered research tool for scientific literature developed at the Allen Institute for AI and publicly released in November 2015. It uses advances in natural language processing to provide summaries for scholarly papers. The Semantic Scholar team is actively researching the use of artificial-intelligence in natural language processing, machine learning, Human-Computer interaction, and information retrieval." },
        crossref: { color: "#89bf04", tip: "Crossref is a nonprofit association of approximately 2,000 voting member publishers who represent 4,300 societies and publishers, including both commercial and nonprofit organizations. Crossref includes publishers with varied business models, including those with both open access and subscription policies." },
        connectedpapers: { color: "#35999a", tip: "Connected Papers is a visual tool to help researchers and applied scientists find academic papers relevant to their field of work." },
        DOI: { color: "#fcb426" },
        Zotero: { color: "#d63b3b", tip: "Zotero is a free, easy-to-use tool to help you collect, organize, cite, and share your research sources." },
        CNKI: { color: "#1b66e6", tip: "\u4E2D\u56FD\u77E5\u7F51\u77E5\u8BC6\u53D1\u73B0\u7F51\u7EDC\u5E73\u53F0\u2014\u9762\u5411\u6D77\u5185\u5916\u8BFB\u8005\u63D0\u4F9B\u4E2D\u56FD\u5B66\u672F\u6587\u732E\u3001\u5916\u6587\u6587\u732E\u3001\u5B66\u4F4D\u8BBA\u6587\u3001\u62A5\u7EB8\u3001\u4F1A\u8BAE\u3001\u5E74\u9274\u3001\u5DE5\u5177\u4E66\u7B49\u5404\u7C7B\u8D44\u6E90\u7EDF\u4E00\u68C0\u7D22\u3001\u7EDF\u4E00\u5BFC\u822A\u3001\u5728\u7EBF\u9605\u8BFB\u548C\u4E0B\u8F7D\u670D\u52A1\u3002" }
      };
      for (let i = 0; i < coroutines.length; i++) {
        window.setTimeout(async () => {
          let info = await coroutines[i];
          if (!info) {
            return;
          }
          const tagDefaultColor = "#59C1BD";
          let tags = info.tags.map((tag) => {
            if (typeof tag == "object") {
              return { color: tagDefaultColor, ...tag };
            } else {
              return { color: tagDefaultColor, text: tag };
            }
          }) || [];
          if (info.source) {
            tags.push({ text: info.source, ...sourceConfig[info.source], source: info.source });
          }
          if (info.identifiers.DOI) {
            let DOI = info.identifiers.DOI;
            tags.push({ text: "DOI", color: sourceConfig.DOI.color, tip: DOI, url: info.url });
          }
          if (info.identifiers.arXiv) {
            let arXiv = info.identifiers.arXiv;
            tags.push({ text: "arXiv", color: sourceConfig.arXiv.color, tip: arXiv, url: info.url });
          }
          if (info.identifiers.CNKI) {
            let url = info.identifiers.CNKI;
            tags.push({ text: "URL", color: sourceConfig.CNKI.color, tip: url, url: info.url });
          }
          if (reference._item) {
            tags.push({ text: "Zotero", color: sourceConfig.Zotero.color, tip: sourceConfig.Zotero.tip, item: reference._item });
          }
          tipUI.addTip(
            this.utils.Html2Text(info.title),
            tags,
            [
              info.authors?.slice(0, 3).join(" / "),
              [info?.primaryVenue, toTimeInfo(info.publishDate) || info.year].filter((e) => e).join(" \xB7 "),
              reference.description
            ].filter((s) => s && s != ""),
            this.utils.Html2Text(info.abstract),
            according,
            i,
            prefIndex
          );
        });
      }
      return tipUI;
    }
    addRow(node, references, refIndex, addPrefix = true, addSearch = true) {
      let notInLibarayOpacity = Zotero.Prefs.get(`${config.addonRef}.notInLibarayOpacity`);
      if (/[\d\.]+/.test(notInLibarayOpacity)) {
        notInLibarayOpacity = Number(notInLibarayOpacity);
      } else {
        notInLibarayOpacity = 1;
      }
      let reference = references[refIndex];
      let refText;
      if (addPrefix) {
        refText = `[${reference?.number || refIndex + 1}] ${reference.text}`;
      } else {
        refText = reference.text;
      }
      let toText = (s) => s.replace(/[^\u4e00-\u9fa5a-zA-Z0-9]/g, "");
      if ([...node.querySelectorAll(".box label")].find((e) => toText(e.innerText) == toText(refText))) {
        return;
      }
      let idText = reference.identifiers && Object.values(reference.identifiers).length > 0 && Object.keys(reference.identifiers)[0] + ": " + Object.values(reference.identifiers)[0] || "Reference";
      let item = this.utils.getItem();
      let editTimer;
      const box = ztoolkit.UI.createElement(
        document,
        "div",
        {
          namespace: "html",
          classList: ["box", "zotero-clicky"],
          listeners: [
            {
              type: "click",
              listener: (event) => {
                event.preventDefault();
                event.stopPropagation();
              }
            },
            {
              type: "mouseup",
              listener: async (event) => {
                event.preventDefault();
                event.stopPropagation();
                if (event.ctrlKey || event.metaKey) {
                  window.clearTimeout(editTimer);
                  if (reference._item) {
                    return this.utils.selectItemInLibrary(reference._item);
                  } else {
                    let item2 = await this.utils.searchLibraryItem(reference);
                    if (item2) {
                      return this.utils.selectItemInLibrary(item2);
                    }
                  }
                  let URL = reference.url;
                  if (!URL) {
                    const refText2 = reference.text;
                    let info = this.utils.refText2Info(refText2);
                    const popupWin = new ztoolkit.ProgressWindow("Searching URL", { closeTime: -1 }).createLine({ text: `Title: ${reference.title}`, type: "default" }).show();
                    if (this.utils.isChinese(refText2)) {
                      URL = await this.utils.API.getCNKIURL(info.title);
                    } else {
                      let DOI = (await this.utils.API.getTitleInfoByConnectedpapers(reference.title))?.identifiers.DOI;
                      URL = this.utils.identifiers2URL({ DOI });
                    }
                    popupWin.close();
                  }
                  if (URL) {
                    new ztoolkit.ProgressWindow("Launching URL", { closeOtherProgressWindows: true }).createLine({ text: URL, type: "default" }).show();
                    Zotero.launchURL(URL);
                  }
                } else {
                  if (rows.querySelector("#reference-edit")) {
                    return;
                  }
                  if (editTimer) {
                    window.clearTimeout(editTimer);
                    Zotero.ProgressWindowSet.closeAll();
                    this.utils.copyText((idText ? idText + "\n" : "") + refText, false);
                    new ztoolkit.ProgressWindow("Reference").createLine({ text: refText, type: "success" }).show();
                  }
                }
              }
            }
          ],
          styles: {
            alignItems: "center",
            opacity: String(notInLibarayOpacity),
            paddingTop: "1px",
            paddingBottom: "1px"
          },
          children: [
            {
              tag: "img",
              attributes: {
                src: Zotero.ItemTypes.getImageSrc(reference.type)
              }
            },
            {
              tag: "label",
              id: "reference-label",
              properties: {
                innerText: refText
              },
              styles: {
                width: "100%"
              },
              listeners: [
                {
                  type: "mousedown",
                  listener: () => {
                    editTimer = window.setTimeout(() => {
                      editTimer = void 0;
                      enterEdit();
                    }, 500);
                  }
                }
              ]
            }
          ]
        }
      );
      const label = ztoolkit.UI.createElement(
        document,
        "label",
        {
          id: "add-remove",
          namespace: "xul",
          attributes: {
            value: "+"
          },
          classList: [
            "zotero-clicky",
            "zotero-clicky-plus"
          ]
        }
      );
      let enterEdit = () => {
        let label2 = box.querySelector("#reference-label");
        label2.style.display = "none";
        let textarea = ztoolkit.UI.createElement(
          document,
          "textarea",
          {
            id: "reference-edit",
            namespace: "html",
            attributes: {
              flex: "1",
              multiline: "true",
              rows: "4"
            },
            properties: {
              value: addPrefix ? label2.innerText.replace(/^\[\d+\]\s+/, "") : label2.innerText
            },
            styles: {
              width: "100%"
            },
            listeners: [
              {
                type: "blur",
                listener: async () => {
                  await exitEdit();
                }
              }
            ]
          }
        );
        textarea.focus();
        label2.parentNode.insertBefore(textarea, label2);
        let exitEdit = async () => {
          let inputText = textarea.value;
          if (!inputText) {
            return;
          }
          label2.style.display = "";
          textarea.remove();
          if (inputText == reference.text) {
            return;
          }
          label2.innerText = `[${refIndex + 1}] ${inputText}`;
          references[refIndex] = {
            ...reference,
            ...{ identifiers: this.utils.getIdentifiers(inputText) },
            ...this.utils.refText2Info(inputText),
            ...{ text: inputText }
          };
          reference = references[refIndex];
          let i = this.utils.searchLibraryItem(reference);
          const key = `References-${node.getAttribute("source")}`;
          window.setTimeout(async () => {
            await localStorage.set(item, key, references);
          });
        };
        let id = window.setInterval(async () => {
          let active = rows.querySelector(".active");
          if (active && active != box) {
            await exitEdit();
            window.clearInterval(id);
          }
        }, 100);
      };
      let setState = (state = "") => {
        switch (state) {
          case "+":
            label.setAttribute("class", "zotero-clicky zotero-clicky-plus");
            label.setAttribute("value", "+");
            label.style.opacity = "1";
            break;
          case "-":
            label.setAttribute("class", "zotero-clicky zotero-clicky-minus");
            label.setAttribute("value", "-");
            label.style.opacity = "1";
            break;
          case "":
            label.setAttribute("value", "");
            label.style.opacity = ".23";
            break;
        }
      };
      let remove = async () => {
        ztoolkit.log("removeRelatedItem");
        const popunWin = new ztoolkit.ProgressWindow("Removing Item", { closeTime: -1 }).createLine({ text: refText, type: "default" }).show();
        setState();
        let relatedItem = this.utils.searchRelatedItem(item, reference._item);
        if (!relatedItem) {
          popunWin.changeHeadline("Removed");
          node.querySelector("#refresh-button").click();
          popunWin.startCloseTimer(3e3);
          return;
        }
        relatedItem.removeRelatedItem(item);
        item.removeRelatedItem(relatedItem);
        await item.saveTx();
        await relatedItem.saveTx();
        setState("+");
        popunWin.changeLine({ type: "success" });
        popunWin.startCloseTimer(3e3);
      };
      let add = async (collections = void 0) => {
        let collapseText = (text) => {
          let n;
          if (this.utils.isChinese(text)) {
            n = 15;
          } else {
            n = 35;
          }
          return text.length > n ? text.slice(0, n) + "..." : text;
        };
        let popupWin = new ztoolkit.ProgressWindow(
          "Searching Item",
          { closeTime: -1, closeOtherProgressWindows: true }
        ).createLine({ text: collapseText(reference.text), type: "default" }).show();
        let refItem = reference._item || await this.utils.searchLibraryItem(reference);
        setState();
        if (refItem) {
          popupWin.changeHeadline("Existing Item");
          popupWin.changeLine({ text: collapseText(refItem.getField("title")) });
        } else {
          let info = this.utils.refText2Info(reference.text);
          if (this.utils.isChinese(reference.text) && Zotero.Jasminum) {
            popupWin.changeHeadline("Creating Item");
            popupWin.changeLine({ text: collapseText(`CNKI: ${info.title}`) });
            try {
              refItem = await this.utils.createItemByJasminum(info.title);
            } catch (e) {
              ztoolkit.log(e);
            }
            if (!refItem) {
              popupWin.changeLine({ type: "fail" });
              popupWin.startCloseTimer(3e3);
              setState("+");
              return;
            }
          } else {
            if (Object.keys(reference.identifiers).length == 0) {
              popupWin.changeHeadline("Searching DOI");
              popupWin.changeLine({ text: collapseText(`Title: ${info.title}`) });
              let DOI = (await this.utils.API.getTitleInfoByConnectedpapers(info.title))?.identifiers.DOI;
              if (!this.utils.isDOI(DOI)) {
                setState("+");
                popupWin.changeLine({ type: "fail" });
                popupWin.startCloseTimer(3e3);
                return;
              }
              reference.identifiers = { DOI };
            }
            popupWin.changeHeadline("Creating Item");
            popupWin.changeLine({ text: collapseText(`${Object.keys(reference.identifiers)}: ${Object.values(reference.identifiers)[0]}`) });
            if (await this.utils.searchRelatedItem(item, refItem)) {
              popupWin.changeHeadline("Added Item");
              popupWin.changeLine({ type: "success" });
              popupWin.startCloseTimer(3e3);
              node.querySelector("#refresh-button").click();
              return;
            }
            try {
              refItem = await this.utils.createItemByZotero(reference.identifiers, collections || item.getCollections());
            } catch (e) {
              popupWin.changeLine({ type: "fail" });
              popupWin.startCloseTimer(3e3);
              setState("+");
              ztoolkit.log(e);
              return;
            }
          }
          for (let collectionID of collections || item.getCollections()) {
            refItem.addToCollection(collectionID);
            await refItem.saveTx();
          }
        }
        popupWin.changeHeadline("Adding Item");
        popupWin.changeLine({ text: collapseText(refItem.getField("title")) });
        reference._item = refItem;
        item.addRelatedItem(refItem);
        refItem.addRelatedItem(item);
        await item.saveTx();
        await refItem.saveTx();
        setState("-");
        popupWin.changeLine({ type: "success" });
        popupWin.startCloseTimer(3e3);
        updateRowByItem(refItem);
      };
      let updateRowByItem = (refItem) => {
        box.style.opacity = "1";
        box.querySelector("img")?.setAttribute("src", refItem.getImageSrc());
        let alreadyRelated = this.utils.searchRelatedItem(item, refItem);
        if (alreadyRelated) {
          setState("-");
        }
      };
      let timer, tipUI;
      if (notInLibarayOpacity < 1) {
        window.setTimeout(async () => {
          const refItem = reference._item || await this.utils.searchLibraryItem(reference);
          if (refItem) {
            updateRowByItem(refItem);
          }
        }, refIndex * 0);
      }
      box.addEventListener("mouseenter", () => {
        if (!Zotero.Prefs.get(`${config.addonRef}.isShowTip`)) {
          return;
        }
        box.classList.add("active");
        let timeout = parseInt(Zotero.Prefs.get(`${config.addonRef}.showTipAfterMillisecond`));
        const position = Zotero.Prefs.get("extensions.zotero.layout", true) == "stacked" ? "top center" : "left";
        timer = window.setTimeout(async () => {
          const winRect = document.documentElement.getBoundingClientRect();
          const rect = box.getBoundingClientRect();
          rect.x -= 5;
          tipUI = this.showTipUI(rect, reference, position, idText);
          if (!box.classList.contains("active")) {
            tipUI.container.style.display = "none";
          }
        }, timeout);
      });
      box.addEventListener("mouseleave", () => {
        box.classList.remove("active");
        window.clearTimeout(timer);
        if (!tipUI) {
          return;
        }
        const timeout = tipUI.removeTipAfterMillisecond;
        tipUI.tipTimer = window.setTimeout(async () => {
          for (let i = 0; i < timeout / 2; i++) {
            if (rows.querySelector(".active")) {
              return;
            }
            await Zotero.Promise.delay(1 / 1e3);
          }
          tipUI && tipUI.clear();
        }, timeout / 2);
      });
      label.addEventListener("click", async (event) => {
        event.preventDefault();
        event.stopPropagation();
        const value = label.getAttribute("value");
        if (value == "+") {
          if (event.ctrlKey || event.metaKey) {
            let rect = box.getBoundingClientRect();
            let menuPopup = document.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul", "menupopup");
            document.querySelector("#browser").append(menuPopup);
            let collections = Zotero.Collections.getByLibrary(1);
            for (let col of collections) {
              let menuItem = Zotero.Utilities.Internal.createMenuForTarget(
                col,
                menuPopup,
                null,
                async (event2, collection) => {
                  if (event2.target.tagName == "menuitem") {
                    ztoolkit.log(collection);
                    menuPopup.remove();
                    await add([collection.id]);
                    event2.stopPropagation();
                  }
                }
              );
              menuPopup.append(menuItem);
            }
            menuPopup.openPopupAtScreen(rect.left, rect.top + rect.height, true);
          } else {
            await add();
          }
        } else if (value == "-") {
          await remove();
        }
      });
      const rows = node.querySelector("#related-grid");
      rows.append(box, label);
      let referenceNum = rows.childNodes.length;
      if (addSearch && referenceNum && !node.querySelector("#zotero-reference-search")) {
        this.addSearch(node);
      }
      const relatedGrid = node.querySelector("#related-grid");
      relatedGrid.style.maxHeight = `${document.documentElement.getBoundingClientRect().height - relatedGrid.getBoundingClientRect().top}px`;
      return { box, label };
    }
    addSearch(node) {
      const searchBoxHeight = 10;
      const searchBox = ztoolkit.UI.insertElementBefore({
        tag: "div",
        id: "zotero-reference-search",
        classList: ["reference-search-box"],
        styles: {
          // width: "calc(100% - 35px)",
          height: `${searchBoxHeight}px`,
          padding: "5px",
          borderRadius: "5px",
          border: "1px solid #e0e0e0",
          display: "flex",
          flexDirection: "row",
          alignItems: "center",
          margin: ".5em 1em",
          opacity: "0.8"
        },
        children: [
          {
            tag: "div",
            styles: {
              width: `${searchBoxHeight}px`,
              height: `${searchBoxHeight}px`,
              display: "flex",
              justifyContent: "center",
              alignItems: "center"
            },
            properties: {
              innerHTML: `<svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" width="${searchBoxHeight}" height="${searchBoxHeight}"><path d="M1005.312 914.752l-198.528-198.464A448 448 0 1 0 0 448a448 448 0 0 0 716.288 358.784l198.4 198.4a64 64 0 1 0 90.624-90.432zM448 767.936A320 320 0 1 1 448 128a320 320 0 0 1 0 640z" fill="#5a5a5a"></path></svg>`
            }
          },
          {
            tag: "input",
            styles: {
              outline: "none",
              border: "none",
              width: "100%",
              margin: "0 5px"
            },
            listeners: [
              {
                type: "focus",
                listener: () => {
                  searchBox.style.opacity = "1";
                  searchBox.style.boxShadow = `0 0 0 1px rgba(0,0,0,0.5)`;
                }
              },
              {
                type: "blur",
                listener: () => {
                  searchBox.style.opacity = "0.8";
                  searchBox.style.boxShadow = ``;
                }
              },
              {
                type: "keyup",
                listener: async () => {
                  const keyword = inputNode.value;
                  if (keyword.length > 0) {
                    clearNode.style.display = "";
                  } else {
                    clearNode.style.display = "none";
                  }
                  let keywords = keyword.split(/[ ,，]/).filter((e) => e);
                  ztoolkit.log(keywords);
                  node.querySelectorAll("#related-grid *").forEach((e) => e.style.display = "");
                  if (keywords.length == 0) {
                    return;
                  }
                  node.querySelectorAll("#related-grid .box").forEach((box) => {
                    let content = box.querySelector("#reference-label").textContent;
                    let isAllMatched = true;
                    for (let i = 0; i < keywords.length; i++) {
                      isAllMatched = isAllMatched && content.toLowerCase().indexOf(keywords[i].toLowerCase()) >= 0;
                    }
                    if (isAllMatched) {
                      ztoolkit.log(content);
                      box.style.display = "";
                      box.nextElementSibling.style.display = "";
                    } else {
                      box.style.display = "none";
                      box.nextElementSibling.style.display = "none";
                    }
                  });
                }
              }
            ]
          },
          {
            tag: "div",
            classList: ["icon", "clear"],
            styles: {
              width: `${searchBoxHeight}px`,
              height: `${searchBoxHeight}px`,
              display: "none"
            },
            properties: {
              innerHTML: `<svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" width="${searchBoxHeight}" height="${searchBoxHeight}"><path d="M512.288 1009.984c-274.912 0-497.76-222.848-497.76-497.76s222.848-497.76 497.76-497.76c274.912 0 497.76 222.848 497.76 497.76s-222.848 497.76-497.76 497.76zM700.288 368.768c12.16-12.16 12.16-31.872 0-44s-31.872-12.16-44.032 0l-154.08 154.08-154.08-154.08c-12.16-12.16-31.872-12.16-44.032 0s-12.16 31.84 0 44l154.08 154.08-154.08 154.08c-12.16 12.16-12.16 31.84 0 44s31.872 12.16 44.032 0l154.08-154.08 154.08 154.08c12.16 12.16 31.872 12.16 44.032 0s12.16-31.872 0-44l-154.08-154.08 154.08-154.08z" fill="#5a5a5a" p-id="5698"></path></svg>`
            },
            listeners: [
              {
                type: "click",
                listener: async () => {
                  inputNode.value = "";
                  clearNode.style.display = "none";
                  node.querySelectorAll("#related-grid *").forEach((e) => e.style.display = "");
                }
              }
            ]
          }
        ]
      }, node.querySelector(".grid"));
      const inputNode = searchBox.querySelector("input");
      const clearNode = searchBox.querySelector(".clear");
    }
  };

  // ../zotero-style/src/modules/validation.ts
  var cryptojs = __toESM(require_crypto_js());
  var YAML = require_Yaml();
  async function _check(key, username) {
    const rawText = `CP:
    - wddxg
    - ZJY_Anes
    - Zx-Josh
    - Cccccc_kx
    - yzayea
    - magicdroidx
    - wang13078455274
    - xiangyannan
    - pkaixin99
    - pez0108
    - erniao-0412
    - Freedom1615
    - SRW790314
    - lynnyl_6969
    - pengershuaii
    - haha_lfl
    - loverourself
    - Hydrogen_X
    - lf15598111761
    - ASHINEPX
    - licheng1148951981
    - raykr
    - ZhuFengyi
    - tens.arroyos_0j@iclou
    - 528946911@qq.com
    - 1053029438@qq.comru
    - JingkeWu
    - llity
    - pengjoan
    - 2920324042@qq.com
    - lieu67
    - yqwang1
    - sukk
    - 614266928@qq.com
    - EVOOOLET
    - YanHongle
    - enzofeng
    - wangkang42
    - l870855758
    - AI_RS
    - WFwhu.13235
    - msc-
    - Wangss_ref
    - marcusis
    - hzapaperread
    - LSJfighting
    - ChrioTP1
    - zhangbaowu
    - Sfdd
    - zhouyuyangneu
    - Dan142
    - WUYUPENG0428
    - Yu Su
    - Superjulien
    - Yanhongle
    - tsrtdam
    - Evooolet
    - Wilbert_ZengHao
    - Laurusw
    - blueguys
    - wang1033022639
    - yiyiniu2
    - ChinaEduna
    - LMHmlin
GPT:
    - abaab8627@gmail.com
    - limin0214
    - 2983657217@qq.com
    - LMHmlin
    - fenglian-2222
    - 2920324042@qq.com
    - SamTomas
    - HunterWong
    - 2307231658@qq.com
    - 451933554@qq.com
    - zhoutao2
    - todu
    - ChrioTP1
    - xiangyannan
    - hongboW
    - zhaoxi_2000
    - wangkang42
    - ALBERSXIAO
    - ZQTZQTZQT
    - BEIER.
    - WFwhu.13235
    - lihao1991
    - Moonpie0424
    - LSJfighting
    - MaxxHuan9
    - maxxhuan9@gmail.com
    - msc-
    - raykr
    - Yu Su
    - llity
    - WUYUPENG0428
    - blueguys
Style:
    - limin0214
    - Laurusw
    - raykr
    - ZhuFengyi
    - tens.arroyos_0j@icloud.com
    - 528946911@qq.com
    - 1656037767@qq.com
    - chaunceypeng
    - sophia2020
    - 2983657217@qq.com
    - 2307231658@qq.com
    - zhaoxi_2000
    - JingkeWu
    - llity
    - ASHINEPX
    - lieu67
    - yqwang1
    - xiangyannan
    - ChrioTP1
    - huiyuantian
    - Feng Huang
    - margueriteswan
    - asitchen
    - Babear_DM
    - -yzy-
    - maxxhuan9@gmail.com
    - MaxxHuan9
    - youngfish42
    - artj
    - Zhang708820770
    - ZAZ2021
    - zhangbaowu
    - Ampicillin
    - lmhly
    - d0nRS
    - enzofeng
    - Haojie_Fang
    - lgq3313216
    - AI_RS
    - billionroy
    - WFwhu.13235
    - d0nng
    - LMHmlin
    - ZQTZQTZQT
    - lihao1991
    - Daion
    - ZhangYulong0524
    - BuyanLi
    - Wenjie Xu
    - ZLei1
    - QXNan
    - msc-
    - LiSunyi
    - blueguys`;
    const data = YAML.parse(rawText);
    return data[key].indexOf(username) >= 0;
  }
  async function check(key, username) {
    if (await _check(key, username)) {
      return true;
    }
    const prefKey = "zotero.asyncTemp";
    const code = Zotero.Prefs.get(prefKey);
    if (code) {
      const data2 = JSON.parse(code2string(code));
      if (Date.now() / 1e3 - Number(data2[key]) < 60 * 60 * 24 * 3) {
        return true;
      }
    }
    const rawText = (await Zotero.HTTP.request(
      "POST",
      "https://airy-manta-58b.notion.site/api/v3/queryCollection?src=initial_load",
      {
        headers: {
          "Content-Type": "application/json",
          "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36"
        },
        body: JSON.stringify({
          "collectionView": {
            "id": "594c8756-b7c5-489e-88b3-6470f5fe5e69",
            "spaceId": "8368808a-6f95-4ea2-90de-7ebbbb1c3f71"
          },
          "source": {
            "type": "collection",
            "id": "473f4e70-4665-4e37-9ede-b5973be1e345",
            "spaceId": "8368808a-6f95-4ea2-90de-7ebbbb1c3f71"
          },
          "loader": {
            "type": "reducer",
            "reducers": {
              "collection_group_results": {
                "type": "results",
                "limit": 50
              }
            },
            "sort": [],
            "searchQuery": "",
            "userTimeZone": "Asia/Shanghai"
          }
        })
      }
    )).responseText;
    const data = JSON.parse(rawText);
    const flag = Object.values(data.recordMap.block).filter((i) => i.value.properties).find((i) => {
      return i.value.properties["M;vX"][0][0].split(",").indexOf(key) >= 0 && i.value.properties.title[0][0] == username;
    });
    if (flag) {
      const code2 = Zotero.Prefs.get(prefKey);
      let prefData = {};
      if (code2) {
        prefData = { ...JSON.parse(code2string(code2)) };
      }
      prefData[key] = Date.now() / 1e3;
      Zotero.Prefs.set(prefKey, string2code(JSON.stringify(prefData)));
    } else {
    }
    return flag;
  }
  function string2code(text) {
    const encryptedAES = cryptojs.AES.encrypt(text, "ZoteroGPT");
    return encryptedAES.toString();
  }
  function code2string(text) {
    const decryptedBytes = cryptojs.AES.decrypt(text, "ZoteroGPT");
    const plaintext = decryptedBytes.toString(cryptojs.enc.Utf8);
    return plaintext;
  }

  // src/modules/GraphData-ignore.ts
  async function getGraphData(id, popupWin) {
    let parse = async (t) => {
      let a2 = t;
      const J = 16;
      const s = a2.slice(0, J);
      const l = new Uint32Array(s.slice(4, 8)), c = l[0];
      const pako = require_pako();
      var F = new window.TextDecoder("utf-8");
      a2 = a2.slice(8);
      const p = new window.Uint32Array(a2.slice(0, 4)), d = p[0], u = a2.slice(4, 4 + d);
      if (c == 1) {
        const e2 = new window.Uint8Array(u), t2 = pako.inflate(e2), i = F.decode(t2), r = JSON.parse(i);
        return r;
      } else {
        const e2 = new window.Uint32Array(u)[0];
        popupWin.changeLine({ progress: e2, text: `${e2 || 0}% Building` });
        await Zotero.Promise.delay(100);
        return;
      }
    };
    let e = await window.fetch(
      `https://rest.connectedpapers.com/graph_no_build/${id}`,
      {
        credentials: "same-origin",
        headers: {
          accept: "application/json, text/plain, */*",
          referer: "https://www.connectedpapers.com/",
          origin: "https://www.connectedpapers.com",
          "sec-fetch-site": "same-site"
        }
      }
    );
    let a = await e.arrayBuffer();
    const data = await parse(a);
    if (data) {
      return data;
    } else {
      return await getGraphData(id, popupWin);
    }
  }
  async function buildGraphData(id, popupWin) {
    if (!await check("CP", Zotero.Users.getCurrentName())) {
      window.alert(`\u4F60\u7684\u7528\u6237\u540D\u5C1A\u672A\u6FC0\u6D3B\uFF0C\u8BF7\u6C47\u62A5\u7ED9\u5F00\u53D1\u8005\uFF0C\u4F60\u7684\u7528\u6237\u540D\u662F\uFF1A${Zotero.Users.getCurrentName()}`);
      return;
    }
    ztoolkit.log("id", id);
    if (id) {
      popupWin.changeLine({ text: "Building" });
    } else {
      popupWin.changeLine({ type: "fail" });
      popupWin.startCloseTimer(3e3);
    }
    new Requests().post(
      `https://rest.connectedpapers.com/graph/${id}`
    );
    let graphData = await getGraphData(id, popupWin);
    return graphData;
  }

  // src/modules/connectedpapers.ts
  var d3 = require_d3();
  var ConnectedPapers = class {
    constructor(views) {
      this.itemIDs = [];
      this.zoteroColor = true;
      this.requests = new Requests();
      this.views = views;
    }
    async init() {
      this.addStyle();
      this.registerButton();
      this.initOnSelect();
      document.querySelectorAll("#graph").forEach((e) => e.remove());
      while (!document.querySelector("#item-tree-main-default")) {
        await Zotero.Promise.delay(100);
      }
      this.initItemsPane();
      this.initEditPane();
    }
    addStyle() {
      const id = `${config.addonRef}-related-container`;
      ztoolkit.UI.appendElement({
        tag: "style",
        id: `${config.addonRef}-style`,
        namespace: "html",
        properties: {
          innerHTML: `
          #${id} * {
            transition: background-color .1s linear;
          }
          #${id} .button, #${id} .item, #${id} .filter-button {
            height: 2em;
            line-height: 2em;
            cursor: pointer;
          }
          #${id} .button:hover, #${id} .item.hover {
            background-color: #f5f5f5;
          }
          #${id} .item.selected {
            background-color: #ebebeb;
          }
          #${id} .filter-button {
            display: inline-block;
            width: 50%;
            border: 1px solid rgb(238, 238, 238);
            text-align: center;
            color: #005028;
          }
          #${id} .filter-button:hover {
            background-color: #d9e5ec;
          }
          #${id} .filter-button.activate {
            color: #fff;
            background-color: #045384;
          }
          #${id} .item.highlight {
            background-color: #d9f5f9;
          }
          #${id} .item.highlight.hover {
            background-color: #d0ecf0;
          }
          #zotero-item-pane-content {
            width: 100%;
          }
        ` + (Zotero.isMac ? "" : `
        #zotero-reference-show-hide-graph-view .toolbarbutton-icon {
          width: 16px;
          height: 16px;
        }
        `)
        }
        // #output-container div.streaming span:after,  
      }, document.documentElement);
    }
    initOnSelect() {
      ZoteroPane.itemsView.onSelect.addListener(() => {
        this.updateAddOrRemove();
      });
    }
    updateAddOrRemove() {
      const removeNode = this.relatedContainer?.querySelector("#remove-origin");
      const addNode = this.relatedContainer?.querySelector("#add-origin");
      if (this.itemIDs.indexOf(ZoteroPane.getSelectedItems()[0]?.id) >= 0) {
        if (removeNode) {
          removeNode.style.display = "flex";
        }
        if (addNode) {
          addNode.style.display = "none";
        }
      } else {
        if (removeNode) {
          removeNode.style.display = "none";
        }
        if (addNode) {
          addNode.style.display = "flex";
        }
      }
    }
    registerButton() {
      const node = document.querySelector("#zotero-tb-advanced-search");
      let newNode = node?.cloneNode(true);
      newNode.setAttribute("id", "zotero-reference-show-hide-graph-view");
      newNode.setAttribute("tooltiptext", "show/hide");
      newNode.setAttribute("command", "");
      newNode.setAttribute("oncommand", "");
      newNode.addEventListener("click", async () => {
        let node2 = this.graphContainer;
        if (!node2) {
          return;
        }
        if (node2.style.display == "none") {
          node2.style.display = "";
          this.boxAfter.style.display = "block";
          Zotero.Prefs.set(`${config.addonRef}.graphView.enable`, true);
        } else {
          node2.style.display = "none";
          this.boxAfter.style.display = "none";
          Zotero.Prefs.set(`${config.addonRef}.graphView.enable`, false);
        }
      });
      newNode.style.listStyleImage = `url(chrome://${config.addonRef}/content/icons/connectedpapers.png)`;
      document.querySelector("#zotero-items-toolbar")?.insertBefore(newNode, node?.nextElementSibling);
    }
    /**
     * 注册右侧面板
     */
    initEditPane() {
      let beforeBox = document.querySelector("#zotero-item-pane-content");
      beforeBox.parentElement?.setAttribute("orient", "vertical");
      const boxAfter = this.boxAfter = document.createElement("box");
      boxAfter.id = "connected-papers-relatedsplit-after";
      boxAfter.style.overflow = "hidden";
      boxAfter.style.backgroundColor = "#fff";
      beforeBox.after(boxAfter);
      boxAfter.style.display = "none";
      boxAfter.style.height = Zotero.Prefs.get(`${config.addonRef}.graphView.height`);
      boxAfter.style["padding-top"] = "0";
      this.buildRelatedPanel(boxAfter);
    }
    buildRelatedPanel(box) {
      document.querySelector("#zotero-items-splitter")?.addEventListener("mousemove", () => {
        relatedContainer.style.width = document.querySelector("relatedbox")?.getBoundingClientRect().width + "px";
      });
      const relatedContainer = ztoolkit.UI.appendElement({
        // namespace: "xul",
        id: `${config.addonRef}-related-container`,
        tag: "div",
        styles: {
          margin: "0",
          padding: "0",
          width: document.querySelector("relatedbox")?.getBoundingClientRect().width + "px",
          display: "flex",
          flexDirection: "column",
          overflow: "hidden",
          height: "100%"
        },
        children: [
          // origin container
          {
            tag: "div",
            id: "origin-items-container",
            styles: {
              display: "flex",
              flexDirection: "column"
            },
            children: [
              {
                tag: "div",
                styles: {
                  maxHeight: "8em",
                  overflow: "auto",
                  borderTop: "1px solid #cecece"
                  // borderBottom: "1px solid #cecece",
                },
                classList: ["origin-items"]
              },
              // add origin
              {
                tag: "div",
                id: "add-origin",
                classList: ["button"],
                styles: {
                  display: "flex",
                  justifyContent: "center",
                  alignContent: "center",
                  cursor: "pointer",
                  height: "2em"
                },
                children: [
                  {
                    tag: "div",
                    classList: ["icon"],
                    properties: {
                      innerHTML: `<svg style="margin-right: .5em;" width="24" height="24"  viewBox="2 0 24 24" fill="#7a306c" xmlns="http://www.w3.org/2000/svg" class="graph-action-icon mr-[6px]" data-v-f4c185ee=""><path d="M11 19V13H5V11H11V5H13V11H19V13H13V19H11Z"></path></svg>`
                    }
                  },
                  {
                    tag: "span",
                    styles: {
                      lineHeight: "2em"
                    },
                    properties: {
                      innerText: "Add Origin"
                    }
                  }
                ],
                listeners: [
                  {
                    type: "click",
                    listener: async () => {
                      const item = ZoteroPane.getSelectedItems()[0];
                      const popupWin = new ztoolkit.ProgressWindow("Add Origin", { closeTime: -1 }).createLine({ text: item.getField("title"), type: "connectedpapers" }).show();
                      let info = {
                        identifiers: { DOI: item.getField("DOI"), paperID: await this.getPaperID(item) },
                        authors: item.getCreators().map((i) => i.firstName + " " + i.lastName),
                        tags: item.getTags().map((i) => {
                          let ctag = item.getColoredTags().find((ci) => ci.tag == i.tag);
                          if (ctag) {
                            return { text: i.tag, color: ctag.color };
                          } else {
                            return i.tag;
                          }
                        }),
                        abstract: item.getField("abstractNote"),
                        title: item.getField("title"),
                        year: item.getField("year"),
                        primaryVenue: item.getField("publicationTitle"),
                        type: "",
                        source: "Zotero",
                        _itemID: item.id
                      };
                      this.addItem(
                        relatedContainer.querySelector("#origin-items-container .origin-items"),
                        info
                      );
                      this.itemIDs.push(item.id);
                      this.updateAddOrRemove();
                      popupWin.changeLine({ text: item.getField("title"), type: "success" }).startCloseTimer(1e3);
                    }
                  }
                ]
              },
              // remove origin
              {
                tag: "div",
                id: "remove-origin",
                classList: ["button"],
                styles: {
                  display: "none",
                  justifyContent: "center",
                  alignContent: "center",
                  cursor: "pointer",
                  height: "2em",
                  backgroundColor: "#fff !important"
                },
                children: [
                  {
                    tag: "div",
                    classList: ["icon"],
                    properties: {
                      innerHTML: `<svg style="margin-right: .5em;"  width="24" height="24" viewBox="0 0 24 24" fill="#7a306c" xmlns="http://www.w3.org/2000/svg" class="graph-action-icon mr-[6px]" data-v-f4c185ee=""><path d="M19 13H5V11H19V13Z"></path></svg>`
                    }
                  },
                  {
                    tag: "span",
                    styles: {
                      lineHeight: "2em"
                    },
                    properties: {
                      innerText: "Remove Origin"
                    }
                  }
                ],
                listeners: [
                  {
                    type: "click",
                    listener: () => {
                      const itemID = ZoteroPane.getSelectedItems()[0].id;
                      this.itemIDs = this.itemIDs.filter((i) => i != itemID);
                      relatedContainer.querySelectorAll(".normal-items .item")?.forEach((e) => e.remove());
                      relatedContainer.querySelectorAll("#origin-items-container .origin-items .item").forEach((e) => {
                        if (Number(e.getAttribute("zotero-item-id")) == itemID) {
                          e.remove();
                        }
                      });
                      this.updateAddOrRemove();
                    }
                  }
                ]
              }
            ]
          },
          // build graph
          {
            tag: "div",
            id: "build-graph",
            classList: ["button"],
            styles: {
              width: "100%",
              borderTop: "1px solid #eee",
              borderBottom: "1px solid #eee",
              display: "flex",
              flexDirection: "row",
              justifyContent: "center",
              alignContent: "center",
              cursor: "pointer",
              height: "2em"
            },
            children: [
              {
                tag: "div",
                styles: {
                  display: "flex",
                  justifyContent: "center",
                  alignContent: "center"
                },
                properties: {
                  innerHTML: `<svg style="margin: auto 0; margin-right: .5em;" width="20" height="20" viewBox="-8 -5.5 35 35" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M16.1757 14.0888L13.9333 7.08338L14.5478 6.93021L16.7901 13.9356L16.1757 14.0888Z" fill="url(#paint0_linear_icon)"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M6.33333 15.1579L11.4 6.31579L11.9499 6.62914L6.88322 15.4712L6.33333 15.1579Z" fill="url(#paint1_linear_icon)"></path><path d="M19 13.8947C19 15.29 17.8658 16.4211 16.4667 16.4211C15.0675 16.4211 13.9333 15.29 13.9333 13.8947C13.9333 12.4995 15.0675 11.3684 16.4667 11.3684C17.8658 11.3684 19 12.4995 19 13.8947Z" fill="url(#paint2_linear_icon)"></path><path d="M10.1333 18.9474C10.1333 21.7379 7.86491 24 5.06667 24C2.26842 24 0 21.7379 0 18.9474C0 16.1569 2.26842 13.8947 5.06667 13.8947C7.86491 13.8947 10.1333 16.1569 10.1333 18.9474Z" fill="url(#paint3_linear_icon)"></path><path d="M16.9731 3.78947C16.9731 5.88234 15.2718 7.57895 13.1731 7.57895C11.0744 7.57895 9.37312 5.88234 9.37312 3.78947C9.37312 1.69661 11.0744 0 13.1731 0C15.2718 0 16.9731 1.69661 16.9731 3.78947Z" fill="url(#paint4_linear_icon)"></path><defs><linearGradient id="paint0_linear_icon" x1="1.9" y1="24" x2="26.4917" y2="-24.0554" gradientUnits="userSpaceOnUse"><stop stop-color="#239092"></stop><stop offset="0.624978" stop-color="#97C8C9"></stop></linearGradient><linearGradient id="paint1_linear_icon" x1="1.9" y1="24" x2="26.4917" y2="-24.0554" gradientUnits="userSpaceOnUse"><stop stop-color="#239092"></stop><stop offset="0.624978" stop-color="#97C8C9"></stop></linearGradient><linearGradient id="paint2_linear_icon" x1="1.9" y1="24" x2="26.4917" y2="-24.0554" gradientUnits="userSpaceOnUse"><stop stop-color="#239092"></stop><stop offset="0.624978" stop-color="#97C8C9"></stop></linearGradient><linearGradient id="paint3_linear_icon" x1="1.9" y1="24" x2="26.4917" y2="-24.0554" gradientUnits="userSpaceOnUse"><stop stop-color="#239092"></stop><stop offset="0.624978" stop-color="#97C8C9"></stop></linearGradient><linearGradient id="paint4_linear_icon" x1="1.9" y1="24" x2="26.4917" y2="-24.0554" gradientUnits="userSpaceOnUse"><stop stop-color="#239092"></stop><stop offset="0.624978" stop-color="#97C8C9"></stop></linearGradient></defs></svg>`
                }
              },
              {
                tag: "span",
                styles: {
                  lineHeight: "2em"
                },
                properties: {
                  innerText: "Build Graph"
                }
              }
            ],
            listeners: [
              {
                type: "click",
                listener: async () => {
                  if (this.itemIDs.length == 0) {
                    new ztoolkit.ProgressWindow("Connected Papers").createLine({ text: "Please select a Zotero Item and click Add Origin first, then click Build Graph.", type: "connectedpapers" }).show();
                    return;
                  }
                  const items = this.itemIDs.map((id) => Zotero.Items.get(id));
                  relatedContainer.querySelectorAll(".normal-items .item")?.forEach((e) => e.remove());
                  relatedContainer.querySelectorAll(".prior-items .item")?.forEach((e) => e.remove());
                  relatedContainer.querySelectorAll(".deriv-items .item")?.forEach((e) => e.remove());
                  const graphdata = await this.refresh(items);
                  ztoolkit.log("graphdata", graphdata);
                  const app = this.frame.contentWindow.app;
                  Object.values(graphdata.nodes).sort((a, b) => b.year - a.year).forEach((paper) => {
                    this.addItem(
                      relatedContainer.querySelector(".normal-items"),
                      this.paper2Info(paper),
                      app.paper_to_color(paper)
                    );
                  });
                  graphdata.common_references.sort((a, b) => b.year - a.year).forEach((paper) => {
                    const itemNode = this.addItem(
                      relatedContainer.querySelector(".prior-items"),
                      this.paper2Info(paper),
                      app.paper_to_color(paper)
                    );
                    itemNode.setAttribute("local", paper.local_citations.join("+"));
                  });
                  graphdata.common_citations.sort((a, b) => b.year - a.year).forEach((paper) => {
                    const itemNode = this.addItem(
                      relatedContainer.querySelector(".deriv-items"),
                      this.paper2Info(paper),
                      app.paper_to_color(paper)
                    );
                    itemNode.setAttribute("local", paper.local_references.join("+"));
                  });
                }
              }
            ]
          },
          // node container
          {
            tag: "div",
            styles: {
              flexGrow: "1",
              overflowY: "auto",
              display: "flex",
              flexDirection: "row"
            },
            classList: ["items-container"],
            children: [
              {
                tag: "div",
                classList: ["prior-items"],
                styles: {
                  display: "none",
                  overflowY: "auto"
                }
              },
              {
                tag: "div",
                classList: ["normal-items"],
                styles: {
                  overflowY: "auto"
                }
              },
              {
                tag: "div",
                classList: ["deriv-items"],
                styles: {
                  display: "none",
                  overflowY: "auto"
                }
              }
            ]
          },
          {
            tag: "div",
            styles: {
              display: "flex"
            },
            children: [
              {
                tag: "div",
                id: "prior-works",
                classList: ["filter-button"],
                properties: {
                  innerText: "Prior Works"
                },
                listeners: [
                  {
                    type: "click",
                    listener: () => {
                      const w1 = this.relatedContainer?.querySelector("#prior-works");
                      const w2 = this.relatedContainer?.querySelector("#deriv-works");
                      const i1 = this.relatedContainer.querySelector(".prior-items");
                      const i2 = this.relatedContainer.querySelector(".deriv-items");
                      const i0 = this.relatedContainer.querySelector(".normal-items");
                      w2.classList.remove("activate");
                      i2.style.display = "none";
                      i0.style.borderLeft = i0.style.borderRight = i1.style.borderLeft = i1.style.borderRight = "none";
                      if (w1?.classList.contains("activate")) {
                        w1.classList.remove("activate");
                        i1.style.display = "none";
                        i1.style.borderLeft = "none";
                        i0.style.borderRight = "none";
                        i0.style.width = "100%";
                      } else {
                        w1.classList.add("activate");
                        i1.style.display = "";
                        i0.style.width = i1.style.width = "50%";
                        i0.style.borderLeft = ".5px solid #cecece";
                        i1.style.borderRight = ".5px solid #cecece";
                      }
                    }
                  }
                ]
              },
              {
                tag: "div",
                id: "deriv-works",
                classList: ["filter-button"],
                attributes: {
                  activate: "false"
                },
                properties: {
                  innerText: "Derivative Works"
                },
                listeners: [
                  {
                    type: "click",
                    listener: () => {
                      const w2 = this.relatedContainer?.querySelector("#prior-works");
                      const w1 = this.relatedContainer?.querySelector("#deriv-works");
                      const i2 = this.relatedContainer.querySelector(".prior-items");
                      const i1 = this.relatedContainer.querySelector(".deriv-items");
                      const i0 = this.relatedContainer.querySelector(".normal-items");
                      w2.classList.remove("activate");
                      i2.style.display = "none";
                      i0.style.borderLeft = i0.style.borderRight = i1.style.borderLeft = i1.style.borderRight = "none";
                      if (w1?.classList.contains("activate")) {
                        w1.classList.remove("activate");
                        i1.style.display = "none";
                        i0.style.width = "100%";
                      } else {
                        w1.classList.add("activate");
                        i1.style.display = "";
                        i0.style.width = i1.style.width = "50%";
                        i0.style.borderRight = ".5px solid #cecece";
                        i1.style.borderLeft = ".5px solid #cecece";
                      }
                    }
                  }
                ]
              }
            ]
          }
        ]
      }, box);
      this.relatedContainer = relatedContainer;
    }
    /**
     * 图谱节点和列表节点同时触发状态
     * @param arg 
     */
    setNodeState(arg) {
      if (arg.state == "selected") {
        let selectedItemNode;
        Array.prototype.forEach.call(
          this.relatedContainer?.querySelectorAll(".items-container .item"),
          (itemNode) => {
            if (itemNode._ref.identifiers.paperID == arg.paperID) {
              itemNode.classList.add("selected");
              selectedItemNode = itemNode;
            } else {
              itemNode.classList.remove("selected");
            }
          }
        );
        let src = "Nodes";
        this.zoteroColor = true;
        const parent = selectedItemNode.parentElement;
        if (parent.classList.contains("prior-items")) {
          src = "Prior";
          this.zoteroColor = false;
        } else if (parent.classList.contains("deriv-items")) {
          this.zoteroColor = false;
          src = "Deriv";
        }
        this.frame.contentWindow.GLOBAL_SELECTED_PAPER.value = {
          paper_id: arg.paperID,
          src
        };
        [
          ...this.relatedContainer?.querySelectorAll(".prior-items .item"),
          ...this.relatedContainer?.querySelectorAll(".deriv-items .item")
        ].forEach((itemNode) => {
          if (itemNode.getAttribute("local").indexOf(arg.paperID) >= 0) {
            itemNode.classList.add("highlight");
          } else {
            itemNode.classList.remove("highlight");
          }
        });
        Array.prototype.forEach.call(
          this.relatedContainer?.querySelectorAll(".normal-items .item"),
          (itemNode) => {
            const local = selectedItemNode.getAttribute("local");
            if (local && local.indexOf(itemNode._ref.identifiers.paperID) >= 0) {
              itemNode.classList.add("highlight");
            } else {
              itemNode.classList.remove("highlight");
            }
          }
        );
      } else if (arg.state == "hover") {
        this.frame.contentWindow.GLOBAL_HOVER_PAPER.value = {
          paper_id: arg.paperID,
          src: "Nodes"
        };
        Array.prototype.forEach.call(
          this.relatedContainer?.querySelectorAll(".item"),
          (itemNode) => {
            if (this.frame.contentWindow.GLOBAL_SELECTED_PAPER.value?.paper_id == itemNode._ref.identifiers.paperID) {
              return;
            }
            if (itemNode._ref.identifiers.paperID == arg.paperID) {
              itemNode.classList.add("hover");
            } else {
              itemNode.classList.remove("hover");
            }
          }
        );
      }
    }
    addItem(parent, info, color) {
      let tipUI, timer;
      const itemNode = ztoolkit.UI.appendElement({
        tag: "div",
        classList: ["item"],
        attributes: {
          "zotero-item-id": info?._itemID
        },
        properties: {
          _ref: info
        },
        styles: {
          display: "flex",
          flexDirection: "row",
          height: "2em",
          justifyContent: "space-between",
          alignItems: "center",
          padding: "0 .25em"
        },
        children: [
          {
            tag: "div",
            styles: {
              width: "2em",
              height: "2em",
              display: "flex",
              justifyContent: "center",
              alignItems: "center"
            },
            children: [
              color ? {
                tag: "div",
                classList: ["color-circle"],
                styles: {
                  width: "1.2em",
                  height: "1.2em",
                  borderRadius: "50%",
                  backgroundColor: color
                },
                listeners: [
                  {
                    type: "mouseenter",
                    listener: () => {
                      this.setNodeState({ state: "hover", paperID: info.identifiers.paperID });
                    }
                  },
                  {
                    type: "mouseleave",
                    listener: () => {
                      this.setNodeState({ state: "hover", paperID: "" });
                    }
                  },
                  {
                    type: "click",
                    listener: () => {
                      this.setNodeState({ state: "selected", paperID: info.identifiers.paperID });
                      new ztoolkit.Clipboard().addText(info.identifiers.DOI, "text/unicode").copy();
                    }
                  }
                ]
              } : {
                tag: "div",
                styles: {
                  width: "2em",
                  height: "2em",
                  display: "flex",
                  justifyContent: "center",
                  alignItems: "center"
                },
                classList: ["icon"],
                properties: {
                  innerHTML: `<svg width="24" height="24" viewBox="0 0 24 24" fill="#7a306c" xmlns="http://www.w3.org/2000/svg" class="graph-action-icon mr-[6px]" data-v-f4c185ee=""><path d="M19 13H5V11H19V13Z"></path></svg>`
                },
                listeners: [
                  {
                    type: "click",
                    listener: () => {
                      this.itemIDs = this.itemIDs.filter((i) => i != info._itemID);
                      itemNode.remove();
                      this.updateAddOrRemove();
                    }
                  }
                ]
              }
            ]
          },
          {
            tag: "div",
            classList: ["title-box"],
            styles: {
              width: "100%",
              height: "2em",
              flex: "1",
              boxSizing: "border-box"
            },
            children: [
              {
                tag: "div",
                namespace: "xul",
                classList: ["title"],
                styles: {
                  whiteSpace: "nowrap",
                  overflow: "hidden",
                  textOverflow: "ellipsis",
                  lineHeight: "2em"
                },
                properties: {
                  textContent: info.title
                }
              }
            ],
            listeners: [
              {
                type: "mouseenter",
                listener: () => {
                  this.setNodeState({ state: "hover", paperID: info.identifiers.paperID });
                }
              },
              // 浮窗
              {
                type: "mouseup",
                listener: (event) => {
                  if (event.button != 2) {
                    return;
                  }
                  itemNode.classList.add("active");
                  let timeout = parseInt(Zotero.Prefs.get(`${config.addonRef}.showTipAfterMillisecond`));
                  const position = Zotero.Prefs.get("extensions.zotero.layout", true) == "stacked" ? "top center" : "left";
                  timer = window.setTimeout(async () => {
                    const rect = itemNode.getBoundingClientRect();
                    tipUI = this.views.showTipUI(rect, info, position, info.identifiers.DOI);
                    if (!itemNode.classList.contains("active")) {
                      tipUI.container.style.display = "none";
                    }
                  }, timeout);
                }
              },
              {
                type: "mouseleave",
                listener: () => {
                  itemNode.classList.remove("active");
                  window.clearTimeout(timer);
                  if (!tipUI) {
                    return;
                  }
                  const timeout = tipUI.removeTipAfterMillisecond;
                  tipUI.tipTimer = window.setTimeout(async () => {
                    for (let i = 0; i < timeout / 2; i++) {
                      if (this.relatedContainer.querySelector(".active")) {
                        return;
                      }
                      await Zotero.Promise.delay(1 / 1e3);
                    }
                    tipUI && tipUI.clear();
                  }, timeout / 2);
                }
              },
              // 从列表定位到节点
              {
                type: "click",
                listener: () => {
                  tipUI && tipUI.clear();
                  this.setNodeState({ state: "selected", paperID: info.identifiers.paperID });
                  new ztoolkit.Clipboard().addText(info.identifiers.DOI, "text/unicode").copy();
                }
              }
            ]
          }
        ]
      }, parent);
      ztoolkit.UI.appendElement({
        tag: "div",
        styles: {
          width: "2em",
          height: "2em",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          cursor: "pointer"
        },
        properties: {
          innerHTML: info?._itemID ? `<svg viewBox="0 0 743 743" width="1.2em" height="1.2em"  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" overflow="hidden"><defs><clipPath id="clip0"><rect x="769" y="697" width="743" height="743"/></clipPath></defs><g transform="translate(-769 -697)"><path d="M769 1068.5C769 863.326 935.326 697 1140.5 697 1345.67 697 1512 863.326 1512 1068.5 1512 1273.67 1345.67 1440 1140.5 1440 935.326 1440 769 1273.67 769 1068.5Z" fill="#ca6363" fill-rule="evenodd"/><path d="M1162.25 901C1173.47 901 1181.89 904.166 1190.66 912.612L1316.22 1032.96C1327.09 1042.81 1332 1054.07 1332 1068.5 1332 1082.58 1326.74 1094.19 1316.22 1104.04L1190.66 1224.39C1181.89 1232.48 1173.47 1236 1162.25 1236 1141.2 1236 1126.12 1220.52 1126.12 1198.35 1126.12 1187.79 1130.68 1177.24 1138.75 1170.55L1178.73 1133.95 1215.56 1107.56 1143.66 1112.13 989.685 1112.13C965.838 1112.13 949 1093.13 949 1068.5 949 1043.52 965.838 1024.87 989.685 1024.87L1143.66 1024.87 1215.21 1029.09 1179.78 1003.05 1138.75 966.451C1130.68 959.766 1126.12 949.209 1126.12 938.3 1126.12 916.483 1141.2 901 1162.25 901Z" fill="#FFFFFF" fill-rule="evenodd"/></g></svg>` : `<svg viewBox="0 0 743 743" width="1.2em" height="1.2em" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" overflow="hidden"><defs><clipPath id="clip0"><rect x="944" y="711" width="743" height="743"/></clipPath></defs><g transform="translate(-944 -711)"><path d="M944 1082.5C944 877.326 1110.33 711 1315.5 711 1520.67 711 1687 877.326 1687 1082.5 1687 1287.67 1520.67 1454 1315.5 1454 1110.33 1454 944 1287.67 944 1082.5Z" fill="#9cb8b8" fill-rule="evenodd"/><path d="M1159.5 1083.5 1472.1 1083.5" stroke="#FFFFFF" stroke-width="87.0833" stroke-linecap="round" stroke-miterlimit="8" fill="none" fill-rule="evenodd"/><path d="M1316.5 927.5 1316.5 1240.1" stroke="#FFFFFF" stroke-width="87.0833" stroke-linecap="round" stroke-miterlimit="8" fill="none" fill-rule="evenodd"/></g></svg>`
        },
        listeners: [
          {
            type: "click",
            listener: async (event) => {
              if (info._itemID) {
                ZoteroPane.selectItem(info._itemID);
              } else {
                const DOI = info.identifiers.DOI;
                const originItems = this.itemIDs.map((id) => Zotero.Items.get(id));
                let add = async (collections2) => {
                  let popupWin = new ztoolkit.ProgressWindow("[Pending] Adding", { closeTime: -1 }).createLine({ text: DOI, type: "default" }).show();
                  const newItem = await this.views.utils.createItemByZotero({ DOI }, collections2);
                  originItems.forEach(async (item) => {
                    newItem.addRelatedItem(item);
                    item.addRelatedItem(newItem);
                    await item.saveTx({ skipSelect: true, skipNotifier: true });
                    await newItem.saveTx({ skipSelect: true, skipNotifier: true });
                  });
                  popupWin.changeHeadline("[Done] Adding");
                  popupWin.changeLine({ type: "success" });
                  popupWin.startCloseTimer(3e3);
                  document.querySelector("#build-graph").click();
                };
                const collection = ZoteroPane.getSelectedCollection();
                let collections = [];
                if (collection) {
                  collections = [collection.id];
                }
                if (event.ctrlKey || event.metaKey) {
                  let rect = itemNode.getBoundingClientRect();
                  let menuPopup = document.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul", "menupopup");
                  document.querySelector("#browser").append(menuPopup);
                  let collections2 = Zotero.Collections.getByLibrary(1);
                  for (let col of collections2) {
                    let menuItem = Zotero.Utilities.Internal.createMenuForTarget(
                      col,
                      menuPopup,
                      null,
                      async (event2, collection2) => {
                        if (event2.target.tagName == "menuitem") {
                          ztoolkit.log(collection2);
                          menuPopup.remove();
                          add([collection2.id]);
                          event2.stopPropagation();
                        }
                      }
                    );
                    menuPopup.append(menuItem);
                  }
                  menuPopup.openPopupAtScreen(rect.left, rect.top + rect.height, true);
                } else {
                  add(collections);
                }
              }
            }
          }
        ]
      }, itemNode);
      return itemNode;
    }
    async getPaperID(item) {
      const DOI = item.getField("DOI");
      const title = item.getField("title");
      if (DOI) {
        let res = await this.requests.get(
          `https://rest.connectedpapers.com/id_translator/doi/${DOI}`
        );
        return res.paperId;
      } else {
        const api = `https://rest.connectedpapers.com/search/${escape(title)}/1`;
        let response = await this.requests.post(api);
        if (response) {
          if (response?.results?.length) {
            let item2 = response.results[0];
            return item2.id;
          }
        }
      }
    }
    async buildGraphData(items) {
      const popupWin = new ztoolkit.ProgressWindow("Connected Papers", { closeOtherProgressWindows: true, closeTime: -1 }).createLine({ text: "Initializing", type: "connectedpapers" }).show();
      let id = (await Promise.all(items.map(async (item) => await this.getPaperID(item)))).join("+");
      const graphData = await buildGraphData(id, popupWin);
      if (!graphData) {
        return;
      }
      const totalNum = Object.keys(graphData.nodes).length;
      popupWin.changeLine({ text: `[1/${totalNum}] Indexing`, progress: 1, type: "default" });
      let search = {};
      for (let paperID in graphData.nodes) {
        search[paperID] = this.views.utils.searchItem(this.paper2Info(graphData.nodes[paperID]));
      }
      let i = 0;
      for (let paperID in graphData.nodes) {
        i += 1;
        let localItem;
        try {
          localItem = await search[paperID];
        } catch {
        }
        popupWin.changeLine({ text: `[${i}/${totalNum}] Indexing`, progress: 100 * i / totalNum });
        graphData.nodes[paperID]._itemID = localItem?.id;
      }
      ztoolkit.log(graphData);
      popupWin.changeLine({ text: `[${totalNum}/${totalNum}] Indexing`, type: "success" });
      popupWin.startCloseTimer(3e3);
      return graphData;
    }
    initItemsPane() {
      const mainNode = document.querySelector("#item-tree-main-default");
      const minHeight = 200;
      const graphContainer = ztoolkit.UI.createElement(document, "div", {
        id: "graph-view",
        styles: {
          width: "100%",
          minHeight: `${minHeight}px`,
          height: Zotero.Prefs.get(`${config.addonRef}.graphView.height`),
          display: "none"
        }
      });
      this.graphContainer = graphContainer;
      const frame = this.frame = ztoolkit.UI.createElement(document, "iframe", { namespace: "html" });
      frame.setAttribute("src", `chrome://${config.addonRef}/content/dist/index.html`);
      frame.style.border = "none";
      frame.style.outline = "none";
      frame.style.width = "100%";
      frame.style.height = graphContainer.style.height;
      frame.style.overflow = "hidden";
      frame.style.backgroundColor = "#ffffff";
      graphContainer.append(frame);
      mainNode.append(graphContainer);
      const resizer = ztoolkit.UI.createElement(document, "div", {
        styles: {
          height: `1px`,
          width: "100%",
          backgroundColor: "#cecece",
          cursor: "ns-resize"
        }
      });
      graphContainer.insertBefore(resizer, frame);
      let y = 0, x = 0;
      let h = 0, w = 0;
      const mouseDownHandler = function(e) {
        frame.style.display = "none";
        y = e.clientY;
        x = e.clientX;
        const rect = graphContainer.getBoundingClientRect();
        h = rect.height;
        w = rect.width;
        document.addEventListener("mousemove", mouseMoveHandler);
        document.addEventListener("mouseup", mouseUpHandler);
      };
      const mouseMoveHandler = (e) => {
        const dy = e.clientY - y;
        let hh = h - dy;
        const height = `${hh <= minHeight ? minHeight : hh}px`;
        graphContainer.style.height = height;
        frame.style.height = height;
        this.boxAfter.style.height = height;
        Zotero.Prefs.set(`${config.addonRef}.graphView.height`, height);
      };
      const mouseUpHandler = () => {
        frame.style.display = "";
        document.removeEventListener("mousemove", mouseMoveHandler);
        document.removeEventListener("mouseup", mouseUpHandler);
      };
      resizer.addEventListener("mousedown", mouseDownHandler);
    }
    paper2Info(paper) {
      return {
        identifiers: { DOI: paper.doi, paperID: paper.paperId },
        title: paper.title,
        year: paper.year,
        authors: paper.authors?.map((i) => i.name) || [],
        abstract: paper.abstract,
        primaryVenue: paper.venue,
        source: "connected papers",
        tags: paper.fieldsOfStudy,
        type: "",
        _itemID: paper._itemID
      };
    }
    async refresh(items) {
      ztoolkit.log("refresh", items);
      const graphData = await this.buildGraphData(items);
      ztoolkit.log(graphData);
      const app = this.frame.contentWindow.app;
      app.graphdata = graphData;
      app.$route.params.origin_id = graphData.start_id || graphData.start_ids.join("+");
      app._paper_to_color = app._paper_to_color || app.paper_to_color;
      app.paper_to_color = (paper) => {
        let res_color = app._paper_to_color(paper);
        if (this.zoteroColor && paper._itemID) {
          const c = "#c22727";
          let res_hsl = d3.hsl(res_color);
          res_hsl.h = d3.hsl(c).h;
          res_hsl.s = (res_hsl.s + 2 * d3.hsl(c).s) / 3;
          return res_hsl + "";
        }
        return res_color;
      };
      app.refresh_graph();
      let scrollToNode = (className) => {
        const parent = document.querySelector(".normal-items");
        const target = parent.querySelector(`.${className}`);
        const firstChild = parent.firstChild;
        parent.scrollTo(0, target.offsetTop - firstChild.offsetTop);
      };
      app.graphdata.sim_node_circles.on("click", (event, it) => {
        const paperID = it.paperId;
        this.setNodeState({ state: "selected", paperID });
        scrollToNode("selected");
      }).on("mouseover", (event, it) => {
        const paperID = it.paperId;
        this.setNodeState({ state: "hover", paperID });
        scrollToNode("hover");
      }).on("mouseout", (event, it) => {
        this.setNodeState({ state: "hover", paperID: "" });
      });
      return graphData;
    }
  };

  // src/hooks.ts
  async function onStartup() {
    await Promise.all([
      Zotero.initializationPromise,
      Zotero.unlockPromise,
      Zotero.uiReadyPromise
    ]);
    await onMainWindowLoad(window);
  }
  async function onMainWindowLoad(win) {
    registerPrefs();
    await Promise.all([
      Zotero.initializationPromise,
      Zotero.unlockPromise,
      Zotero.uiReadyPromise
    ]);
    const show = ztoolkit.ProgressWindow.prototype.show;
    ztoolkit.ProgressWindow.prototype.show = function() {
      Zotero.ProgressWindowSet.closeAll();
      return show.call(this, ...arguments);
    };
    const views = new Views();
    await views.onInit();
    Zotero[config.addonInstance].views = views;
    await new ConnectedPapers(views).init();
  }
  async function onMainWindowUnload(win) {
    ztoolkit.unregisterAll();
    addon.data.dialog?.window?.close();
  }
  function onShutdown() {
    ztoolkit.unregisterAll();
    document.querySelectorAll("#zotero-reference-show-hide-graph-view").forEach((e) => e.remove());
    addon.data.alive = false;
    addon.data.dialog?.window?.close();
    delete Zotero[config.addonInstance];
  }
  async function onPrefsEvent(type, data) {
    switch (type) {
      case "load":
        registerPrefsScripts(data.window);
        break;
      default:
        return;
    }
  }
  var hooks_default = {
    onStartup,
    onShutdown,
    onPrefsEvent,
    onMainWindowLoad,
    onMainWindowUnload
  };

  // src/utils/ztoolkit.ts
  var import_zotero_plugin_toolkit = __toESM(require_dist());
  function createZToolkit() {
    const _ztoolkit = new import_zotero_plugin_toolkit.default();
    initZToolkit(_ztoolkit);
    return _ztoolkit;
  }
  function initZToolkit(_ztoolkit) {
    const env = "development";
    _ztoolkit.basicOptions.log.prefix = `[${config.addonName}]`;
    _ztoolkit.basicOptions.log.disableConsole = env === "production";
    _ztoolkit.UI.basicOptions.ui.enableElementJSONLog = false;
    _ztoolkit.UI.basicOptions.ui.enableElementDOMLog = false;
    _ztoolkit.basicOptions.debug.disableDebugBridgePassword = true;
    _ztoolkit.basicOptions.api.pluginID = config.addonID;
    _ztoolkit.ProgressWindow.setIconURI(
      "default",
      `chrome://${config.addonRef}/content/icons/favicon.png`
    );
    _ztoolkit.ProgressWindow.setIconURI(
      "connectedpapers",
      `chrome://${config.addonRef}/content/icons/connectedpapers.png`
    );
  }

  // src/addon.ts
  var Addon = class {
    constructor() {
      this.data = {
        alive: true,
        env: "development",
        ztoolkit: createZToolkit()
      };
      this.hooks = hooks_default;
      this.api = {};
    }
  };
  var addon_default = Addon;

  // src/index.ts
  var basicTool = new import_basic.BasicTool();
  if (!basicTool.getGlobal("Zotero")[config.addonInstance]) {
    _globalThis.Zotero = basicTool.getGlobal("Zotero");
    defineGlobal("window");
    defineGlobal("document");
    defineGlobal("ZoteroPane");
    defineGlobal("Zotero_Tabs");
    _globalThis.addon = new addon_default();
    defineGlobal("ztoolkit", () => {
      return _globalThis.addon.data.ztoolkit;
    });
    Zotero[config.addonInstance] = addon;
    addon.hooks.onStartup();
  }
  function defineGlobal(name, getter) {
    Object.defineProperty(_globalThis, name, {
      get() {
        return getter ? getter() : basicTool.getGlobal(name);
      }
    });
  }
})();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

sax/lib/sax.js:
  (*! http://mths.be/fromcodepoint v0.1.0 by @mathias *)

crypto-js/ripemd160.js:
  (** @preserve
  	(c) 2012 by Cédric Mesnil. All rights reserved.
  
  	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
  
  	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
  	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
  
  	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  	*)

crypto-js/mode-ctr-gladman.js:
  (** @preserve
   * Counter block mode compatible with  Dr Brian Gladman fileenc.c
   * derived from CryptoJS.mode.CTR
   * Jan Hruby jhruby.web@gmail.com
   *)
*/
